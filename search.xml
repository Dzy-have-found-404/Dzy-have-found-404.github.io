<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>DS18B20外设驱动</title>
    <url>/2020/12/30/DS18b20/</url>
    <content><![CDATA[<blockquote>
<p>应用最广泛的测温传感器</p>
</blockquote>
<a id="more"></a>

<h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>DS18B20通过1-Wire总线进行通信，根据定义，该总线仅需要一条数据线(和地线)即可与中央微处理器进行通信。它的工作温度范围为 -55°C 至 +125°C，在–10°C 至 +85°C 的范围内精确至 0.5°C。 此外，DS18B20可以直接从数据线获取电源（“寄生电源”），而无需外部电源。</p>
<p>每个DS18B20都有一个唯一的64位串行代码，它允许多个DS18B20在同一条1线总线上工作。 因此，使用一个微处理器控制分布在大面积上的许多DS18B20就很简单，DS18B20也由此成为温控系统中最常用的传感器。</p>
<hr>
<h3 id="温度测量工作原理"><a href="#温度测量工作原理" class="headerlink" title="温度测量工作原理"></a>温度测量工作原理</h3><ul>
<li>使用DS18B20时可以将温度传感器的分辨率配置为9、10、11或12位，分别对应于0.5C，0.25C，0.125C和0.0625C的增量；</li>
<li>要启动温度测量和a-D转换，主机必须发出Convert T[44h]命令；</li>
<li>转换后，产生的热数据存储在草稿行内存中的2字节温度寄存器中，DS18B20返回到空闲状态。</li>
</ul>
<h4 id="寄存器格式"><a href="#寄存器格式" class="headerlink" title="寄存器格式"></a>寄存器格式</h4><ul>
<li>DS18B20输出温度数据以摄氏度校准，温度数据以16位符号扩展2的补码形式存储在温度寄存器中；</li>
<li>符号位表示温度是正还是负：正数S=0，负数S=1；</li>
<li>如果DS18B20配置为12位分辨率，则温度寄存器中的所有位都将包含有效数据；</li>
<li>分辨率位为1，代表加上该位的一个增量。</li>
</ul>
<p><strong>LS Byte：</strong></p>
<table>
<thead>
<tr>
<th align="center">bit 7</th>
<th align="center">bit 6</th>
<th align="center">bit 5</th>
<th align="center">bit 4</th>
<th align="center">bit 3</th>
<th align="center">bit 2</th>
<th align="center">bit 1</th>
<th align="center">bit 0</th>
</tr>
</thead>
<tbody><tr>
<td align="center">2^3</td>
<td align="center">2^2</td>
<td align="center">2^1</td>
<td align="center">2^0</td>
<td align="center">2^-1</td>
<td align="center">2^-2</td>
<td align="center">2^-3</td>
<td align="center">2^-4</td>
</tr>
</tbody></table>
<p><strong>MS Byte</strong></p>
<table>
<thead>
<tr>
<th align="center">bit 15</th>
<th align="center">bit 14</th>
<th align="center">bit 13</th>
<th align="center">bit 12</th>
<th align="center">bit 11</th>
<th align="center">bit 10</th>
<th align="center">bit 9</th>
<th align="center">bit 8</th>
</tr>
</thead>
<tbody><tr>
<td align="center">S</td>
<td align="center">S</td>
<td align="center">S</td>
<td align="center">S</td>
<td align="center">S</td>
<td align="center">2^6</td>
<td align="center">2^5</td>
<td align="center">2^4</td>
</tr>
</tbody></table>
<h4 id="温度-DATA关系表-示例"><a href="#温度-DATA关系表-示例" class="headerlink" title="温度/DATA关系表(示例)"></a>温度/DATA关系表(示例)</h4><table>
<thead>
<tr>
<th align="center">温度</th>
<th align="center">数字信号输出(二进制)</th>
<th align="center">数字信号输出(十六进制)</th>
<th align="center">计算过程</th>
</tr>
</thead>
<tbody><tr>
<td align="center">+125°C</td>
<td align="center">0000 0111 1101 0000</td>
<td align="center">07D0h</td>
<td align="center">2^0+2^2+2^3+2^4+2^5+2^6=125</td>
</tr>
<tr>
<td align="center">+85°C</td>
<td align="center">0000 0101 0101 0000</td>
<td align="center">0550h</td>
<td align="center">2^0+2^2+2^4+2^6=85</td>
</tr>
<tr>
<td align="center">+25.0625°C</td>
<td align="center">0000 0001 1001 0001</td>
<td align="center">0192h</td>
<td align="center">2^-4+2^0+2^3+2^4=25.0625</td>
</tr>
<tr>
<td align="center">+10.125°C</td>
<td align="center">0000 0000 1010 0010</td>
<td align="center">00A2h</td>
<td align="center">2^-3+2^1+2^3=10.125</td>
</tr>
<tr>
<td align="center">+0.5°C</td>
<td align="center">0000 0000 0000 1000</td>
<td align="center">0008h</td>
<td align="center">2^-1=0.5</td>
</tr>
<tr>
<td align="center">0°C</td>
<td align="center">0000 0000 0000 0000</td>
<td align="center">0000h</td>
<td align="center">0</td>
</tr>
<tr>
<td align="center">-0.5°C</td>
<td align="center">1111 1111 1111 1000</td>
<td align="center">FFF8h</td>
<td align="center">2^-1=0.5</td>
</tr>
<tr>
<td align="center">-10.125°C</td>
<td align="center">1111 1111 0101 1110</td>
<td align="center">FF5Eh</td>
<td align="center">2^-3+2^1+2^3=10.125</td>
</tr>
<tr>
<td align="center">-25.0625°C</td>
<td align="center">1111 1110 0110 1111</td>
<td align="center">FE6Fh</td>
<td align="center">2^-4+2^0+2^3+2^4=25.0625</td>
</tr>
<tr>
<td align="center">-55°C</td>
<td align="center">1111 1100 1001 0000</td>
<td align="center">FC90h</td>
<td align="center">2^0+2^2+2^3+2^4+2^5+2^6=125</td>
</tr>
</tbody></table>
<hr>
<h3 id="寄存器指令"><a href="#寄存器指令" class="headerlink" title="寄存器指令"></a>寄存器指令</h3><p><strong>DS18B20的操作顺序为：</strong></p>
<ol>
<li><p>复位指令</p>
</li>
<li><p>ROM指令   </p>
<img src="/upload_image/image-20201224163342870.png" alt="image-20201224163342870" style="zoom:67%;" />
</li>
<li><p>DS18B20功能指令</p>
<img src="/upload_image/image-20201224163247580.png" alt="image-20201224163247580" style="zoom: 67%;" />

</li>
</ol>
<p><strong>常用ROM指令：</strong></p>
<p><strong>SKIP ROM [CCh]：</strong>主机可以使用该命令同时寻址总线上的所有设备，而无需发送任何ROM代码信息。</p>
<p>​        用法1：通过允许主机从机读取而不发送设备的64位ROM代码来节省时间(只有在总线上只有一个从设备时可用)</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">ds_write_byte(bus,<span class="number">0xcc</span>);</span><br><span class="line">ds_write_byte(bus,<span class="number">0xbe</span>);</span><br><span class="line">   <span class="comment">//主机读取暂存器的信息，从字节0的最低有效位开始一直到暂存器直到读取第9个字节（8-0）</span></span><br><span class="line">   <span class="comment">//只有在总线上只有DS18B20的时候，[BEh]指令才能跟随在[CCh]指令之后；否则冲突</span></span><br><span class="line">   <span class="comment">//在这种情况下，可以允许主机从从机读取数据而不发送设备的64位ROM代码来节省时间</span></span><br></pre></td></tr></table></figure>
<p>​        用法2：主机可以通过发出Skip ROM命令和随后的Convert T [44h]命令，使总线上的所有DS18B20都同时执行温度转换</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">ds_write_byte(bus,<span class="number">0xcc</span>);</span><br><span class="line">   <span class="comment">//跳过ROM代码信息的发送</span></span><br><span class="line">ds_write_byte(bus,<span class="number">0x44</span>);</span><br><span class="line">   <span class="comment">//使总线上所有DS18B20都同时执行温度转换</span></span><br></pre></td></tr></table></figure>
<p><strong>常用功能指令：</strong></p>
<p><strong>CONVERT T [44h]：</strong>该命令启动一次温度转换。 转换后，产生的热数据被存储在暂存器的2字节温度寄存器中，DS18B20返回其低功耗空闲状态。 </p>
<p>**WRITE SCRATCHPAD  [4Eh]： **该命令允许主机将3个字节的数据写入DS18B20的暂存器。 第一个数据字节写入TH寄存器（暂存器的字节2），第二个字节写入TL寄存器（字节3），第三个字节写入配置寄存器（字节4）。</p>
<p><strong>READ SCRATCHPAD [BEh] ：</strong>该命令允许主机读取暂存器的内容。 数据传输从字节0的最低有效位开始，一直到暂存器，直到读取第9个字节（字节8 – CRC）</p>
<img src="/upload_image/image-20201224163128270.png" alt="image-20201224163128270" style="zoom: 67%;" />

<hr>
<h3 id="MSP430程序"><a href="#MSP430程序" class="headerlink" title="MSP430程序"></a>MSP430程序</h3><p>&lt;DS18B20.h&gt;：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> WL_DS18B20_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> WL_DS18B20_H</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">DS18B20_BUS_DEF</span>                                    //枚举</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	DS18B20_BUS_1,                                      <span class="comment">//枚举第一项默认为0</span></span><br><span class="line">	DS18B20_BUS_DEF_END                                 <span class="comment">//1</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">tem_change</span><span class="params">(uint8 bus)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">float</span> <span class="title">get_temperature</span><span class="params">(uint8 bus)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p>&lt;DS18B20.c&gt;：</p>
<ol>
<li><p>引脚操作函数</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">set_ds_output</span><span class="params">(uint8 bus)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">switch</span>(bus)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">case</span> DS18B20_BUS_1:</span><br><span class="line">			P7DIR |= BIT2;			<span class="comment">//P7.3设置为输出</span></span><br><span class="line">			<span class="keyword">break</span>; 						          </span><br><span class="line">		<span class="keyword">default</span>:</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">set_ds_input</span><span class="params">(uint8 bus)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">switch</span>(bus)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">case</span> DS18B20_BUS_1:</span><br><span class="line">			P7DIR &amp;= ~BIT2;			<span class="comment">//P7.3设置为输入</span></span><br><span class="line">			<span class="keyword">break</span>;						          </span><br><span class="line">		<span class="keyword">default</span>:</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">set_ds_high</span><span class="params">(uint8 bus)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">switch</span>(bus)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">case</span> DS18B20_BUS_1:</span><br><span class="line">			P7OUT |= BIT2;			<span class="comment">//P7.2拉高</span></span><br><span class="line">			<span class="keyword">break</span>;            </span><br><span class="line">		<span class="keyword">default</span>:</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">	&#125;	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">set_ds_low</span><span class="params">(uint8 bus)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">switch</span>(bus)</span><br><span class="line">	&#123; </span><br><span class="line">		<span class="keyword">case</span> DS18B20_BUS_1:</span><br><span class="line">			P7OUT &amp;= ~BIT2;			<span class="comment">//P7.2拉低</span></span><br><span class="line">			<span class="keyword">break</span>;            </span><br><span class="line">		<span class="keyword">default</span>:</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">	&#125;	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">uint8 <span class="title">read_ds</span><span class="params">(uint8 bus)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	uint8 data;</span><br><span class="line">	<span class="keyword">switch</span>(bus)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">case</span> DS18B20_BUS_1:</span><br><span class="line">			data=(P7IN &amp; BIT2)?<span class="number">1</span>:<span class="number">0</span>;</span><br><span class="line">			<span class="keyword">break</span>;						          </span><br><span class="line">		<span class="keyword">default</span>:</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">	&#125;	</span><br><span class="line">    <span class="keyword">return</span> data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Reset_18b20</span><span class="params">(uint8 bus)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   set_ds_output(bus);</span><br><span class="line">   set_ds_high(bus);</span><br><span class="line">   delay_us(<span class="number">1</span>);        <span class="comment">//1us</span></span><br><span class="line">   set_ds_low(bus);</span><br><span class="line">   delay_us(<span class="number">550</span>); 	  <span class="comment">//当总线停留在低电平超过480us，总线上所有器件都将被复位，这里</span></span><br><span class="line">					<span class="comment">//延时约530us总线停留在低电平超过480μs，总线上的所有器件都将被复位。</span></span><br><span class="line"></span><br><span class="line">   set_ds_high(bus);  <span class="comment">//产生复位脉冲后，微处理器释放总线,让总线处于空闲状态，原因查18b20中文资料</span></span><br><span class="line"></span><br><span class="line">   delay_us(<span class="number">45</span>);; 	  <span class="comment">//释放总线后，以便从机18b20通过拉低总线来指示其是否在线</span></span><br><span class="line">                 	  <span class="comment">//存在检测高电平时间:15~60us,所以延时44us,进行1-wire presence //detect（单线存在检测）</span></span><br><span class="line"></span><br><span class="line">   set_ds_input(bus);</span><br><span class="line">   <span class="keyword">if</span>(read_ds(bus)==<span class="number">0</span>)</span><br><span class="line">        ds18b20_flag=<span class="number">1</span>;     <span class="comment">//detect 18b20 success</span></span><br><span class="line">   <span class="keyword">else</span></span><br><span class="line">        ds18b20_flag=<span class="number">0</span>;     <span class="comment">//detect 18b20 fail</span></span><br><span class="line">   delay_us(<span class="number">28</span>);            <span class="comment">//存在检测低电平时间：60~240us，所以延时约140us</span></span><br><span class="line">   set_ds_output(bus);</span><br><span class="line">    </span><br><span class="line">   set_ds_high(bus);        <span class="comment">//再次拉高总线，让总线处于空闲状态	</span></span><br><span class="line">   delay_us(<span class="number">50</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
</li>
<li><p>读写操作函数</p>
<p>读/写时间隙:DS1820 的数据读写是通过时间隙处理位和命令字来确认信息交换。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">uint8 <span class="title">ds_read_bit</span><span class="params">(uint8 bus)</span>    <span class="comment">//读一位</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	uint8 dat;</span><br><span class="line">    set_ds_output(bus);</span><br><span class="line">   	set_ds_low(bus);        	<span class="comment">//单片机（微处理器）将总线拉低</span></span><br><span class="line">	delay_us(<span class="number">1</span>);        	    <span class="comment">//读时隙起始于微处理器将总线拉低至少1us</span></span><br><span class="line">   	set_ds_high(bus);        	<span class="comment">//拉低总线后接着释放总线，让从机18b20能够接管总线，输出有效数据</span></span><br><span class="line">	delay_us(<span class="number">1</span>);</span><br><span class="line">	                		   <span class="comment">//小延时一下，读取18b20上的数据 ,因为从ds18b20上输出的数据</span></span><br><span class="line">							 <span class="comment">//在读&quot;时间隙&quot;下降沿出现15us内有效</span></span><br><span class="line">    set_ds_input(bus);</span><br><span class="line">	dat=read_ds(bus);         <span class="comment">//主机读从机18b20输出的数据，这些数据在读时隙的下降沿出现15us内有效</span></span><br><span class="line">	delay_us(<span class="number">77</span>);   		<span class="comment">//所有读&quot;时间隙&quot;必须60~120us，这里77us</span></span><br><span class="line">	<span class="keyword">return</span>(dat);   			<span class="comment">//返回有效数据</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">uint8 <span class="title">ds_read_byte</span><span class="params">(uint8 bus )</span> 	 <span class="comment">//读一字节</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	uint8 value,i,j;</span><br><span class="line">	value=<span class="number">0</span>;           			<span class="comment">//给初值</span></span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">8</span>;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		j=ds_read_bit(bus);</span><br><span class="line">	    value=(j&lt;&lt;<span class="number">7</span>)|(value&gt;&gt;<span class="number">1</span>); <span class="comment">//这一步的说明在一个word文档里面</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span>(value);        		<span class="comment">//返回一个字节的数据</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ds_write_bit</span><span class="params">(uint8 bus,uint8 dat)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(dat)      			 <span class="comment">//写 1</span></span><br><span class="line">	&#123;</span><br><span class="line">		set_ds_low(bus);</span><br><span class="line">		delay_us(<span class="number">2</span>);     </span><br><span class="line">		<span class="comment">//asm(&quot;NOP&quot;);        //看时序图，至少延时1us，才产生写&quot;时间隙&quot; </span></span><br><span class="line">		set_ds_high(bus);    <span class="comment">//写时间隙开始后的15μs内允许数据线拉到高电平</span></span><br><span class="line">		delay_us(<span class="number">70</span>); 		<span class="comment">//所有写时间隙必须最少持续60us</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span>         			<span class="comment">//写 0</span></span><br><span class="line">	&#123;</span><br><span class="line">		set_ds_low(bus);</span><br><span class="line">		delay_us(<span class="number">64</span>);    	<span class="comment">//主机要生成一个写0 时间隙，必须把数据线拉到低电平并保持至少60μs，这里64us</span></span><br><span class="line">		set_ds_high(bus);</span><br><span class="line">	&#125;	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ds_write_byte</span><span class="params">(uint8 bus,uint8 dat)</span> <span class="comment">//写一个字节</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">uint8 i;</span><br><span class="line">uint8 onebit;        <span class="comment">//一定不要忘了，onebit是一位</span></span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=<span class="number">8</span>;i++) </span><br><span class="line">	&#123;</span><br><span class="line">	    onebit=dat&amp;<span class="number">0x01</span>;</span><br><span class="line">	    dat=dat&gt;&gt;<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">if</span>(onebit)      <span class="comment">//写 1</span></span><br><span class="line">		&#123;</span><br><span class="line">			set_ds_low(bus);</span><br><span class="line">			delay_us(<span class="number">2</span>);     </span><br><span class="line">			<span class="comment">//asm(&quot;NOP&quot;);        //看时序图，至少延时1us，才产生写&quot;时间隙&quot; </span></span><br><span class="line">			set_ds_high(bus);     <span class="comment">//写时间隙开始后的15μs内允许数据线拉到高电平</span></span><br><span class="line">			delay_us(<span class="number">70</span>);       <span class="comment">//所有写时间隙必须最少持续60us</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span>         <span class="comment">//写 0</span></span><br><span class="line">		&#123;</span><br><span class="line">			set_ds_low(bus);</span><br><span class="line">			delay_us(<span class="number">64</span>);    <span class="comment">//主机要生成一个写0 时间隙，必须把数据线拉到低电平并保持至少60μs，这里64us</span></span><br><span class="line">			set_ds_high(bus);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
</li>
<li><p>温度功能函数</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">tem_change</span><span class="params">(uint8 bus)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Reset_18b20(bus);</span><br><span class="line">	delay_us(<span class="number">100</span>);              <span class="comment">//约2ms</span></span><br><span class="line">	ds_write_byte(bus,<span class="number">0xcc</span>);</span><br><span class="line">    <span class="comment">//跳过ROM代码信息的发送</span></span><br><span class="line">	ds_write_byte(bus,<span class="number">0x44</span>);</span><br><span class="line">    <span class="comment">//使总线上所有DS18B20都同时执行温度转换</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>获取温度函数，返回值为一个十进制的温度值，精度为0.0625</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">float</span> <span class="title">get_temperature</span><span class="params">(uint8 bus)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    uint8 a,b;</span><br><span class="line">	Reset_18b20(bus);</span><br><span class="line">	delay_us(<span class="number">150</span>);              <span class="comment">//约2ms</span></span><br><span class="line">	ds_write_byte(bus,<span class="number">0xcc</span>);</span><br><span class="line">	ds_write_byte(bus,<span class="number">0xbe</span>);</span><br><span class="line">    <span class="comment">//主机读取暂存器的信息，从字节0的最低有效位开始一直到暂存器直到读取第9个字节（8-0）</span></span><br><span class="line">    <span class="comment">//只有在总线上只有DS18B20的时候，[BEh]指令才能跟随在[CCh]指令之后；否则冲突</span></span><br><span class="line">    <span class="comment">//在这种情况下，可以允许主机从从机读取数据而不发送设备的64位ROM代码来节省时间</span></span><br><span class="line">    </span><br><span class="line">	a=ds_read_byte(bus);</span><br><span class="line">	b=ds_read_byte(bus);</span><br><span class="line">	tempDS18B20=b;</span><br><span class="line">	tempDS18B20&lt;&lt;=<span class="number">8</span>;</span><br><span class="line">	tempDS18B20=tempDS18B20|a;</span><br><span class="line">	biaozhi=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span>((tempDS18B20&amp;<span class="number">0x8000</span>))</span><br><span class="line">	&#123;</span><br><span class="line">	      biaozhi=<span class="number">1</span>;<span class="comment">//设置温度正负的标志</span></span><br><span class="line">	      tempDS18B20=(~tempDS18B20+<span class="number">1</span>);</span><br><span class="line">          tempDS18B20&amp;=<span class="number">0x07FF</span>;</span><br><span class="line">	&#125; </span><br><span class="line">	wendu=tempDS18B20*<span class="number">0.0625</span>;       <span class="comment">//得到真实十进制温度值，因为DS18B20</span></span><br><span class="line">                                 	<span class="comment">//可以精确到0.0625度，所以读回数据的最低位代表的是0.0625度</span></span><br><span class="line">	<span class="comment">//	wendu=wendu*10.0+0.5;       //放大十倍，这样做的目的将小数点后第一位</span></span><br><span class="line">	                         	    <span class="comment">//也转换为可显示数字，同时进行一个四舍五入操作。</span></span><br><span class="line">    <span class="comment">//tempDS18B20=(unsigned long int)(wendu*100+0.5);</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(biaozhi)</span><br><span class="line">        <span class="comment">//tempDS18B20 |= 0x8000;</span></span><br><span class="line">    	wendu*=(<span class="number">-1</span>);</span><br><span class="line">    Reset_18b20(bus);</span><br><span class="line">	<span class="keyword">return</span> wendu;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>




</li>
</ol>
]]></content>
      <categories>
        <category>嵌入式开发</category>
      </categories>
      <tags>
        <tag>嵌入式</tag>
        <tag>驱动开发</tag>
        <tag>MSP430</tag>
        <tag>C/C++</tag>
      </tags>
  </entry>
  <entry>
    <title>DS3231外设驱动</title>
    <url>/2021/01/07/DS3231/</url>
    <content><![CDATA[<blockquote>
<p>软件：IAR<br>硬件：MSP4305419A，DS3231</p>
</blockquote>
<p>学习外围时钟模块DS3231并编写驱动.</p>
<a id="more"></a>

<h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><ul>
<li>DS3231，高精度I2C实时时钟器件；</li>
<li>具有电池输入，并在设备的主电源中断时保持准确的计时；</li>
<li>RTC保留秒，分钟，小时，日期，日期，月份和年份的信息；</li>
<li>对于少于31天的月份，将自动调整月末的日期，包括闰年的更正；</li>
<li>带有AM / PM指示器的时钟以24小时或12小时格式运行；</li>
<li>提供了两个可编程的日时钟警报和一个可编程的方波输出；</li>
<li> 地址和数据通过I2C双向总线串行传输。</li>
<li>自带存储芯片：AT24C32 EEPROM芯片(存储容量32K)</li>
</ul>
<h3 id="引脚"><a href="#引脚" class="headerlink" title="引脚"></a>引脚</h3><p><img src="/upload_image/image-20201231141212427.png" alt="image-20201231141212427"></p>
<p><strong>引脚说明：</strong></p>
<ul>
<li>Vcc—引脚电源；</li>
<li>INT/SQW—低电平有效中断或方波输出，低电平复位引脚；</li>
<li>32kV—32kHz输出。此漏极开路输出引脚要求外接上拉电阻。使能状态下，输出可工作在任意电源拿下；如不使用，保持开路。</li>
<li>N.C.—表示无连接；外部必须接地</li>
<li>GND—地；</li>
<li>VBAT—备用电源输入；</li>
<li>SDA—串行数据输入输出；</li>
<li>SCL—串行时钟输入。</li>
</ul>
<p><strong>DS3231内部框图：</strong></p>
<img src="/upload_image/image-20201231141728544.png" alt="image-20201231141728544" style="zoom: 50%;" />

<h3 id="寄存器"><a href="#寄存器" class="headerlink" title="寄存器"></a>寄存器</h3><img src="/upload_image/image-20201231154044290.png" alt="image-20201231154044290" style="zoom: 33%;" />

<p>寄存器还是很好懂的，主意好各个Bit的控制的时分秒。</p>
<h3 id="程序"><a href="#程序" class="headerlink" title="程序"></a>程序</h3><p><strong>设计原理图：</strong></p>
<p><img src="/upload_image/image-20201231165705458.png" alt="image-20201231165705458"></p>
<p>​                                                        <img src="/upload_image/image-20201231165345940.png" alt="image-20201231165345940" style="zoom:67%;"  /><img src="/upload_image/image-20201231165515422.png" alt="image-20201231165515422" style="zoom:50%;" /></p>
<img src="/upload_image/image-20201231165515422.png" alt="image-20201231165515422" style="zoom: 67%;" />

<p><strong>宏定义说明：</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DS3231_SCL_H 	P9OUT |= BIT2											  <span class="comment">//P9.2输出SCL高电平</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DS3231_SCL_L 	P9OUT &amp;= ~BIT2											  <span class="comment">//P9.2输出SCL低电平</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DS3231_SDA_IN	do &#123; P9DIR &amp;= ~BIT1;  delay_us(2);&#125; while(0)				<span class="comment">//P9.1设置为SDA输入</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DS3231_SDA_OUT	do &#123; P9DIR |=  BIT1;  delay_us(2);&#125; while(0)				<span class="comment">//P9.1设置为SDA输出</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DS3231_SDA_H	do &#123; DS3231_SDA_OUT;  P9OUT |=  BIT1;  delay_us(2);&#125; while(0)<span class="comment">//P9.1输出SDA高电平</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DS3231_SDA_L	do &#123; DS3231_SDA_OUT;  P9OUT &amp;= ~BIT1;  delay_us(2);&#125; while(0)<span class="comment">//P9.1输出SDA低电平</span></span></span><br></pre></td></tr></table></figure>
<p><strong>函数声明：</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DS3231_Start</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DS3231_I2cError</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DS3231_Stop</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DS3231_ACK</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DS3231_NoAck</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">char</span> <span class="title">DS3231_ReadByte</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">char</span> endbyte)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DS3231_WriteByte</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">char</span> ucData)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> F_DS3231_Ack;										<span class="comment">//应答信号有无标志</span></span><br></pre></td></tr></table></figure>
<p>​        DS3231时钟芯片的管脚初始化: </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DS3231_Init_Pins</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;	</span><br><span class="line">    P9DIR |= (BIT1+BIT2);	<span class="comment">//选择P9.1和P9.2为SDA , SCK</span></span><br><span class="line">       </span><br><span class="line">	DS3231_SCL_H;</span><br><span class="line">	DS3231_SDA_H; </span><br><span class="line">    </span><br><span class="line">    P2DIR |= BIT5;          <span class="comment">//VTEM</span></span><br><span class="line">    P2OUT &amp;= ~BIT5;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​        启动/关闭函数：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DS3231_PowOn</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    P2OUT |= BIT5;</span><br><span class="line">    delay_us(<span class="number">20</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DS3231_PowOff</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    delay_us(<span class="number">20</span>);</span><br><span class="line">    P2OUT &amp;= ~BIT5;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>基本功能函数：</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*   SDA低-SCL高-SDA高   */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DS3231_I2cError</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	DS3231_SDA_L;</span><br><span class="line">	delay_us(<span class="number">10</span>);</span><br><span class="line">	DS3231_SCL_H;</span><br><span class="line">	delay_us(<span class="number">10</span>);</span><br><span class="line">	DS3231_SDA_H;</span><br><span class="line">	delay_us(<span class="number">10</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​        <strong>开始和结束信号</strong></p>
<p><img src="/upload_image/1309643-20180129202110453-1546154669.png" alt="img" style="zoom: 70%;" />从时序图可知，开始信号为：SCL高时，SDA由高变低；结束信号为：SCL为低时，SDA由低变高。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"> <span class="comment">/*******************************************</span></span><br><span class="line"><span class="comment"> 函数名称：DS3231_Start</span></span><br><span class="line"><span class="comment"> 功    能：I2C起始数据</span></span><br><span class="line"><span class="comment"> 参    数：无</span></span><br><span class="line"><span class="comment"> 返 回 值：无</span></span><br><span class="line"><span class="comment"> *******************************************/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DS3231_Start</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;   </span><br><span class="line">	DS3231_SDA_H;			<span class="comment">//SCL和SDA先拉高</span></span><br><span class="line">	delay_us(<span class="number">10</span>);			<span class="comment">//Delay的最小时间要求</span></span><br><span class="line">	DS3231_SCL_H;</span><br><span class="line">  	delay_us(<span class="number">10</span>);</span><br><span class="line">	DS3231_SDA_L;			<span class="comment">//当SCL为高时，SDA由高变低表示开始</span></span><br><span class="line">	delay_us(<span class="number">10</span>);		</span><br><span class="line">	DS3231_SCL_L;			<span class="comment">//SCL拉低表示数据传输准备就绪</span></span><br><span class="line">  	delay_us(<span class="number">10</span>);	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/*******************************************</span></span><br><span class="line"><span class="comment"> 函数名称：DS3231_Stop</span></span><br><span class="line"><span class="comment"> 功    能：I2C终止数据</span></span><br><span class="line"><span class="comment"> 参    数：无</span></span><br><span class="line"><span class="comment"> 返 回 值：无</span></span><br><span class="line"><span class="comment"> ********************************************/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DS3231_Stop</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	DS3231_SCL_L;</span><br><span class="line">  	delay_us(<span class="number">10</span>);</span><br><span class="line">	DS3231_SDA_L;			<span class="comment">//SCL和SDA拉低为结束信号做准备</span></span><br><span class="line">	delay_us(<span class="number">10</span>);</span><br><span class="line">	DS3231_SCL_H;			<span class="comment">//SCL拉高，对照时序图前半部分[STOP]</span></span><br><span class="line">  	delay_us(<span class="number">10</span>);</span><br><span class="line">	DS3231_SDA_H;			<span class="comment">//当SCL为高时，SDA由低到高为结束信号</span></span><br><span class="line">	delay_us(<span class="number">10</span>);	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​            <strong>发送&amp;读写函数：</strong></p>
<img src="/upload_image/image-20210104112626698.png" alt="image-20210104112626698" style="zoom: 50%;" />

<p>​    由图可知，开始信号之后，将SCL拉低，准备数据传输，SDA电平变化后，再拉高SCL，发送数据(最高位先发送)，循环8次(一个字节)；</p>
<p>​    读函数同理，过程与发送相反，SDA做输入，主机做接收端。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*******************************************</span></span><br><span class="line"><span class="comment">函数名称：DS3231_WriteByte</span></span><br><span class="line"><span class="comment">功    能：I2C发送/写入数据</span></span><br><span class="line"><span class="comment">参    数：ucData</span></span><br><span class="line"><span class="comment">返 回 值：ucData</span></span><br><span class="line"><span class="comment">********************************************/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DS3231_WriteByte</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">char</span> ucData)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">char</span> i;</span><br><span class="line">    DS3231_SDA_OUT;</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">8</span>;i++)				<span class="comment">//循环8次，一个字节</span></span><br><span class="line">	&#123;</span><br><span class="line">		DS3231_SCL_L;</span><br><span class="line">		delay_us(<span class="number">10</span>);</span><br><span class="line">		<span class="keyword">if</span>(ucData &amp; <span class="number">0x80</span>)</span><br><span class="line">		&#123; </span><br><span class="line">			DS3231_SDA_H;			<span class="comment">//高位先发</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			DS3231_SDA_L;</span><br><span class="line">		&#125;</span><br><span class="line">		delay_us(<span class="number">10</span>);</span><br><span class="line">		DS3231_SCL_H;				<span class="comment">//SCL拉高，发送数据</span></span><br><span class="line">		delay_us(<span class="number">10</span>);</span><br><span class="line">		ucData &lt;&lt;= <span class="number">1</span>;				<span class="comment">//数据左移一位</span></span><br><span class="line">		DS3231_SCL_L;</span><br><span class="line">		delay_us(<span class="number">10</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	DS3231_SDA_IN;</span><br><span class="line">	delay_us(<span class="number">10</span>);</span><br><span class="line">	F_DS3231_Ack = <span class="number">0</span>;</span><br><span class="line">	DS3231_SCL_H;</span><br><span class="line">	<span class="comment">//-------------------------------------</span></span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">20</span>;i++)</span><br><span class="line"> 	&#123;</span><br><span class="line">		<span class="keyword">if</span>(!DS3231_SDA()) &#123;F_DS3231_Ack = <span class="number">1</span>; <span class="keyword">break</span>;&#125;		<span class="comment">//循环20次，若I2C接收到应答信号，F_DS3231_Ack标志置1 </span></span><br><span class="line"> 	&#125;</span><br><span class="line"> 	<span class="comment">//-------------------------------------</span></span><br><span class="line"> 	delay_us(<span class="number">10</span>);</span><br><span class="line">	DS3231_SCL_L;</span><br><span class="line">	DS3231_SDA_OUT;</span><br><span class="line">	DS3231_SDA_H;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*******************************************</span></span><br><span class="line"><span class="comment">函数名称：DS3231_ReadByte</span></span><br><span class="line"><span class="comment">功    能：I2C发送/写入数据</span></span><br><span class="line"><span class="comment">参    数：endbyte</span></span><br><span class="line"><span class="comment">返 回 值：ucValue</span></span><br><span class="line"><span class="comment">********************************************/</span></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">char</span> <span class="title">DS3231_ReadByte</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">char</span> endbyte)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">char</span> ucValue;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">char</span> ucIndex;</span><br><span class="line"></span><br><span class="line">	DS3231_SDA_IN;						<span class="comment">//P9.1设置为输入</span></span><br><span class="line">	ucValue=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(ucIndex=<span class="number">0</span>;ucIndex&lt;<span class="number">8</span>;ucIndex++)</span><br><span class="line">	&#123;		</span><br><span class="line">		ucValue &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">		DS3231_SCL_L;					<span class="comment">//P9.2输出低电平</span></span><br><span class="line">		delay_us(<span class="number">10</span>);</span><br><span class="line">		DS3231_SCL_H;					<span class="comment">//P9.2输出高电平，保证接收数据时SDA不改变</span></span><br><span class="line">		delay_us(<span class="number">10</span>);</span><br><span class="line">		<span class="keyword">if</span>(DS3231_SDA())				<span class="comment">//引脚状态检测</span></span><br><span class="line">		&#123;</span><br><span class="line">			ucValue |= <span class="number">1</span>;				<span class="comment">//高电平保留</span></span><br><span class="line">		&#125;</span><br><span class="line">		delay_us(<span class="number">10</span>);</span><br><span class="line">		DS3231_SCL_L;					<span class="comment">//SCL拉低，数据准备</span></span><br><span class="line">		delay_us(<span class="number">10</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	DS3231_SDA_OUT;						<span class="comment">//P9.1设置为输入</span></span><br><span class="line">	<span class="keyword">if</span>(endbyte != <span class="number">0</span>)</span><br><span class="line"> 		DS3231_ACK();</span><br><span class="line"> 	<span class="keyword">else</span></span><br><span class="line">  		DS3231_NoAck();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> ucValue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​    <strong>主机应答信号&amp;非应答信号</strong></p>
<p><img src="/upload_image/1309643-20180129210833937-2127679015.png" alt="img" style="zoom:67%;" />主机接收完从机数据后，要发送应答或者非应答信号。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"> <span class="comment">/*******************************************</span></span><br><span class="line"><span class="comment"> 函数名称：DS3231_ACK</span></span><br><span class="line"><span class="comment"> 功    能：I2C发送应答信号</span></span><br><span class="line"><span class="comment"> 参    数：无</span></span><br><span class="line"><span class="comment"> 返回值  ：无</span></span><br><span class="line"><span class="comment"> ********************************************/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DS3231_ACK</span><span class="params">(<span class="keyword">void</span>)</span>		<span class="comment">//主机位接收端，发送应答信号</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//DS3231_SCL_L;			//SCL拉低，允许SDA改变电平</span></span><br><span class="line">	DS3231_SDA_L;			<span class="comment">//SCL低电平为应答</span></span><br><span class="line">	delay_us(<span class="number">10</span>);</span><br><span class="line">	DS3231_SCL_H;</span><br><span class="line">    delay_us(<span class="number">10</span>);</span><br><span class="line">	DS3231_SCL_L;</span><br><span class="line">    delay_us(<span class="number">10</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/*******************************************</span></span><br><span class="line"><span class="comment"> 函数名称：DS3231_NoAck</span></span><br><span class="line"><span class="comment"> 功    能：I2C发送非应答信号</span></span><br><span class="line"><span class="comment"> 参    数：无</span></span><br><span class="line"><span class="comment"> 返回值  ：无</span></span><br><span class="line"><span class="comment"> ********************************************/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DS3231_NoAck</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//DS3231_SCL_L;			//SCL拉低，允许SDA改变电平</span></span><br><span class="line">	DS3231_SDA_H;</span><br><span class="line">	delay_us(<span class="number">10</span>);</span><br><span class="line">	DS3231_SCL_H;</span><br><span class="line">  	delay_us(<span class="number">10</span>);</span><br><span class="line">	DS3231_SCL_L;</span><br><span class="line">  	delay_us(<span class="number">10</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/*******************************************</span></span><br><span class="line"><span class="comment"> 函数名称：DS3231_SDA</span></span><br><span class="line"><span class="comment"> 功    能：状态检测，I2C接收应答信号</span></span><br><span class="line"><span class="comment"> 参    数：无</span></span><br><span class="line"><span class="comment"> 返 回 值：0/1</span></span><br><span class="line"><span class="comment"> *******************************************/</span></span><br><span class="line"><span class="function">uint8 <span class="title">DS3231_SDA</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	DS3231_SDA_IN;</span><br><span class="line">	<span class="keyword">if</span>(P9IN &amp; BIT1)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;				<span class="comment">//无应答信号</span></span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;				<span class="comment">//有应答信号</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​        <strong>DS3231传输时序图</strong></p>
<p>​        再发送开始信号之后，DS3231接收的第一个字节的前7位时从机地址(DS3231地址)，第八位为读/写操作。</p>
<img src="/upload_image/image-20210105163356262.png" alt="image-20210105163356262" style="zoom: 33%;" />

<p>​        读写地址如下图，可以看出DS3231的主机地址为1101000，所以主机的写操作地址为0xD1(1101 0000)，读操作地址为0xD0(1101 0001)</p>
<img src="/upload_image/image-20210105164631330.png" alt="image-20210105164631330" style="zoom: 33%;" />

<p><img src="/upload_image/image-20210105165208899.png" alt="image-20210105165208899"></p>
<img src="/upload_image/image-20210105164631330.png" alt="image-20210105164631330" style="zoom: 33%;" />

<p><img src="/upload_image/image-20210105165208899.png" alt="image-20210105165208899"></p>
<p>​        <strong>DS3231写入模式工作流程：</strong></p>
<table>
<thead>
<tr>
<th align="center">程序步骤</th>
<th align="center">主机</th>
<th align="center">从机</th>
<th align="center">DS3231</th>
</tr>
</thead>
<tbody><tr>
<td align="center">1</td>
<td align="center">产生START信号</td>
<td align="center"></td>
<td align="center">接收从机地址字节1101 0000</td>
</tr>
<tr>
<td align="center">2</td>
<td align="center"></td>
<td align="center"></td>
<td align="center">确认从机地址+写位之后，在SDA上输出一个应答</td>
</tr>
<tr>
<td align="center">3</td>
<td align="center">将字地址发送到DS3231</td>
<td align="center"></td>
<td align="center">设置寄存器指针，确认传输</td>
</tr>
<tr>
<td align="center">4</td>
<td align="center">发送零个或多个字节的数据</td>
<td align="center"></td>
<td align="center">寄存器指针递增，接收每一个字节后都将发送一个确认位</td>
</tr>
<tr>
<td align="center">5</td>
<td align="center">产生一个STOP信号终止数据写入</td>
<td align="center"></td>
<td align="center"></td>
</tr>
</tbody></table>
<p>​        <strong>DS3231读取模式工作流程：</strong></p>
<table>
<thead>
<tr>
<th align="center">程序步骤</th>
<th align="center">主机</th>
<th align="center">从机</th>
<th align="center">DS3231</th>
</tr>
</thead>
<tbody><tr>
<td align="center">1</td>
<td align="center">产生START信号</td>
<td align="center"></td>
<td align="center">接收从机地址字节1101 0001</td>
</tr>
<tr>
<td align="center">2</td>
<td align="center"></td>
<td align="center"></td>
<td align="center">确认之后，在SDA输出一个应答</td>
</tr>
<tr>
<td align="center">3</td>
<td align="center"></td>
<td align="center"></td>
<td align="center">从寄存器指针指向寄存器地址开始发送数据</td>
</tr>
<tr>
<td align="center">4</td>
<td align="center"></td>
<td align="center"></td>
<td align="center">收到非确认信息才能结束</td>
</tr>
</tbody></table>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"> <span class="comment">/*******************************************</span></span><br><span class="line"><span class="comment"> 函数名称：DS3231_write_byte</span></span><br><span class="line"><span class="comment"> 功    能：I2C总线给DS3231发送单字节</span></span><br><span class="line"><span class="comment"> 参    数：无</span></span><br><span class="line"><span class="comment"> 返回值  ：无</span></span><br><span class="line"><span class="comment"> ********************************************/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DS3231_write_byte</span><span class="params">(uint8 dev_add,uint8 reg,uint8 data)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	DS3231_Start();</span><br><span class="line">	DS3231_WriteByte(dev_add);</span><br><span class="line">	</span><br><span class="line">	DS3231_WriteByte(reg);</span><br><span class="line">	</span><br><span class="line">	DS3231_WriteByte(data);</span><br><span class="line">    </span><br><span class="line">	DS3231_Stop();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"> <span class="comment">/*******************************************</span></span><br><span class="line"><span class="comment"> 函数名称：DS3231_read_byte</span></span><br><span class="line"><span class="comment"> 功    能：I2C总线给DS3231接收单字节</span></span><br><span class="line"><span class="comment"> 参    数：无</span></span><br><span class="line"><span class="comment"> 返回值  ：无</span></span><br><span class="line"><span class="comment"> ********************************************/</span></span><br><span class="line"><span class="function">uint8 <span class="title">DS3231_read_byte</span><span class="params">(uint8 dev_add,uint8 reg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    uint8 ret;	</span><br><span class="line">	DS3231_Start();</span><br><span class="line">	DS3231_WriteByte(dev_add);	</span><br><span class="line">	DS3231_WriteByte(reg);	</span><br><span class="line">	DS3231_Start();</span><br><span class="line">	DS3231_WriteByte(dev_add+<span class="number">1</span>);	</span><br><span class="line">	ret=DS3231_ReadByte(<span class="number">0</span>);    </span><br><span class="line">	DS3231_Stop();</span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;	</span><br></pre></td></tr></table></figure>
<p>​    硬件读取的为BCD码格式的时间数据，BCD码增加了硬件算数运算的复杂度且存储效率低，因此在读取之后需要进行转码读取。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"> <span class="comment">/*******************************************</span></span><br><span class="line"><span class="comment"> 函数名称：BCD2HEX</span></span><br><span class="line"><span class="comment"> 功    能：BCD转换为Byte</span></span><br><span class="line"><span class="comment"> 参    数：uint val</span></span><br><span class="line"><span class="comment"> 返回值  ：char i</span></span><br><span class="line"><span class="comment"> ********************************************/</span></span><br><span class="line"><span class="function">uint8 <span class="title">BCD2HEX</span><span class="params">(uint8 val)</span>   	<span class="comment">//BCD转换为Byte </span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> i; </span><br><span class="line">    i= val &amp; <span class="number">0x0f</span>; </span><br><span class="line">    val &gt;&gt;= <span class="number">4</span>; </span><br><span class="line">    val &amp;= <span class="number">0x0f</span>; </span><br><span class="line">    val *= <span class="number">10</span>; </span><br><span class="line">    i += val; </span><br><span class="line">     </span><br><span class="line">    <span class="keyword">return</span> i; </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"> <span class="comment">/*******************************************</span></span><br><span class="line"><span class="comment"> 函数名称：B_BCD</span></span><br><span class="line"><span class="comment"> 功    能：B码转换为BCD码</span></span><br><span class="line"><span class="comment"> 参    数：uint val</span></span><br><span class="line"><span class="comment"> 返回值  ：uint i</span></span><br><span class="line"><span class="comment"> ********************************************/</span></span><br><span class="line"><span class="function">uint8 <span class="title">B_BCD</span><span class="params">(uint8 val)</span>     <span class="comment">//B码转换为BCD码 </span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">  </span><br><span class="line">  uint8 i,j,k; </span><br><span class="line">  i=val/<span class="number">10</span>; </span><br><span class="line">  j=val%<span class="number">10</span>; </span><br><span class="line">  k=j+(i&lt;&lt;<span class="number">4</span>); </span><br><span class="line">  <span class="keyword">return</span> k; </span><br><span class="line">  </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<p>​    读取时间、计算、显示函数：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"> <span class="comment">/*******************************************</span></span><br><span class="line"><span class="comment"> 函数名称：DS3231_ModifyTime</span></span><br><span class="line"><span class="comment"> 功    能：修改时间</span></span><br><span class="line"><span class="comment"> 参    数：BCD码</span></span><br><span class="line"><span class="comment"> 返回值  ：</span></span><br><span class="line"><span class="comment"> ********************************************/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DS3231_ModifyTime</span><span class="params">(uint8 yea,uint8 mon,uint8 da,uint8 hou,uint8 min,uint8 sec)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">  uint8 temp=<span class="number">0</span>; </span><br><span class="line">  DS3231_PowOn();</span><br><span class="line">  temp=B_BCD(yea); </span><br><span class="line">  DS3231_write_byte(<span class="number">0xD0</span>,<span class="number">0x06</span>,temp);<span class="comment">//修改年 </span></span><br><span class="line">   </span><br><span class="line">  temp=B_BCD(mon); </span><br><span class="line">  DS3231_write_byte(<span class="number">0xD0</span>,<span class="number">0x05</span>,temp);<span class="comment">//修改月 </span></span><br><span class="line">    </span><br><span class="line">  temp=B_BCD(da); </span><br><span class="line">  DS3231_write_byte(<span class="number">0xD0</span>,<span class="number">0x04</span>,temp);<span class="comment">//修改日 </span></span><br><span class="line">   </span><br><span class="line">  temp=B_BCD(hou); </span><br><span class="line">  DS3231_write_byte(<span class="number">0xD0</span>,<span class="number">0x02</span>,temp);<span class="comment">//修改时 </span></span><br><span class="line">   </span><br><span class="line">  temp=B_BCD(min); </span><br><span class="line">  DS3231_write_byte(<span class="number">0xD0</span>,<span class="number">0x01</span>,temp);<span class="comment">//修改分 </span></span><br><span class="line">   </span><br><span class="line">  temp=B_BCD(sec); </span><br><span class="line">  DS3231_write_byte(<span class="number">0xD0</span>,<span class="number">0x00</span>,temp);<span class="comment">//修改秒 </span></span><br><span class="line">  DS3231_PowOff();</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"> <span class="comment">/*******************************************</span></span><br><span class="line"><span class="comment"> 函数名称：DS3231_GetTime</span></span><br><span class="line"><span class="comment"> 功    能：获取、计算、显示时间</span></span><br><span class="line"><span class="comment"> 参    数：BCD码</span></span><br><span class="line"><span class="comment"> 返回值  ：</span></span><br><span class="line"><span class="comment"> ********************************************/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DS3231_GetTime</span><span class="params">(uint8 *yea,uint8 *mon,uint8 *da,uint8 *hou,uint8 *min,uint8 *sec)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">  </span><br><span class="line"> uint8 temp1; </span><br><span class="line"></span><br><span class="line"> DS3231_PowOn(); </span><br><span class="line">  </span><br><span class="line"> temp1=DS3231_read_byte(<span class="number">0xd0</span>,<span class="number">0x06</span>);  <span class="comment">//年 </span></span><br><span class="line"> *yea=BCD2HEX(temp1); </span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"> temp1=DS3231_read_byte(<span class="number">0xd0</span>,<span class="number">0x05</span>);  <span class="comment">//月 </span></span><br><span class="line"> *mon=BCD2HEX(temp1); </span><br><span class="line"> </span><br><span class="line">  </span><br><span class="line"> temp1=DS3231_read_byte(<span class="number">0xd0</span>,<span class="number">0x04</span>);  <span class="comment">//日 </span></span><br><span class="line"> *da=BCD2HEX(temp1); </span><br><span class="line"> </span><br><span class="line">  </span><br><span class="line"> temp1=DS3231_read_byte(<span class="number">0xd0</span>,<span class="number">0x02</span>);  <span class="comment">//时 24小时制 </span></span><br><span class="line"> temp1&amp;=<span class="number">0x3f</span>;                    </span><br><span class="line"> *hou=BCD2HEX(temp1); </span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"> temp1=DS3231_read_byte(<span class="number">0xd0</span>,<span class="number">0x01</span>);  <span class="comment">//分 </span></span><br><span class="line"> *min=BCD2HEX(temp1); </span><br><span class="line"> </span><br><span class="line">   </span><br><span class="line"> temp1=DS3231_read_byte(<span class="number">0xd0</span>,<span class="number">0x00</span>);  <span class="comment">//秒 </span></span><br><span class="line"> *sec=BCD2HEX(temp1); </span><br><span class="line"> </span><br><span class="line"> DS3231_PowOff();</span><br><span class="line">  </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>嵌入式开发</category>
      </categories>
      <tags>
        <tag>嵌入式</tag>
        <tag>驱动开发</tag>
        <tag>MSP430</tag>
        <tag>C/C++</tag>
      </tags>
  </entry>
  <entry>
    <title>MSP430 单片机(一)——概述</title>
    <url>/2020/11/01/MSP430%E5%8D%95%E7%89%87%E6%9C%BA%E5%85%A5%E9%97%A8(1)%E2%80%94%E2%80%94%E6%A6%82%E8%BF%B0/</url>
    <content><![CDATA[<blockquote>
<p>简要介绍(水)一下MSP430单片机的特点和应用</p>
</blockquote>
<a id="more"></a>

<h3 id="MSP430系列单片机的特点"><a href="#MSP430系列单片机的特点" class="headerlink" title="MSP430系列单片机的特点"></a>MSP430系列单片机的特点</h3><ul>
<li><p><strong>超低功耗</strong></p>
<p>掉电工作模式i电流0.1μA</p>
<p>等待模式电流0.8μA</p>
<p>250μA/1MIPS@3V</p>
<p>时钟唤醒时间&lt;6μs</p>
<p>端口漏电流&lt;50nA</p>
<p>零功率BOR</p>
</li>
<li><p><strong>强大的处理能力</strong></p>
<p>16位RISC结构指令</p>
<p>集成SCoC</p>
</li>
<li><p><strong>高性能的模拟技术及丰富的片上外围资源</strong></p>
<p>快速进入市场</p>
</li>
<li><p><strong>系统稳定工作</strong></p>
</li>
<li><p><strong>方便高效的开发环境</strong></p>
</li>
<li><p><strong>有丰富的开发资源和强大的技术支持</strong></p>
</li>
</ul>
<h3 id="MSP430命名"><a href="#MSP430命名" class="headerlink" title="MSP430命名"></a>MSP430命名</h3><p><img src="/upload_image/image-20201104201509479.png" alt="image-20201104201509479"></p>
<p>(老图)</p>
<p>如手上的学习板型号为：<strong>MSP430F5438</strong>，表示存储器类型为 <strong>FLASH</strong>，“54”表示</p>
<h3 id="MSP430单片机的应用场景"><a href="#MSP430单片机的应用场景" class="headerlink" title="MSP430单片机的应用场景"></a>MSP430单片机的应用场景</h3><p>根据其特点有以下应用场景：</p>
<p><strong>通讯：</strong></p>
<ul>
<li>实时信号处理</li>
<li>专用功能</li>
</ul>
<p><strong>计算任务：</strong></p>
<ul>
<li>多任务</li>
<li>微处理器</li>
</ul>
<p><strong>低功率测量：</strong></p>
<ul>
<li>可靠测量</li>
<li>便携仪器</li>
<li>消费类产品</li>
<li>三表：水表、气表、热表</li>
</ul>
<p><strong>简单的控制：</strong></p>
<ul>
<li>丰富接口功能</li>
<li>片选功能</li>
<li>相当通俗易上手的库文件</li>
</ul>
]]></content>
      <categories>
        <category>嵌入式开发</category>
      </categories>
      <tags>
        <tag>嵌入式</tag>
        <tag>MSP430</tag>
        <tag>IAR</tag>
      </tags>
  </entry>
  <entry>
    <title>MSP430单片机(二)——开发环境IAR</title>
    <url>/2020/11/08/MSP430%E5%8D%95%E7%89%87%E6%9C%BA%E5%85%A5%E9%97%A8(2)%E2%80%94%E2%80%94%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83IAR/</url>
    <content><![CDATA[<blockquote>
<p>初步接触IAR的开发环境.<br>版本：Embedded Workbench 8.0 IAR for 430</p>
</blockquote>
<a id="more"></a>

<h3 id="编程优化"><a href="#编程优化" class="headerlink" title="编程优化"></a>编程优化</h3><p>右击Project，选中【C/C++ Compiler】，【Optimizations】，【Level】，根据需求选择速度优先和大小优先，选择不同的等级【None】、【Low】、【Medium】、【High】</p>
<hr>
<h3 id="芯片选择"><a href="#芯片选择" class="headerlink" title="芯片选择"></a>芯片选择</h3><p>右击侧边栏的Project，选中【General Options】，【Target】，【Device】</p>
<hr>
<h3 id="Debugger"><a href="#Debugger" class="headerlink" title="Debugger"></a>Debugger</h3><p>右击Project，选中【Debugger】，【Setup】、【Driver】，有【FET Debugger】和【Simulator】两种。</p>
<p><strong>FET Debugger：</strong>【Connection】中选择仿真器的类型，【Download】中选择【Verify download】以校验下载到单片机中程序的大小是否与编译的程序一致；【Flash erase】中选择不同的Flash擦除方式；【Breakpoints】中勾选【Use software breakpoints】表示超过三个断点之后，再添加断点就是虚拟断点，会使得调试效率变低速度变慢</p>
<p><strong>Simulator：</strong>不做考虑，默认即可</p>
<hr>
<h3 id="调试Q-amp-A"><a href="#调试Q-amp-A" class="headerlink" title="调试Q&amp;A"></a>调试Q&amp;A</h3><p><strong>调试问题1：</strong>连接仿真器之后提示要升级</p>
<img src="/upload_image/image-20201216113413235.png" alt="image-20201216113413235" style="zoom:80%;" />

<img src="/upload_image/image-20201216113831524.png" alt="image-20201216113831524" style="zoom:67%;" />

<p>如果不选【Y】下次每次连接都会有提示，点击【Y】之后大概率会升级成功，但也有可能会出现升级失败：</p>
<p><img src="/upload_image/image-20201216113859710.png" alt="image-20201216113859710"></p>
<p><strong>解决方法：</strong>升级失败的原因有很多，最主要的可能性是连了device，这种情况下将JTAG拔掉不连device，再将另一头的USB也拔掉重插；</p>
<p>如果问题没有解决，那就检查一下C盘文件。只要是IAR5.3及以下的版本就可以随便点是，更新下即可。如果是IAR5.4以上版本提示升级，首先要查看下电脑系统C:\WINDOWS\system32\drivers下面有没有usbser.sys文件，如果没有肯定不能升级的，升级就坏了驱动会不识别的，如果C:\WINDOWS\system32\drivers路径下有usbser.sys文件，那么就可以放心升级了。</p>
<img src="/upload_image/image-20201216185839335.png" alt="image-20201216185839335" style="zoom: 50%;" />

<p>升级过程：在此期间不能拔插仿真器，中途停止会导致仿真器损坏。</p>
<p><img src="/upload_image/image-20201216113849973.png" alt="image-20201216113849973"></p>
<p><img src="/upload_image/image-20201216133611769.png" alt="image-20201216133611769"></p>
<p>IAR5.3及以下版本识别的端口号是VCP；IAR5.4以上版本识别的端口后就是CDC了。</p>
<p><strong>调试问题2：</strong>连接设备失败</p>
<img src="/upload_image/image-20201216113432373.png" alt="image-20201216113432373" style="zoom: 67%;" />

<img src="/upload_image/image-20201216113831524.png" alt="image-20201216113831524" style="zoom:50%;" />

<p><strong>解决方案：</strong> 主要的是CPU出现故障或者是JTAG没有插好方向。在更换了JTAG插口之后仿真器更新成功了</p>
<p><strong>调试问题2：</strong>进入debug模式之后，发现不能在main里打断点</p>
<img src="/upload_image/image-20201216161509221.png" alt="image-20201216161509221" style="zoom:50%;" />

<p><strong>解决方法：</strong></p>
<ol>
<li><p>打开 <code>c-SPY</code> 的调试信息</p>
<p> 右击项目，<code>-&gt; options -&gt; linker -&gt; output -&gt; format</code> ，选择 <code>Debug information for c-SPY</code> 选项：</p>
</li>
</ol>
<img src="/upload_image/image-20201216162239317.png" alt="image-20201216162239317" style="zoom:50%;" />

<ol start="2">
<li><p>软件选项中有关断点的设置</p>
<p> <code>Tools -&gt; options -&gt; stack -&gt;</code> 去掉选项 <code>stack pointer not valid until program reaches</code></p>
</li>
</ol>
<img src="/upload_image/image-20201216162605666.png" alt="image-20201216162605666" style="zoom:50%;" />

<ol start="3">
<li><p>生成Debug信息</p>
<p> <code>Project -&gt; Options -&gt; C/C++ Compiler -&gt; Output</code> ：勾选上 <code> Generate debug informat</code>这个选项;</p>
<p> 低版本IAR：<code>Project -&gt; Options -&gt; linker -&gt; Output</code>：勾选上<code>Include debug information in output </code> 这个选项;</p>
<p> 高版本IAR：<code>Project -&gt; Options -&gt; linker -&gt; Diagnostics</code>：勾选上<code>Always generate output </code> 这个选项。</p>
</li>
<li><p>设置合适的优化等级</p>
<p> <code>Project -&gt; Options -&gt; C/C++ Compiler -&gt; Optimizations</code> ：选择 <code>low</code></p>
</li>
</ol>
<p>设置完之后，右击项目 -&gt; <code>Rebuild All</code> 。</p>
]]></content>
      <categories>
        <category>工具应用</category>
      </categories>
      <tags>
        <tag>嵌入式</tag>
        <tag>MSP430</tag>
        <tag>IAR</tag>
        <tag>编译软件</tag>
      </tags>
  </entry>
  <entry>
    <title>MSP430单片机(五)——USCI-UART模式</title>
    <url>/2021/01/22/MSP430%E5%8D%95%E7%89%87%E6%9C%BA%E5%85%A5%E9%97%A8(5)%E2%80%94%E2%80%94USCI-UART%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>USCI模块不仅支持UART模式，还支持SPI模式，在单片机的应用中十分重要。</p>
<a id="more"></a>

<h3 id="USCI-UART概述"><a href="#USCI-UART概述" class="headerlink" title="USCI-UART概述"></a>USCI-UART概述</h3><p>先简要翻译一下官方手册对USCI-UART模式的描述：</p>
<h4 id="USCI概述"><a href="#USCI概述" class="headerlink" title="USCI概述"></a>USCI概述</h4><blockquote>
<p>USCI模块支持多种串行通信模式。 不同的USCI模块支持不同的模式。 每个不同的USCI模块均以不同的字母命名。 例如，USCI_A与USCI_B不同，等等。如果在一个设备上实现了多个相同的USCI模块，则这些模块将以递增编号命名。 例如，如果一个设备具有两个USCI_A模块，则它们分别命名为USCI_A0和USCI_A1。 </p>
<p>USCI_Ax模块支持：</p>
<ul>
<li>UART模式</li>
<li>IrDA通信的脉冲整形</li>
<li>LIN通信的自动波特率检测</li>
<li><strong>SPI模式</strong></li>
</ul>
<p>USCI_Bx模块支持：</p>
<ul>
<li>I2C模式</li>
<li>SPI模式</li>
</ul>
</blockquote>
<h4 id="UART模式"><a href="#UART模式" class="headerlink" title="UART模式"></a>UART模式</h4><blockquote>
<p>在异步模式下，USCI_Ax模块通过两个外部引脚UCAxRXD和UCAxTXD将设备连接到外部系统。UCSYNC位清零时，选择UART模式。<br>UART模式的功能包括：</p>
<ul>
<li>具有奇校验，偶校验或非奇偶校验的7位或8位数据</li>
<li>独立的发送和接收移位寄存器</li>
<li>单独的发送和接收缓冲寄存器</li>
<li>LSB优先或MSB优先数据发送和接收</li>
<li>内置 用于多处理器系统的空闲线路和地址位通信协议</li>
<li>用于从LPMx模式自动唤醒的接收器起始沿检测</li>
<li>带有调制的可编程波特率，支持分数波特率</li>
<li>用于错误检测和抑制的状态标志</li>
<li>状态标志 用于地址检测</li>
<li>具有独立的中断接收和发送功能 </li>
</ul>
</blockquote>
<h3 id="UART模式操作"><a href="#UART模式操作" class="headerlink" title="UART模式操作"></a>UART模式操作</h3><p>在串口模式下，USCI以一个比特的速率和其他谁被之间进行异步的传输和接收数据。发送每一个字符的时间都是由USCI选择的波特率决定的。发送和接收的功能使用相同的波特率。</p>
<h4 id="操作步骤"><a href="#操作步骤" class="headerlink" title="操作步骤"></a>操作步骤</h4><p><strong>初始化：</strong></p>
<ul>
<li>设置波特率</li>
<li>选择USCI时钟源</li>
<li>设置UART状态机</li>
<li>设置预分频器UCBRx</li>
<li>设置调制器</li>
<li>打开 USCI RX 中断</li>
</ul>
<h4 id="寄存器说明"><a href="#寄存器说明" class="headerlink" title="寄存器说明"></a>寄存器说明</h4><h5 id="USCI-Ax控制寄存器1-USCI-Ax-Control-Register-1-UCAxCTL1"><a href="#USCI-Ax控制寄存器1-USCI-Ax-Control-Register-1-UCAxCTL1" class="headerlink" title="USCI_Ax控制寄存器1 USCI_Ax Control Register 1 (UCAxCTL1)"></a>USCI_Ax控制寄存器1 USCI_Ax Control Register 1 (UCAxCTL1)</h5><table>
<thead>
<tr>
<th align="center">7</th>
<th align="center">6</th>
<th align="center">5</th>
<th align="center">4</th>
<th align="center">3</th>
<th align="center">2</th>
<th align="center">1</th>
<th align="center">0</th>
</tr>
</thead>
<tbody><tr>
<td align="center">UCSSELx</td>
<td align="center"></td>
<td align="center">UCRXEIE</td>
<td align="center">UCBRKIE</td>
<td align="center">UCDORM</td>
<td align="center">UCTXADDR</td>
<td align="center">UCTXBRK</td>
<td align="center">UCSWRST</td>
</tr>
<tr>
<td align="center">rw-0</td>
<td align="center">rw-0</td>
<td align="center">rw-0</td>
<td align="center">rw-0</td>
<td align="center">rw-0</td>
<td align="center">rw-0</td>
<td align="center">rw-0</td>
<td align="center">rw-1</td>
</tr>
</tbody></table>
<p><strong>UCSSELx</strong>            位7-6             USCI时钟源选择。 这些位选择BRCLK源时钟。<br>                                                            00 UCLK<br>​                                                            01 ACLK<br>​                                                            10 SMCLK<br>​                                                            11 SMCLK<br><strong>UCRXEIE</strong>            位5                接收错误字符中断使能<br>​                                                            0-拒绝错误字符且未设置UCRXIFG。<br>                                                           1-收到的错误字符设置为UCRXIFG。<br><strong>UCBRKIE</strong>            位4                接收中断字符中断使能<br>​                                                            0-接收到的中断字符未设置UCRXIFG。<br>                                                            1-接收到的断字符设置为UCRXIFG。<br><strong>UCDORM</strong>             位3            休眠。 使USCI进入睡眠模式。<br>                                                           0-不休眠。所有收到的字符都设置为UCRXIFG。<br>                                                           1-休眠。UCRXIFG只设置了空行或地址位之后的字符。 在具有自动波特率检测的UART模式下，只有中断和同步字段的组合才会设置UCRXIFG。<br><strong>UCTXADDR</strong>        位2                发送地址。根据所选的多处理器模式，将要发送的下一帧标记为地址。<br>                                                           0-传输的下一帧是数据。<br>                                                           1-下一个发送的帧是一个地址。<br><strong>UCTXBRK</strong>            位1                发送中断。 下一次写入传输缓冲区时发送中断。 在具有自动波特率检测的UART模式下，必须将055h写入UCAxTXBUF，以生成所需的间隔/同步字段。否则，必须将0h写入发送缓冲区。<br>                                                           0-传输的下一帧不是间断。<br>                                                           1-传输的下一帧是中断或中断/同步。<br><strong>UCSWRST</strong>            位0                软件复位使能<br>​                                                            0-禁用。USCI复位已释放以进行操作。<br>                                                           1-启用。USCI逻辑保持在复位状态。</p>
<h5 id="USCI-Ax波特率控制寄存器0-USCI-Ax-Baud-Rate-Control-Register-0-UCAxBR0"><a href="#USCI-Ax波特率控制寄存器0-USCI-Ax-Baud-Rate-Control-Register-0-UCAxBR0" class="headerlink" title="USCI_Ax波特率控制寄存器0 USCI_Ax Baud Rate Control Register 0 (UCAxBR0)"></a>USCI_Ax波特率控制寄存器0 USCI_Ax Baud Rate Control Register 0 (UCAxBR0)</h5><table>
<thead>
<tr>
<th align="center">7</th>
<th align="center">6</th>
<th align="center">5</th>
<th align="center">4</th>
<th align="center">3</th>
<th align="center">2</th>
<th align="center">1</th>
<th align="center">0</th>
</tr>
</thead>
<tbody><tr>
<td align="center">-</td>
<td align="center">-</td>
<td align="center">-</td>
<td align="center">UCBRx - low byte</td>
<td align="center">-</td>
<td align="center">-</td>
<td align="center">-</td>
<td align="center">-</td>
</tr>
<tr>
<td align="center">rw</td>
<td align="center">rw</td>
<td align="center">rw</td>
<td align="center">rw</td>
<td align="center">rw</td>
<td align="center">rw</td>
<td align="center">rw</td>
<td align="center">rw</td>
</tr>
</tbody></table>
<h5 id="USCI-Ax波特率控制寄存器1-USCI-Ax-Baud-Rate-Control-Register-1-UCAxBR1"><a href="#USCI-Ax波特率控制寄存器1-USCI-Ax-Baud-Rate-Control-Register-1-UCAxBR1" class="headerlink" title="USCI_Ax波特率控制寄存器1 USCI_Ax Baud Rate Control Register 1 (UCAxBR1)"></a>USCI_Ax波特率控制寄存器1 USCI_Ax Baud Rate Control Register 1 (UCAxBR1)</h5><table>
<thead>
<tr>
<th align="center">7</th>
<th align="center">6</th>
<th align="center">5</th>
<th align="center">4</th>
<th align="center">3</th>
<th align="center">2</th>
<th align="center">1</th>
<th align="center">0</th>
</tr>
</thead>
<tbody><tr>
<td align="center">-</td>
<td align="center">-</td>
<td align="center">-</td>
<td align="center">UCBRx - high byte</td>
<td align="center">-</td>
<td align="center">-</td>
<td align="center">-</td>
<td align="center">-</td>
</tr>
<tr>
<td align="center">rw</td>
<td align="center">rw</td>
<td align="center">rw</td>
<td align="center">rw</td>
<td align="center">rw</td>
<td align="center">rw</td>
<td align="center">rw</td>
<td align="center">rw</td>
</tr>
</tbody></table>
<p><strong>UCBRx</strong>                波特率发生器的时钟预分频器设置。（UCAxBR0 + UCAxBR1×256）的16位值构成了预分频器值UCBRx</p>
<h5 id="USCI-Ax调制控制寄存器-USCI-Ax-Modulation-Control-Register-UCAxMCTL"><a href="#USCI-Ax调制控制寄存器-USCI-Ax-Modulation-Control-Register-UCAxMCTL" class="headerlink" title="USCI_Ax调制控制寄存器 USCI_Ax Modulation Control Register (UCAxMCTL)"></a>USCI_Ax调制控制寄存器 USCI_Ax Modulation Control Register (UCAxMCTL)</h5><table>
<thead>
<tr>
<th align="center">7</th>
<th align="center">6</th>
<th align="center">5</th>
<th align="center">4</th>
<th align="center">3</th>
<th align="center">2</th>
<th align="center">1</th>
<th align="center">0</th>
</tr>
</thead>
<tbody><tr>
<td align="center">UCBRFx</td>
<td align="center">-</td>
<td align="center">-</td>
<td align="center">-</td>
<td align="center">UCBRSx</td>
<td align="center">-</td>
<td align="center">-</td>
<td align="center">UCOS16</td>
</tr>
<tr>
<td align="center">rw-0</td>
<td align="center">rw-0</td>
<td align="center">rw-0</td>
<td align="center">rw-0</td>
<td align="center">rw-0</td>
<td align="center">rw-0</td>
<td align="center">rw-0</td>
<td align="center">rw-0</td>
</tr>
</tbody></table>
<p><strong>UCBRFx</strong>             位7-4            第一个调制级选择。 当UCOS16 = 1时，这些位确定BITCLK16的调制模式。<br>                                                如果UCOS16 =0，则忽略。表16-3给出了调制模式。<br><strong>UCBRSx</strong>             位3-1           第二调制级选择。 这些位确定BITCLK的调制模式。 表16-2给出了调制模式。<br><strong>UCOS16</strong>             位0               启用过采样模式<br>​                                                    0禁用<br>​                                                    1启用</p>
<h5 id="USCI-Ax中断允许寄存器-USCI-Ax-Interrupt-Enable-Register-UCAxIE"><a href="#USCI-Ax中断允许寄存器-USCI-Ax-Interrupt-Enable-Register-UCAxIE" class="headerlink" title="USCI_Ax中断允许寄存器 USCI_Ax Interrupt Enable Register (UCAxIE)"></a>USCI_Ax中断允许寄存器 USCI_Ax Interrupt Enable Register (UCAxIE)</h5><table>
<thead>
<tr>
<th align="center">7</th>
<th align="center">6</th>
<th align="center">5</th>
<th align="center">4</th>
<th align="center">3</th>
<th align="center">2</th>
<th align="center">1</th>
<th align="center">0</th>
</tr>
</thead>
<tbody><tr>
<td align="center">Reserved</td>
<td align="center">-</td>
<td align="center">-</td>
<td align="center">-</td>
<td align="center">-</td>
<td align="center">-</td>
<td align="center">UCTXIE</td>
<td align="center">UXRXIE</td>
</tr>
<tr>
<td align="center">rw-0</td>
<td align="center">rw-0</td>
<td align="center">rw-0</td>
<td align="center">rw-0</td>
<td align="center">rw-0</td>
<td align="center">rw-0</td>
<td align="center">rw-0</td>
<td align="center">rw-0</td>
</tr>
</tbody></table>
<p>保留                    位7-2                保留</p>
<p>UCTXIE              位1                   发送中断使能    0禁止中断    1允许中断</p>
<p>UCRXIE              位0                  接收中断使能     0禁止中断    1允许中断</p>
<h4 id="波特率的计算方法"><a href="#波特率的计算方法" class="headerlink" title="波特率的计算方法"></a>波特率的计算方法</h4><p>usart模块的波特率值设定是通过以下三个寄存器决定的： <code>UxBR0</code>, <code>UxBR1</code>, <code>UxMCTL</code><br>波特率＝ <code>BRCLK / N</code> ,主要是计算出N</p>
<p><strong>BRCLK：</strong> 时钟源，可以通过寄存器设定何为时钟源; 通过寄存器UCAxCTL1的SSEL两位选择，01:ACLK, 02:SMCLK</p>
<p><strong>N：</strong>波特率产生的分频因子。 <code>N=UxBR1+UxBR0+UxMCTL</code>, 其中 <code>UxBR1+UxBR0</code>为整数部分， <code>UxMCTL</code>为设定小数部分，其中 <code>UxBR1</code>为高位， <code>UxBR0</code>为低位，两者结合起来为一个16位的字。</p>
<p>波特率 = 115200 ，时钟源 = 8MHz，为外部晶振，N = 8000000 / 115200 = 69.44。所以 <code>UxBR1+UxBR0＝69</code>, 69为十进制数，转换为十六进制为 0x45，所以 <code>UxBR1=0</code>，<code>UxBR0=0x45</code> ，小数部分 0.44 x 8 = 3.52，取4(<strong>一般取偶数</strong>)，则需要四个脉冲插补位(<strong>需要几个插补位八位上就需要几个1</strong>)，因为这里设置 <code>UCOS16=0</code>，所以查看表16-2 ，看到四个插补位的是 <code>UCBRSx = 4</code> ，01010101的那一组 ，所以 <code>UCAxMCTL</code> 寄存器中的 <code>UCBRSx</code> 设置为 0x04， <code>UCAxMCTL</code> 也就是 0000 1000（0x08）。</p>
<p>再算一组，波特率 = 9600，时钟源 = 16MHz，外部晶振。N = 16000000 / 9600 = 1666.66666. 所以 <code>UxBR1+UxBR0＝1666</code>，1666转十六进制0x682（0000 0110 1000 0010），所以  <code>UxBR1=0x06</code>，<code>UxBR0=0x82</code> ，小数部分 0.666666 x 8 = 5.33333，近似取正偶数6，<code>UCBRSx = 6</code> ，所以 <code>UCAxMCTL = 0x0c（0000 1100）</code>.</p>
<h4 id="参数表"><a href="#参数表" class="headerlink" title="参数表"></a>参数表</h4><p>UCAxMCTL 7-4位控制BITCLK调制模式：</p>
<img src="/upload_image/image-20210124182449137.png" alt="image-20210124182449137" style="zoom: 67%;" />

<p> UCAxMCTL 3-1位控制BITCLK16调制模式：</p>
<img src="/upload_image/image-20210124182730186.png" alt="image-20210124182730186" style="zoom:67%;" />

<h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><p>​    分频器参数：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">if</span> (HAL_BOARD_SYS_FREQ==HAL_BOARD_SYS_FREQ_8M)</span></span><br><span class="line"><span class="comment">/*fDCOCLK=8M , uart para */</span></span><br><span class="line"><span class="comment">/***********baud rate********</span></span><br><span class="line"><span class="comment">BP---                  S_1200,  S_2400,  S_4800,  S_9600,  S_19200, S_38400, S_57600, S_115200*/</span></span><br><span class="line">uint16 arUCBRx[<span class="number">8</span>] = &#123;    <span class="number">27</span>,     <span class="number">13</span>,      <span class="number">6</span>,       <span class="number">833</span>,     <span class="number">416</span>,     <span class="number">208</span>,     <span class="number">138</span>,     <span class="number">69</span>    &#125;;	 <span class="comment">// 8MHz/S_Baud ~ _______(十进制数)</span></span><br><span class="line"><span class="comment">/*				 	0x04;	  0x0c;	   0x0E;	0x04;	0x0c;	  0x06;   0x0E;		0x08	*/</span></span><br><span class="line">uint16 arUCBRSx[<span class="number">8</span>]= &#123; UCBRS_2, UCBRS_6, UCBRS_7, UCBRS_2, UCBRS_6, UCBRS_3, UCBRS_7, UCBRS_4 &#125;;	<span class="comment">//见调制器参数表 Table16-2</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> (HAL_BOARD_SYS_FREQ==HAL_BOARD_SYS_FREQ_16M)</span></span><br><span class="line"><span class="comment">/*fDCOCLK=16M , uart para */</span></span><br><span class="line"><span class="comment">/***********baud rate********</span></span><br><span class="line"><span class="comment">BP---                  S_1200,  S_2400,  S_4800,  S_9600,  S_19200,  S_38400, S_57600, S_115200*/</span></span><br><span class="line">uint16 arUCBRx[<span class="number">8</span>] = &#123;    <span class="number">27</span>,     <span class="number">13</span>,      <span class="number">6</span>,      <span class="number">1666</span>,     <span class="number">833</span>,     <span class="number">416</span>,     <span class="number">208</span>,      <span class="number">138</span>  &#125;;</span><br><span class="line">uint16 arUCBRSx[<span class="number">8</span>]= &#123; UCBRS_2, UCBRS_6, UCBRS_7, UCBRS_6, UCBRS_2, UCBRS_6, UCBRS_3, UCBRS_7 &#125;;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p>​    初始化程序：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">InitHalUart</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> uart , <span class="keyword">unsigned</span> <span class="keyword">int</span> baud)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    uint8 unUartClk;	</span><br><span class="line">	<span class="keyword">if</span>( baud &gt;= UART_BAUD_DEF_END )</span><br><span class="line">		<span class="keyword">return</span> EP_FAILED;</span><br><span class="line">	InitHalUartBuf();</span><br><span class="line">	<span class="comment">//选择UCSI时钟源</span></span><br><span class="line">    <span class="comment">//BAUD &lt;= 4800, UCAxCTL1 置 01，选择ACLK为时钟源</span></span><br><span class="line">    <span class="comment">//BAUD &gt; 4800，UCAxCTL1 置 11/10，选择SMCLK为时钟源</span></span><br><span class="line">    <span class="keyword">switch</span>(baud)								   </span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">case</span> UART_BAUD_1200:</span><br><span class="line">		<span class="keyword">case</span> UART_BAUD_2400:</span><br><span class="line">		<span class="keyword">case</span> UART_BAUD_4800:</span><br><span class="line">			unUartClk=UCSSEL__ACLK;					<span class="comment">// CLK = ACLK	</span></span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">default</span>:</span><br><span class="line">			unUartClk=UCSSEL_2;						<span class="comment">// CLK = SMCLK			</span></span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">switch</span>(uart)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">case</span> HAL_UART_UCA0:</span><br><span class="line">			P3SEL |= BIT4 + BIT5;</span><br><span class="line">			UCA0CTL1 |= UCSWRST;				  <span class="comment">// **Put state machine in reset**</span></span><br><span class="line">			UCA0CTL1 |= unUartClk;                  <span class="comment">// 选择BRCLK的时钟源</span></span><br><span class="line">		    UCA0BR0 = (arUCBRx[baud] &amp; <span class="number">0xFF</span>);       <span class="comment">// 低八位赋值BR0</span></span><br><span class="line">		    UCA0BR1 = (arUCBRx[baud]&gt;&gt;<span class="number">8</span>)&amp;<span class="number">0xFF</span>;  	<span class="comment">// 高八位赋值BR1</span></span><br><span class="line">		    UCA0MCTL = arUCBRSx[baud];              <span class="comment">// </span></span><br><span class="line">			UCA0CTL1 &amp;= ~UCSWRST;                   <span class="comment">// **Initialize USCI state machine**</span></span><br><span class="line">			UCA0IE |=  UCRXIE;            			<span class="comment">// Enable USCI RX interrupt     		                 </span></span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> HAL_UART_UCA1:</span><br><span class="line">			P5SEL |= BIT6 + BIT7;</span><br><span class="line">			UCA1CTL1 |= UCSWRST;					<span class="comment">// **Put state machine in reset**</span></span><br><span class="line">			UCA1CTL1 |= unUartClk;  </span><br><span class="line">		    UCA1BR0 = (arUCBRx[baud] &amp; <span class="number">0xFF</span>);   </span><br><span class="line">		    UCA1BR1 = (arUCBRx[baud]&gt;&gt;<span class="number">8</span>)&amp;<span class="number">0xFF</span>;  	</span><br><span class="line">		    UCA1MCTL = arUCBRSx[baud];</span><br><span class="line">			UCA1CTL1 &amp;= ~UCSWRST;                   <span class="comment">// **Initialize USCI state machine**</span></span><br><span class="line">			UCA1IE |=  UCRXIE;            			<span class="comment">// Enable USCI RX interrupt     		                 </span></span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> HAL_UART_UCA2:</span><br><span class="line">			P9SEL |= BIT4 + BIT5;</span><br><span class="line">			UCA2CTL1 |= UCSWRST;					<span class="comment">// **Put state machine in reset**</span></span><br><span class="line">			UCA2CTL1 |= unUartClk;  </span><br><span class="line">		    UCA2BR0 = (arUCBRx[baud] &amp; <span class="number">0xFF</span>);   </span><br><span class="line">		    UCA2BR1 = (arUCBRx[baud]&gt;&gt;<span class="number">8</span>)&amp;<span class="number">0xFF</span>;  	</span><br><span class="line">		    UCA2MCTL = arUCBRSx[baud];</span><br><span class="line">			UCA2CTL1 &amp;= ~UCSWRST;                   <span class="comment">// **Initialize USCI state machine**</span></span><br><span class="line">			UCA2IE |=  UCRXIE;            			<span class="comment">// Enable USCI RX interrupt     		                 </span></span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> HAL_UART_UCA3:</span><br><span class="line">  			<span class="comment">//P10DIR |= BIT3;</span></span><br><span class="line">  			<span class="comment">//P10OUT &amp;= ~BIT3;			</span></span><br><span class="line">			P10SEL |= BIT4 + BIT5;</span><br><span class="line">			UCA3CTL1 |= UCSWRST;					<span class="comment">// **Put state machine in reset**</span></span><br><span class="line">			UCA3CTL1 |= unUartClk;  </span><br><span class="line">		    UCA3BR0 = (arUCBRx[baud] &amp; <span class="number">0xFF</span>);   </span><br><span class="line">		    UCA3BR1 = (arUCBRx[baud]&gt;&gt;<span class="number">8</span>)&amp;<span class="number">0xFF</span>;  	</span><br><span class="line">		    UCA3MCTL = arUCBRSx[baud];</span><br><span class="line">			UCA3CTL1 &amp;= ~UCSWRST;                   <span class="comment">// **Initialize USCI state machine**</span></span><br><span class="line">			UCA3IE |=  UCRXIE;            			<span class="comment">// Enable USCI RX interrupt     		                 </span></span><br><span class="line">			<span class="keyword">break</span>;									</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> EP_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>嵌入式开发</category>
      </categories>
      <tags>
        <tag>嵌入式</tag>
        <tag>MSP430</tag>
        <tag>IAR</tag>
        <tag>通信</tag>
      </tags>
  </entry>
  <entry>
    <title>MSP430单片机(六)——USCI-SPI模式</title>
    <url>/2021/01/25/MSP430%E5%8D%95%E7%89%87%E6%9C%BA%E5%85%A5%E9%97%A8(6)%E2%80%94%E2%80%94USCI-SPI%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<blockquote>
<p>在墨水屏入门功能开发(一)中写到了SPI的应用，但对SPI并没有做深入的了解，正好借开发墨水屏的机会，从原理到墨水屏开发的实际应用来全面学习SPI。</p>
</blockquote>
<a id="more"></a>

<h3 id="SPI"><a href="#SPI" class="headerlink" title="SPI"></a>SPI</h3><h4 id="SPI接口简介"><a href="#SPI接口简介" class="headerlink" title="SPI接口简介"></a>SPI接口简介</h4><p>SPI，是一种高速的，全双工(通信允许数据在两个方向上同时传输)，同步的通信总线，在芯片的管脚上只占用四根线，节约了芯片的管脚，为PCB的布局节省空间。主要应用与实时时钟，AD转换器，还有数字信号处理器和数字信号解码器之间。</p>
<h4 id="SPI内部结构"><a href="#SPI内部结构" class="headerlink" title="SPI内部结构"></a>SPI内部结构</h4><p>SPI接口一般使用4条线通信：</p>
<blockquote>
<p>MISO主设备数据输入，从设备数据输出；<br>MOSI主设备数据输出，从设备数据输入；<br>SCLK时钟信号，由主设备产生；<br>CS从设备片选信号，由主设备控制。</p>
</blockquote>
<p><strong>MISO做主机时作为输入，作为从机时作为输出，MOSI则相反。</strong></p>
<p>例：移位寄存器A数据为 <code>10101010</code> ，移位寄存器B为 <code>01010101</code> ，若进行信息传输，移位寄存器A作为主机，B作为从机，移位寄存器A的最高位“1”移至移位寄存器B的最高位，B的数据左移，将末位的 0 移至移位寄存器A。最终，移位寄存器A的数据变为 <code>01010101</code>，B的数据变为 <code>10101010</code>，实现了两个寄存器数据的互换。</p>
<p><strong>移位寄存器在进行数据传输时，主机给从机传输N个字节，从机也会给主机传输回N个字节。</strong>所以SPI会有read()和write()函数，这是因为寄存器在进行字节传输时同时有接受和发送。</p>
<h4 id="SPI工作原理总结"><a href="#SPI工作原理总结" class="headerlink" title="SPI工作原理总结"></a>SPI工作原理总结</h4><p>​        ① 硬件上为四根线；<br>​        ② 主机和从机都有一个串行移位寄存器，主机通过向它的SPI传销寄存器写入一个字节来发起一次传输；<br>​        ③ 串行移位寄存器通过MOSI信号线将字节传送给从机，从机也将自己的串行移位寄存器中的内容通过MISO信号线返回给主机，这样，两个移位寄存器中的内容就被交换；<br>​        ④外设的写操作和读操作是同步完成的，如果只进行写操作，主机只需忽略接收到的字节；反之，若主机要读取从机的一个字节，就必须发送一个空字节来引发从机的传输。</p>
<h4 id="SPI特征"><a href="#SPI特征" class="headerlink" title="SPI特征"></a>SPI特征</h4><ul>
<li>3线全双工同步传输</li>
<li>8位或者16位传输帧格式选择</li>
<li>主或从操作</li>
<li>支持多主模式</li>
<li><strong>可编程的时钟极性和相位</strong></li>
<li><strong>可编程的数据顺序</strong>，MSB在前或者LSB在前</li>
<li>可触发终端的专用发送和接受标志</li>
<li><strong>SPI总线忙状态标志</strong></li>
<li>支持可靠通信的硬件CRC<ul>
<li>在发送模式下,CRC的值可以作为最后一个字节发送</li>
<li>在全双工模式中对接收到的最后一个字节自动进行CRC校验</li>
</ul>
</li>
<li>支持DMA功能的1字节发送和接受缓冲器，产生发送和接受请求</li>
</ul>
<h5 id="时钟信号的相位和极性"><a href="#时钟信号的相位和极性" class="headerlink" title="时钟信号的相位和极性"></a>时钟信号的相位和极性</h5><p>在墨水屏的开发中，数据采样和时钟沿是绕不开的一个点，这两点与CPOL时钟极性和CPHA时钟相位的组合有关。</p>
<img src="/upload_image/SPI时序图.png" alt="SPI时序图" style="zoom: 40%;" />

<p>SPI CR寄存器的CPOL和CPHA位，能够 <code>0 1</code> 组合成四种可能的时序关系。CPOL(时钟极性)位控制在没有数据传输时时钟的空闲状态电平，此位对主模式和从模式下的设备都有效。如果CPOL被清 <code>0</code> ，SCK引脚在空状态保持低电平；如果CPOL被置 <code>1</code> ，SCK引脚在空闲状态保持高电平。如果CPHA(时钟相位)位被置 <code>1</code>，SCK时钟的第二个边沿(CPOL位为0时就是下降沿，CPOL位为 <code>1</code> 时就是上升沿)进行数据位的采样，数据在第二个时钟边沿被锁存。如果CPHA位被清 <code>0</code>，SCK时钟的第一边沿(CPOL位位‘0’时就是下降沿，CPOL位为 <code>1</code> 时就是上升沿)进行数据位采样，数据在第一个时钟边沿被锁存。</p>
<p>以表格形式总结以上文字：</p>
<table>
<thead>
<tr>
<th align="center">CPHA</th>
<th align="center">CPOL</th>
<th align="center">采样时刻</th>
<th align="center">SCK时钟</th>
</tr>
</thead>
<tbody><tr>
<td align="center">1</td>
<td align="center">0</td>
<td align="center">第二个时钟沿</td>
<td align="center">上升沿</td>
</tr>
<tr>
<td align="center">1</td>
<td align="center">1</td>
<td align="center">第二个时钟沿</td>
<td align="center">下降沿</td>
</tr>
<tr>
<td align="center">0</td>
<td align="center">1</td>
<td align="center">第一个时钟沿</td>
<td align="center">下降沿</td>
</tr>
<tr>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">第一个时钟沿</td>
<td align="center">上升</td>
</tr>
</tbody></table>
<h5 id="状态标志"><a href="#状态标志" class="headerlink" title="状态标志"></a>状态标志</h5><p>应用程序通过3个状态标志可以完全监控SPI总线的状态。</p>
<p><strong>发送缓冲器空闲标志(TXE)</strong></p>
<p>此标志为“1”时表明发送缓冲器为空，下一个待发送的数据可进入缓冲器中。当写入SPI_DR时，TXE标志被清除。</p>
<p><strong>接收缓冲器非空(RXNE)</strong></p>
<p>此标志位为“1”时表明在接收缓冲器中包含有效的接收数据。读SPI数据寄存器可以清除此标志。</p>
<p><strong>忙(BUSY)标志</strong></p>
<p>BUSY标志由硬件设置与清除(写入此位无效果)，此标志表明SPI通信层的状态。</p>
<h5 id="SPI中断"><a href="#SPI中断" class="headerlink" title="SPI中断"></a>SPI中断</h5><table>
<thead>
<tr>
<th align="center">中断事件</th>
<th align="center">事件标志</th>
<th align="center">使能控制位</th>
</tr>
</thead>
<tbody><tr>
<td align="center">发送缓冲器空标志</td>
<td align="center">TXE</td>
<td align="center">TXEIE</td>
</tr>
<tr>
<td align="center">接收缓冲器非空标志</td>
<td align="center">RXNE</td>
<td align="center">RXNEIE</td>
</tr>
<tr>
<td align="center">主模式失效事件</td>
<td align="center">MODF</td>
<td align="center">ERRIE</td>
</tr>
<tr>
<td align="center">溢出错误</td>
<td align="center">OVR</td>
<td align="center">ERRIE</td>
</tr>
<tr>
<td align="center">CRC错误标志</td>
<td align="center">CRCERR</td>
<td align="center">ERRIE</td>
</tr>
</tbody></table>
<h3 id="USCI-SPI-模式"><a href="#USCI-SPI-模式" class="headerlink" title="USCI-SPI 模式"></a>USCI-SPI 模式</h3><h4 id="USCI-SPI模式简介"><a href="#USCI-SPI模式简介" class="headerlink" title="USCI-SPI模式简介"></a>USCI-SPI模式简介</h4><p>在同步模式下，USCI通过三个或四个引脚将设备连接到外部系统： <code>UCxSIMO</code>， <code>UCxSOMI</code>， <code>UCxCLK</code> 和 <code>UCxSTE</code> 。 当 <code>UCSYNC</code>位置1时选择SPI模式，并通过 <code>UCMODEx</code>位选择SPI模式（3针或4针）。</p>
<p>在SPI模式下，串行数据通过主机提供的共享时钟由多个设备发送和接收。提供了一个额外的引脚UCxSTE，以使设备能够接收和发送数据，并由主机控制。</p>
<p>三个或四个信号用于SPI数据交换：</p>
<ul>
<li><code>UCxSIMO</code> 从机输入，主机输出主机模式： <code>UCxSIMO</code> 是数据输出线。从模式： <code>UCxSIMO</code> 是数据输入线。</li>
<li><code>UCxSOMI</code> 从机输出，主机处于主机模式： <code>UCxSOMI</code> 是数据输入线。从模式： <code>UCxSOMI</code> 是数据输出线。</li>
<li><code>UCxCLK</code>   USCI SPI时钟主模式： <code>UCxCLK</code> 是输出。从模式： <code>UCxCLK</code> 是输入。</li>
<li><code>UCxSTE</code>   从机发送使能。在4引脚模式下使用，以允许单个总线上有多个主机。在3针模式下不使用。见表17-1。</li>
</ul>
<table>
<thead>
<tr>
<th align="center">UCMODEx</th>
<th align="center">UCxSTE Active State</th>
<th align="center">UCxSTE</th>
<th align="center">Slave</th>
<th align="center">Master</th>
</tr>
</thead>
<tbody><tr>
<td align="center">01</td>
<td align="center">High</td>
<td align="center">0</td>
<td align="center">Inactive</td>
<td align="center">Active</td>
</tr>
<tr>
<td align="center"></td>
<td align="center"></td>
<td align="center">1</td>
<td align="center">Active</td>
<td align="center">Inactive</td>
</tr>
<tr>
<td align="center">10</td>
<td align="center">Low</td>
<td align="center">0</td>
<td align="center">Active</td>
<td align="center">Inactive</td>
</tr>
<tr>
<td align="center"></td>
<td align="center"></td>
<td align="center">1</td>
<td align="center">Inactive</td>
<td align="center">Active</td>
</tr>
</tbody></table>
<h4 id="主从模式"><a href="#主从模式" class="headerlink" title="主从模式"></a>主从模式</h4><p><strong>主机模式：</strong></p>
<p>要在主机模式下将数据接收到 <code>USCI</code>，必须将数据写入 <code>UCxTXBUF</code> ，因为接收和发送的操作是同时进行的。</p>
<img src="/upload_image/image-20210126160915298.png" alt="image-20210126160915298" style="zoom: 50%;" />

<p>看图说话，工作流程如下：</p>
<p>数据移至 <code>Transmit Buffer UCxTXBUF(TX数据缓冲区)</code> ，<code>USCI</code> 启动数据传输 -&gt; 数据被发送至 <code>Transmit Shift Register(TX移位寄存器)</code> -&gt;  从 <code>MSB</code> 或 <code>LSB</code> 开始在 <code>UCxSIMO</code> 上启动数据传输 -&gt; 数据进入 <code>Data Shift Register(DSR)</code> 之后通过 <code>UCxSOMI</code> 将数据传至 <code>Receive Shift Register(RX移位寄存器)</code> -&gt; 数据被传至 <code>Receive Buffer UCxRXBUF</code> ，同时接收中断标志 <code>UCRXIFG</code> 被置位(指示RX/TX操作已完成)</p>
<p><code>UCxSTE</code> 的作用是防止与另一个主机冲突：</p>
<p>主机在SET为高电平时正常操作，SET为低电平时(另一台设备申请成为主机)，当前主机驱动总线的MOSI和UCLK的引脚变为输入；</p>
<p>如果在主机被 <code>UCxSTE</code> 保持非活动状态时将数据写入 <code>UCxTXBUF</code> ，则一旦 <code>UCxSTE</code> 转换为主机活动状态，就会立即发送数据；</p>
<p>如果主机在活动状态被 <code>UCxTXBUF</code> 转换为非活动状态导致了传输终止，则必须将数据重写到 <code>UCxTXBUF</code> 中， <code>UCxSTE</code> 转换回主机活动状态时将重新进行传输</p>
<p><strong>从机模式：</strong></p>
<img src="/upload_image/image-20210126161129878.png" alt="image-20210126161129878" style="zoom: 50%;" />

<p>工作流程如下：</p>
<p>在 <code>UCxCLK</code> 之前，数据被写入 <code>UCxTXBUF</code> -&gt; 送至 <code>TX Shift Register</code> -&gt; 在 <code>UXcSOMI</code> 上传输至 <code>DSR</code> -&gt; 接收到设置的位数后，数据经 <code>UCxSIMO</code> 移至相对边缘的 <code>RX Shift Register</code> -&gt; 最后送入 <code>UCxRXBUF</code> -&gt; <code>UCRXIFG</code> 中断标志被置1，数据接收完成。</p>
<p><code>UCxSTE</code> 的作用是当作发送和接受允许信号：</p>
<p>当SET为1时该从机禁止发送和接受数据；</p>
<p><em>注：1. <code>UCxCLK</code> 用作 SPI 时钟的输入，必须由外部主机提供，传输速率由该时钟决定而不由内部时钟发生器决定；2.若新数据移至 <code>UCxRXBUF</code> 之前没有将其中的旧数据读取的话，将会导致溢出错误位UCOE</em></p>
<h4 id="寄存器"><a href="#寄存器" class="headerlink" title="寄存器"></a>寄存器</h4><p><strong>USCI_Ax Control Register 0 (UCAxCTL0)</strong></p>
<p><strong>USCI_Bx Control Register 0 (UCBxCTL0)</strong></p>
<img src="/upload_image/image-20210126163147114.png" alt="image-20210126163147114" style="zoom: 67%;" />

<p><strong>USCI_Ax Control Register 1 (UCAxCTL1)</strong></p>
<p><strong>USCI_Bx Control Register 1 (UCBxCTL1)</strong></p>
<p><img src="/upload_image/image-20210126163537402.png" alt="image-20210126163537402"></p>
<p><strong>USCI_Ax Bit Rate Control Register 0 (UCAxBR0)</strong> / <strong>USCI_Ax Bit Rate Control Register 0 (UCAxBR0)</strong></p>
<p><strong>USCI_Ax Bit Rate Control Register 1 (UCAxBR1)</strong> / <strong>USCI_Bx Bit Rate Control Register 1 (UCBxBR1)</strong></p>
<p><img src="/upload_image/image-20210126163925932.png" alt="image-20210126163925932"></p>
<h3 id="程序"><a href="#程序" class="headerlink" title="程序"></a>程序</h3><p>SPI初始化：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HAL_EPAPER_SPI_PRESCALER 	((uint8)(HAL_CPU_CLOCK_MHZ / 8.1) + 1)</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SPI_INIT</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    UCB1CTL1 = UCSSEL1 | UCSWRST;              <span class="comment">//SMCLK、启用软复位</span></span><br><span class="line">    UCB1CTL0 = UCCKPL | UCMSB | UCMST | UCSYNC; <span class="comment">//时钟极性高、MSB优先、UCMODE同步模式、同步模式打开</span></span><br><span class="line">    UCB1BR0 = HAL_EPAPER_SPI_PRESCALER;         <span class="comment">//设置频率</span></span><br><span class="line">    UCA0BR1 = <span class="number">0</span>;                                <span class="comment">//</span></span><br><span class="line">    UCB1CTL1 &amp;= ~UCSWRST;                       <span class="comment">//关闭软复位</span></span><br><span class="line">&#125;        </span><br></pre></td></tr></table></figure>
<p>管脚初始化：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">IO_Init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    P2DIR &amp;= ~BIT1; <span class="comment">//LBUSY</span></span><br><span class="line">	P2REN |= BIT1;</span><br><span class="line">    P2OUT &amp;= ~BIT1; <span class="comment">//BUSY引脚上拉电阻</span></span><br><span class="line">    P2DIR |= BIT3;  <span class="comment">//RESET</span></span><br><span class="line">    P3DIR |= BIT6;  <span class="comment">//LCS</span></span><br><span class="line">    P5DIR |= BIT4;  <span class="comment">//LDC</span></span><br><span class="line">    P5SEL |= BIT5;  <span class="comment">//LSCK</span></span><br><span class="line">    P3SEL |= BIT7;  <span class="comment">//LSDA</span></span><br><span class="line"></span><br><span class="line">    HAL_EPAPER_SPI_INIT();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>嵌入式开发</category>
      </categories>
      <tags>
        <tag>嵌入式</tag>
        <tag>通信协议</tag>
        <tag>SPI</tag>
        <tag>E-paper</tag>
      </tags>
  </entry>
  <entry>
    <title>VC++6.0打开多个窗口</title>
    <url>/2020/10/15/VC++6.0%E6%89%93%E5%BC%80%E5%A4%9A%E4%B8%AA%E7%AA%97%E5%8F%A3/</url>
    <content><![CDATA[<blockquote>
<p>做测试时需要打开两个.dsw,希望能够同时打开多个窗口进行开发调试。</p>
</blockquote>
<a id="more"></a>

<p>以管理员身份打开cmd，找到VC++6.0程序的路径“xxx\xxx\xxx\Bin\MSDEV.EXE”，在cmd窗口如下输入：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ftype dspfile=&quot;E:\Program Files (x86)\Microsoft Visual Studio\Common\MSDev98\Bin\MSDEV.EXE&quot; %1</span><br></pre></td></tr></table></figure>
<p>得到如图所示：<img src="/upload_image/image-20201015140628185.png" alt="image-20201015140628185" style="zoom: 33%;" /></p>
<p>打开VC++6.0，分别打开两个窗口，可以看到已经可以成功打开两个.dsw文件。<img src="/upload_image/image-20201015140805439.png" alt="image-20201015140805439" style="zoom: 50%;" /></p>
]]></content>
      <categories>
        <category>工具应用</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>编译软件</tag>
        <tag>VC6.0</tag>
      </tags>
  </entry>
  <entry>
    <title>VMware-pro15安装CentOS</title>
    <url>/2020/10/19/VMware-pro15%E5%AE%89%E8%A3%85CentOS/</url>
    <content><![CDATA[<blockquote>
<p>使用 VMware-pro15 安装 CentOS-7.x</p>
</blockquote>
<a id="more"></a>

<h2 id="虚拟机安装"><a href="#虚拟机安装" class="headerlink" title="虚拟机安装"></a>虚拟机安装</h2><p>安装vmware-pro15完成后打开，按如图所示加载 <code>CentOS-7.3-KDE-x86_64</code> 虚拟机。</p>
<img src="/upload_image/image-20201014132520253.png" alt="image-20201014132520253" style="zoom: 33%;" />

<p>点击【开启此虚拟机】，弹出【VMware Workstation 与 Device/Credential Guard 不兼容】的提示框，这是因为Device/Credential Guard 不兼容和Windows系统的Hyper-V不兼容导致的。解决方法按 <a href="https://blog.csdn.net/weixin_41661466/article/details/102745464?utm_medium=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromMachineLearnPai2-1.channel_param&depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromMachineLearnPai2-1.channel_param">解决VMware Workstation 与 Device/Credential Guard 不兼容问题</a> 此贴中给出的方法解决。</p>
<p>若控制面板没有找到<strong>Hyper-V</strong>，是因为windows版本为家庭/学生版，在该版本下解决方法为：</p>
<ol>
<li><p>按下【Win+R】打开运行，然后输入services.msc回车；</p>
<img src="/upload_image/image-20201014141839134.png" alt="image-20201014141839134" style="zoom: 50%;" />
</li>
<li><p>在服务中找到HV主机服务，双击打开，设置为禁用。</p>
<p><img src="/upload_image/image-20201014142022296.png" alt="image-20201014142022296"></p>
</li>
<li><p>按下【Win+X】键，打开【Windows PowerShell(管理员)(A)】</p>
<img src="/upload_image/image-20201014142343318.png" alt="image-20201014142343318" style="zoom: 50%;" />
</li>
<li><p>运行命令：bcdedit /set hypervisorlaunchtype off<img src="/upload_image/image-20201014142701724.png" alt="image-20201014142701724"></p>
</li>
<li><p>重启电脑后生效</p>
</li>
</ol>
<h2 id="虚拟机联网设置"><a href="#虚拟机联网设置" class="headerlink" title="虚拟机联网设置"></a>虚拟机联网设置</h2><p>安装好CentOS7之后，进行网络连接配置。</p>
<ol>
<li><p>配置VMware Network，右击【属性】，双击【Internet 协议版本4】，点击【使用下面的IP地址(S):】,按图设置IP地址和子网掩码。</p>
<img src="/upload_image/image-20201014143628782.png" alt="image-20201014143628782" style="zoom: 33%;" />

<img src="/upload_image/image-20201014143802868.png" alt="image-20201014143802868" style="zoom: 40%;" />
</li>
<li><p>配置主机本机的网络，这里是WLAN，本地连接/以太网同理，右击选择【属性】。选择【共享】，两个都勾选，家庭网络连接选择【VMware Network Adapter VMnet8】</p>
<img src="/upload_image/image-20201014143354192.png" alt="image-20201014143354192" style="zoom: 30%;" />

</li>
</ol>
<img src="/upload_image/image-20201014144112657.png" alt="image-20201014144112657" style="zoom: 50%;" />

<p>确定，退出，本机配置完毕。</p>
<ol start="3">
<li><p>配置虚拟机网络：点击【编辑】-【虚拟网络编辑器】</p>
<img src="/upload_image/image-20201014144715728.png" alt="image-20201014144715728" style="zoom:50%;" />

<p>选择【VMnet8-NAT模式】，选择【DHCP设置】，记住网络名、子网掩码、IP起始地址和结束地址；接着选择【NAT设置】，记住网关IP信息。</p>
<img src="/upload_image/image-20201014150327564.png" alt="image-20201014150327564" style="zoom:50%;" />

<img src="/upload_image/image-20201014150843862.png" alt="image-20201014150843862" style="zoom:50%;" />

</li>
</ol>
<p>基本设置完成后，进入CentOS系统准备修改网络配置文件，再此之前需要知道网络配置文件本身的权限为<strong>只读</strong>，修改、保存操作需要Linux下超级权限，配置sudu权限过程如下：</p>
<p> 1）进入超级用户模式。也就是输入”su -“,系统会让你输入超级用户密码，输入密码后就进入了超级用户模式。（当然，你也可以直接用root用）<br>        2）添加文件的写权限。也就是输入命 令”chmod u+w /etc/sudoers”。<br>        3）编辑/etc/sudoers文件。也就是输入命令”vim /etc/sudoers”,输入”i”进入编辑模式，找到这一 行：”root ALL=(ALL) ALL”在起下面添加”xxx ALL=(ALL) ALL”(这里的xxx是你的用户名)，然后保存（就是先按一 下Esc键，然后输入”:wq”）退出；如果要撤销文件的写权限，输入命令”chmod u-w /etc/sudoers”。</p>
<p>拥有权限之后回到终端，输入：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">vi /etc/sysconfig/network-scripts/ifcfg-ens33</span><br></pre></td></tr></table></figure>
<p>图框中为需要添加的内容，具体解释如下</p>
<img src="/upload_image/image-20201014152707698.png" alt="image-20201014152707698" style="zoom:67%;" />

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">BOOTPROTO=&quot;static&quot;		#设置静态IP</span><br><span class="line">DEVICE=&quot;ens33&quot;		    #网卡设备名，和文件名一致</span><br><span class="line">IPADDR=192.168.2.190	#IP地址，不超过步骤3中的IP范围</span><br><span class="line">NETMASK=255.255.255.0	#子网掩码</span><br><span class="line">GATEWAY=192.168.2.1		#网关</span><br><span class="line">DNS1=192.168.64.2		#DNS1地址</span><br><span class="line">DNS2=202.202.0.33		#DNS2地址</span><br></pre></td></tr></table></figure>
<p>保存退出，按【ESC】之后输入</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">:w !sudo tee %</span><br></pre></td></tr></table></figure>
<p>如果是在 su-(超级用户)模式下打开的文件，可直接“:wq”，保存退出。</p>
<p>最后重启虚拟机，打开终端，输入</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ping www.baidu.com</span><br></pre></td></tr></table></figure>
<p>验证网络连接成功。</p>
<img src="/upload_image/image-20201014160730472.png" alt="image-20201014160730472" style="zoom: 67%;" />

<h2 id="RPM安装"><a href="#RPM安装" class="headerlink" title="RPM安装"></a>RPM安装</h2><p>​    最简单的方法，在本地资源管理器中将下载好的rpm包拖入VMwara虚拟机目录中.</p>
<p>​    进入目录执行即可.</p>
]]></content>
      <categories>
        <category>工具应用</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>虚拟机</tag>
      </tags>
  </entry>
  <entry>
    <title>char和指针的问题</title>
    <url>/2020/12/09/char%E5%92%8Cunsigned%20char/</url>
    <content><![CDATA[<blockquote>
<p>char和指针的问题一直是我学了又忘的东西，故写下这篇博客做一个备忘录.</p>
</blockquote>
<a id="more"></a>

<h3 id="1-char和unsigned-char之间的区别"><a href="#1-char和unsigned-char之间的区别" class="headerlink" title="1.char和unsigned char之间的区别"></a>1.char和unsigned char之间的区别</h3><p>unsigned char 是无符号字节型，char类型变量的大小通常为1个字节(1个字节=8个位)，且属于整型。</p>
<p><strong>相同点：</strong>在内存中都是一个字节，8位（2^8=256），都能表示256个数字<br><strong>不同点：</strong>char的最高位为符号位，因此char能表示的数据范围是-128 ~ 127，unsigned char没有符号位，因此能表示的数据范围是 0 ~ 255</p>
<p>但是要把一个char类型的变量赋值给int、long等数据类型或进行类似的强制类型转换时时，系统会进行类型扩展，这时区别就大了。</p>
<p>对于char类型的变量，系统会认为最高位为符号位，然后对最高位进行扩展，即符号扩展：若最高位为1，则扩展到int时高位都以1填充。对于unsigned char类型的变量，系统会直接进行无符号扩展，即0扩展。扩展的高位都以0填充。</p>
<p>所以在进行类似的操作时，如果char和unsigned char最高位都是0，则结果是一样的；若char最高位为1，则结果会大相径庭。</p>
<h3 id="2-unsigned-char-的用法"><a href="#2-unsigned-char-的用法" class="headerlink" title="2. unsigned char* 的用法"></a>2. unsigned char* 的用法</h3><p>char *是字符串，以’/0’为结束符,unsigned char *是普通的指针;</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> *p;</span><br><span class="line">p = (<span class="keyword">unsigned</span> <span class="keyword">char</span> *)ZiFuKuTable;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> *ZiFuKuTable =</span><br><span class="line">&#123;</span><br><span class="line">	<span class="string">&quot;0123456789&quot;</span>\</span><br><span class="line">	<span class="string">&quot;TRHVI%:,mABCDEF.bat-&quot;</span>\</span><br><span class="line">	<span class="string">&quot; &quot;</span>\</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><code>p = (unsigned char *)ZiFuKuTable;</code>是指将ZiFuKuTable的地址值强制性转换为无符号字节类型；</p>
<p><code>*p</code>是对该地址进行取值操作。</p>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>编程语法</tag>
      </tags>
  </entry>
  <entry>
    <title>glib库</title>
    <url>/2020/10/27/glib/</url>
    <content><![CDATA[<h3 id="1-glib简介"><a href="#1-glib简介" class="headerlink" title="1. glib简介"></a>1. glib简介</h3><blockquote>
<p>glib库是Linux平台下最常用的C语言函数库，它具有很好的可移植性和实用性。<br>glib是Gtk +库和Gnome的基础。glib可以在多个平台下使用，比如Linux、Unix、Windows等。glib为许多标准的、常用的C语言结构提供了相应的替代物。</p>
</blockquote>
<a id="more"></a>

<h3 id="2-glib应用"><a href="#2-glib应用" class="headerlink" title="2. glib应用"></a>2. glib应用</h3><h4 id="2-1-常用的glib函数"><a href="#2-1-常用的glib函数" class="headerlink" title="2.1 常用的glib函数"></a>2.1 常用的glib函数</h4><blockquote>
<p>glib库：<a href="https://developer.gnome.org/glib/2.66/glib-The-Main-Event-Loop.html#g-main-loop-new">#include &lt;glib.h&gt;</a></p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">g_main_loop_new（GMainContext *context，</span><br><span class="line">                  gboolean is_running）;</span><br></pre></td></tr></table></figure>
<p><strong>Function：</strong></p>
<p>创建一个新的GMainLoop结构。</p>
<p><strong>Parameters：</strong></p>
<p><strong>context</strong>：GMainContext内容，如果为NULL，将会使用默认的context；</p>
<p><strong>is_running</strong>：设置为<code>True</code>表示循环正在运行；<code>True</code>或者<code>FLASE</code>都无所谓，在调用<code>g_main_loop_run()</code>之后，该设置都会被设置为<code>True</code>。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">g_warning()</span><br></pre></td></tr></table></figure>
<p><strong>Function：</strong></p>
<p>一个用于记录警告消息的宏/功能。</p>
<p>警告消息旨在在意外的外部条件（系统配置错误，文件丢失，其他受信任的程序违反协议，受信任的文件中的无效内容等）的情况下使用。</p>
<p><strong>Parameters：</strong></p>
<p>与<code>printf()</code>类似，格式字符串，后跟要插入格式字符串的参数</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">g_warning (<span class="string">&quot;Failed to connect to the D-BUS daemon: %s&quot;</span>, error.message);</span><br></pre></td></tr></table></figure>


<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">g_timeout_add (guint interval,</span><br><span class="line">               GSourceFunc function,</span><br><span class="line">               gpointer data);</span><br></pre></td></tr></table></figure>
<p><strong>Function：</strong></p>
<p>设置要定期调用的函数，默认优先级为G_PRIORITY_DEFAULT。 重复调用该函数，直到返回FALSE，这时超时将自动销毁，并且不会再次调用该函数。 该函数的第一个调用将在第一个间隔的结尾。</p>
<p><strong>Parameters：</strong></p>
<p><strong>context</strong>：GMainContext内容，如果为NULL，将会使用默认的context；</p>
<p><strong>is_running</strong>：设置为<code>True</code>表示循环正在运行；<code>True</code>或者<code>FLASE</code>都无所谓，在调用<code>g_main_loop_run()</code>之后，该设置都会被设置为<code>True</code>。</p>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>Linux</tag>
        <tag>库</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2020/06/15/hello-world/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>随笔</category>
      </categories>
  </entry>
  <entry>
    <title>typedef struct和struct</title>
    <url>/2020/10/27/typedef%20struct%E5%92%8Cstruct/</url>
    <content><![CDATA[<blockquote>
<p>typedef struct和struct的区别和用法，写作备忘.</p>
</blockquote>
<a id="more"></a>

<h4 id="C语言中："><a href="#C语言中：" class="headerlink" title="C语言中："></a>C语言中：</h4><p>在C中定义一个结构体类型要用typedef：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Student</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  GObjectClass parent_class;</span><br><span class="line">  DBusGConnection *connection;</span><br><span class="line">&#125; CalcServerClass;</span><br></pre></td></tr></table></figure>
<p>于是在声明变量时就可以：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">CalcServerClass *klass;</span><br></pre></td></tr></table></figure>
<p>如果没有<strong>typedef</strong>就必须使用“<em>struct  Student klass1;<em>”来声明，</em>CalcServerClass</em>就成了<em>struct Student</em>的另一个名字。</p>
<p>同样，这里可以不加 <strong>Student</strong>：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  GObjectClass parent_class;</span><br><span class="line">  DBusGConnection *connection;</span><br><span class="line">&#125; CalcServerClass;</span><br></pre></td></tr></table></figure>
<p>这样改变之后，声明时不能再用“struct  Student <em>klass1;”，必须是“</em>CalcServerClass <em>klass1;</em> ”。</p>
<h4 id="C-中："><a href="#C-中：" class="headerlink" title="C++中："></a>C++中：</h4><p>C++中想要实现上述同种效果，只需：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Student</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  GObjectClass parent_class;</span><br><span class="line">  DBusGConnection *connection;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<p>定义了结构体类型Student，声明变量时直接 “*Student <em>klass2</em>；”</p>
<p>如果要在C++中使用typedef的话，与在C中有一些区别：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span>   <span class="title">Student</span>  </span></span><br><span class="line"><span class="class">　　　&#123;</span>  </span><br><span class="line">　　　　<span class="keyword">int</span>   a;  </span><br><span class="line">　　　&#125;stu1;				<span class="comment">//stu1是一个变量 </span></span><br></pre></td></tr></table></figure>
<p>使用时可以直接访问 <em>stu1.a</em></p>
<p>而</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span>   <span class="class"><span class="keyword">struct</span>   <span class="title">Student2</span>  </span></span><br><span class="line"><span class="class">　　　&#123;</span>  </span><br><span class="line">　　　　<span class="keyword">int</span>   a;  </span><br><span class="line">　　　&#125;stu2;				<span class="comment">//stu2是一个结构体类型=struct Student  </span></span><br></pre></td></tr></table></figure>
<p>stu2则必须先“*stu s2;<em>”，然后才能“</em>s2.a=10;*”</p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p><strong>typedef struct 和struct的实质：</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span>   <span class="class"><span class="keyword">struct</span>   <span class="title">tagMyStruct</span> </span></span><br><span class="line"><span class="class">　　　&#123;</span>  </span><br><span class="line">　　　　<span class="keyword">int</span>   a;  </span><br><span class="line">　　　&#125;Mystruct;</span><br></pre></td></tr></table></figure>
<p><em>tagMystruct</em>是标识符，<em>MyStruct</em>是变量类型(相当于 <em>int</em>、<em>char</em>等一样)。</p>
<p>这一语句实际上完成了两个操作：</p>
<ol>
<li><p>定义一个新的结构类型</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span>   <span class="title">tagMyStruct</span> </span></span><br><span class="line"><span class="class">　　　&#123;</span>  </span><br><span class="line">　　　　<span class="keyword">int</span>   a;  </span><br><span class="line">　　　&#125;;</span><br></pre></td></tr></table></figure>
<p><em>tagMyStruct</em>称为“tag”，即“标签”，实际上是一个临时名字，不论<em>typedef struct</em>是否和<em>tagMyStruc</em>t放在一起，这个结构都存在。</p>
<p>可以使用<em>struct tagMyStruct Name1</em>来定义变量，但 <em>tagMyStruct Name1</em>来定义变量是错误的，因为<em>struct</em>和<em>tagMyStruct</em>放在一起才能表示一个结构类型。</p>
</li>
<li><p>typedef为这个新的结构起了一个新的名字，叫Mystruct。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">tagMyStruct</span> <span class="title">MyStruct</span>;</span></span><br></pre></td></tr></table></figure>
<p>因此，Mystruct在实际上相当于struct tagMyStruct，我们可以使用MyStruct varName定义变量。</p>
</li>
</ol>
<p><strong>C和C++在使用上的区别</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span>   <span class="class"><span class="keyword">struct</span>   <span class="title">tagMyStruct</span> </span></span><br><span class="line"><span class="class">　　　&#123;</span>  </span><br><span class="line">　　　　<span class="keyword">int</span>   a;  </span><br><span class="line">　　　&#125;Mystruct;</span><br></pre></td></tr></table></figure>
<p>在C中，这个申明后申请结构变量的方法有两种：</p>
<p>​    (1)struct tagMyStruct 变量名</p>
<p>​    (2)MyStruct 变量名</p>
<p>在C++中，使用方法如下：</p>
<p>​    (1)struct tagMyStruct 变量名</p>
<p>​    (2)MyStruct 变量名</p>
<p>​    (3)tagMyStruct 变量名</p>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>编程语法</tag>
      </tags>
  </entry>
  <entry>
    <title>树莓派平台自建博客(二)——博客上传&amp;域名绑定</title>
    <url>/2021/01/13/%E8%87%AA%E5%BB%BA%E5%8D%9A%E5%AE%A2(%E4%BA%8C)%E2%80%94%E2%80%94%E5%8D%9A%E5%AE%A2%E4%B8%8A%E4%BC%A0&amp;%E5%9F%9F%E5%90%8D%E7%BB%91%E5%AE%9A/</url>
    <content><![CDATA[<blockquote>
<p>搭建完树莓派的环境之后接下来就是需要将blog上传到Github Page进行发布</p>
</blockquote>
<a id="more"></a>

<h3 id="令人Angry的-Github-Pages"><a href="#令人Angry的-Github-Pages" class="headerlink" title="令人Angry的 Github Pages"></a>令人Angry的 Github Pages</h3><p>​    创建一个目录用来放博客的文件，名字任意</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo mkdir blog</span><br><span class="line">cd blog</span><br></pre></td></tr></table></figure>
<p>​    进入blog目录之后，初始化hexo：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo hexo init</span><br></pre></td></tr></table></figure>
<img src="/upload_image/image-20210111154531312.png" alt="image-20210111154531312" style="zoom: 50%;" />

<p>​    煲汤…</p>
<p>​    启动hexo：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo hexo s</span><br></pre></td></tr></table></figure>
<img src="/upload_image/image-20210111155319327.png" alt="image-20210111155319327" style="zoom: 50%;" />

<p>​    <code>Ctrl + C</code> 退出，安装 deployer</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo cnpm install --save hexo-deployer-git</span><br></pre></td></tr></table></figure>
<img src="/upload_image/image-20210111163300563.png" alt="image-20210111163300563" style="zoom:50%;" />

<p>​    启动博客： <code>sudo hexo s</code></p>
<img src="/upload_image/image-20210111164141255.png" alt="image-20210111164141255" style="zoom: 67%;" />

<p>​    上传博客： <code>sudo hexo d</code></p>
<img src="/upload_image/image-20210111164422107.png" alt="image-20210111164422107" style="zoom:50%;" />

<img src="/upload_image/image-20210111164454185.png" alt="image-20210111164454185" style="zoom: 50%;" />

<p>​    我以为是我的GitHub第一邮箱设置的是Gmail导致了auto detect失败，将第一邮箱设置成163之后也还是失败了…</p>
<p>​    于是当前的问题就变成了我输入 <code>git config -l</code> 能够正确显示我的name和email，但当我试图push的时候git却说不能识别我的身份…</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">*** Please tell me who you are.</span><br><span class="line"></span><br><span class="line">Run</span><br><span class="line"></span><br><span class="line">  git config --global user.email &quot;you@example.com&quot;</span><br><span class="line">  git config --global user.name &quot;Your Name&quot;</span><br><span class="line"></span><br><span class="line">to set your account&#x27;s default identity.</span><br><span class="line">Omit --global to set the identity only in this repository.</span><br><span class="line"></span><br><span class="line">fatal: unable to auto-detect email address (got &#x27;root@raspberrypi.(none)&#x27;)</span><br><span class="line">error: src refspec HEAD does not match any.</span><br><span class="line">error: 无法推送一些引用到 &#x27;https://github.com/dzy404/dzy404.github.io&#x27;</span><br></pre></td></tr></table></figure>
<p>​    easy,easy…(我一开始以为这只是个小问题，没想到这个报错提示一直伴随着我接下来的22小时)</p>
<p>​    这种问题只可能有两个可能：1.我对git不够了解，需要重新复习一下 git 的目录结构以及配置；2.GitHub那边可能有问题。</p>
<p>​    第一种我在大学里做项目时就已经遇到过，当时的我选择了绕开，现在的我还是一条懒狗，所以我先找第二种情况可能的解决方法。</p>
<p>​    于是尝试了很多次比如 hexo-deployer 在 pi 目录、home 目录和 blog目录下重新安装或者是更改_config.yml之类的操作，最终都以失败告终。</p>
<p>​    然后我决定暂时放弃去看网上的教程和博客，直奔 hexo-deployer 的 <a href="https://hexo.io/zh-cn/docs/one-command-deployment.html">官方文档</a> 去：[部署]-[Git]部分，最后的第四点提醒要在Github的库设置中也要设置成_config.yml配置中的分支名称。</p>
<img src="/upload_image/image-20210113120314433.png" alt="image-20210113120314433" style="zoom:50%;" />

<p>​    打开GitHub官网，翻到库的 Settings</p>
<p>​    果然，Github 更新了Github Page的用法，<strong>必须在库设置（Repository Settings）设置好Source和发布站点…</strong></p>
<img src="/upload_image/image-20210113141759658.png" alt="image-20210113141759658" style="zoom:50%;" />

<p>​    打开 <a href="https://docs.github.com/en/free-pro-team@latest/github/working-with-github-pages/creating-a-github-pages-site#creating-your-site">Github Paga的官方文档</a> ，根据它的步骤一步步设置所有者和 Github Page的发布站点，如图：</p>
<img src="/upload_image/image-20210113132556672.png" alt="image-20210113132556672" style="zoom:50%;" />

<img src="/upload_image/image-20210113132901512.png" alt="image-20210113132901512" style="zoom:50%;" />

<p>​    我以为我的 git 推送失败是因为这个没有设置，于是在设置结束之后我直奔终端，结果还是以失败告终…</p>
<p>​    我排除了第二种情况的可能性，唯一的可能只有我对 git 的一知半解导致了一直在撞南墙</p>
<h4 id="尝试一：利用-cache-将我的密码临时存储在内存里"><a href="#尝试一：利用-cache-将我的密码临时存储在内存里" class="headerlink" title="尝试一：利用 cache 将我的密码临时存储在内存里"></a>尝试一：利用 cache 将我的密码临时存储在内存里</h4><p>​    有可能是name和email的环境路径不对劲导致了deployer读不到信息；</p>
<p>​    既然读不到我的git身份信息，那就利用 cache 将我的密码临时存储在内存里再进行操作，于是我打开 <a href="https://git-scm.com/docs/git-credential-cache">git 的官方文档</a> ：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd home/pi</span><br><span class="line">git config credential.helper cache</span><br><span class="line">cd blog </span><br><span class="line">sudo hexo d</span><br></pre></td></tr></table></figure>
<p>​    失败…</p>
<h4 id="尝试二：-git-和-ssh-文件的位置"><a href="#尝试二：-git-和-ssh-文件的位置" class="headerlink" title="尝试二：.git 和 .ssh 文件的位置"></a>尝试二：.git 和 .ssh 文件的位置</h4><p>​    我先是到 Pi 目录下（此时pi目录下只有一个 .git 目录）执行了 <code>sudo hexo d</code>：</p>
<img src="/upload_image/image-20210113143531819.png" alt="image-20210113143531819" style="zoom:50%;" />

<p>​    说明 hexo命令必须在 执行 <code>hexo init</code> 的目录下进行…Fine</p>
<p>​    我将Pi目录下的 .git 目录打包送到了bolg目录下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo mv ./.git ./blog</span><br><span class="line">cd blog/.git</span><br><span class="line">sudo nano config</span><br></pre></td></tr></table></figure>
<p>​    确认configure文件中是否有email和name的信息，如果没有，添加如下字段：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">［user］</span><br><span class="line"> 	email＝your email		#你的GitHub邮箱</span><br><span class="line"> 	name＝your name			#你的Github名字</span><br></pre></td></tr></table></figure>
<p>​    这样的话，我的blog目录下就有.git文件，应当就能读取到我的信息</p>
<p>​    but…</p>
<img src="/upload_image/image-20210113144236022.png" alt="image-20210113144236022" style="zoom:50%;" />

<h4 id="尝试三：将deployer推倒重来"><a href="#尝试三：将deployer推倒重来" class="headerlink" title="尝试三：将deployer推倒重来"></a>尝试三：将deployer推倒重来</h4><p>​    参考链接：<a href="https://www.cnblogs.com/tenderwx/p/5783432.html">【Hexo】deploy出错的解决方法</a></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd blog</span><br><span class="line">git config --list	</span><br><span class="line"><span class="meta">#</span><span class="bash">一般会出现你的user.name和user.email，不出现也没关系</span></span><br><span class="line">sudo rm -rf .deployer_git</span><br><span class="line">sudo hexo d</span><br></pre></td></tr></table></figure>
<img src="/upload_image/image-20210113151136100.png" alt="image-20210113151136100" style="zoom:50%;" />

<p>​    还是失败…</p>
<h4 id="尝试四：root-大法好"><a href="#尝试四：root-大法好" class="headerlink" title="尝试四：root 大法好"></a>尝试四：root 大法好</h4><p>​    事先说明，root大法我成功了，但来来回回的曲折比前三种方法可能还要更多一点，顺带着还学习了Linux的权限控制</p>
<p>​    Linux环境下hexo的 <code>hexo d</code> 在各个博主的博文里体现的似乎都很顺利，几乎没有博主在这一步被卡过…Linux方面找不到我想要的答案，我就去找了Windows下配置 <code>hexo d</code> 的步骤和问题。发现Windows下要进行commit必须要在 <code>Git Bush</code> 进行…</p>
<p>​    于是我怀疑我的所有命令都是在 <code>Pi@raspberry:</code>这个用户下进行的，将信将疑地进入blog目录，然后输入 <code>su git</code>，输入我的Github密码，我的终端变了颜色</p>
<img src="/upload_image/image-20210113152554039.png" alt="image-20210113152554039" style="zoom:50%;" />

<p>​    也就是说当前我的操作是在git用户下进行的，按理说我是输了GitHub密码进来的，当前的账户就是我的账户不可能会出现deployer不能识别我的情况，输入：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo hexo d</span><br></pre></td></tr></table></figure>
<p>​    “权力越大，责任越大” ，整挺好；输入Github密码</p>
<img src="/upload_image/image-20210113153008674.png" alt="image-20210113153008674" style="zoom:50%;" />

<p>​    提示我：<code>Git不在 sudoers 文件中。此事将被报告</code> </p>
<p>​    那就放弃管理员权限直接开d</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hexo d</span><br></pre></td></tr></table></figure>
<p>​    提示我 <code>Error: EACCES: permission denied, unlink &#39;/home/pi/blog/.deploy_git/index.html&#39;</code> .</p>
<img src="/upload_image/image-20210113153354265.png" alt="image-20210113153354265" style="zoom:50%;" />

<p>​    死结就在这里，sudo的话git没权限，不 sudo 的话deployer 禁止非管理员启动.</p>
<p>​    我对Linux的配置文件的原则是能不招惹就不招惹，配错了重装一切就得重头来过…</p>
<p>​    第一个思路：<strong>将.deployer_git这个文件的权限拉满拉到 777</strong></p>
<img src="/upload_image/image-20210113153801944.png" alt="image-20210113153801944" style="zoom:50%;" />

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd blog</span><br><span class="line">su root	</span><br><span class="line"><span class="meta">#</span><span class="bash">输入root密码</span></span><br><span class="line">chmod 777 .deployer_git</span><br></pre></td></tr></table></figure>
<p>​    再次尝试，失败；</p>
<p>​    第二个思路：<strong>硬着头皮去改 sudoers 这个文件</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">su root</span><br><span class="line"><span class="meta">#</span><span class="bash">输入root密码</span></span><br><span class="line">cd .. </span><br><span class="line">cd ..</span><br><span class="line">nano etc/sudoers</span><br></pre></td></tr></table></figure>
<img src="/upload_image/image-20210113154809149.png" alt="image-20210113154809149" style="zoom:50%;" />

<p>​    <em>注意：在这种情况下，git 这个用户已经拥有和root一样的权限，在这个用户下面进行操作一定要注意</em></p>
<p>​    <code>Ctrl+X</code> ，Y 退出</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd home/pi</span><br><span class="line">su git</span><br><span class="line">cd blog </span><br><span class="line">sudo hexo d</span><br></pre></td></tr></table></figure>
<img src="/upload_image/image-20210113155440294.png" alt="image-20210113155440294" style="zoom:50%;" />

<p>​    没有权限的提示消失了，接下来就是在 git 用户下解决 email 探测问题</p>
<p>​    在各个目录下面安装 git ，使用 <code>sudo npm install git</code> 在/home，/pi，/blog 下执行这个指令</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd home</span><br><span class="line">sudo mkdir git</span><br><span class="line">cd git</span><br><span class="line">sudo touch .gitconfig</span><br><span class="line">sudo nano .gitconfig</span><br></pre></td></tr></table></figure>
<p>​    加上自己的user.name 和user.email，见尝试二</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">su git </span><br><span class="line">cd home/pi/blog</span><br><span class="line">sudo git config --global user.name &quot;dzy404&quot;</span><br><span class="line">sudo git config --global user.email &quot;dzy1056343052@163.com&quot;</span><br><span class="line">sudo hexo d</span><br></pre></td></tr></table></figure>
<img src="/upload_image/image-20210113160915169.png" alt="image-20210113160915169" style="zoom:67%;" />

<p>​    成功了…</p>
<h4 id="原因总结"><a href="#原因总结" class="headerlink" title="原因总结"></a>原因总结</h4><p>​    <strong>报错一</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">*** Please tell me who you are.</span><br><span class="line"></span><br><span class="line">Run</span><br><span class="line"></span><br><span class="line">  git config --global user.email &quot;you@example.com&quot;</span><br><span class="line">  git config --global user.name &quot;Your Name&quot;</span><br><span class="line"></span><br><span class="line">to set your account&#x27;s default identity.</span><br><span class="line">Omit --global to set the identity only in this repository.</span><br><span class="line"></span><br><span class="line">fatal: unable to auto-detect email address (got &#x27;root@raspberrypi.(none)&#x27;)</span><br><span class="line">error: src refspec HEAD does not match any.</span><br><span class="line">error: 无法推送一些引用到 &#x27;https://github.com/dzy404/dzy404.github.io&#x27;</span><br><span class="line">FATAL &#123; err:</span><br><span class="line">   &#123; Error: Spawn failed</span><br><span class="line">       at ChildProcess.task.on.code (/home/pi/blog/node_modules/hexo-deployer-gi t/node_modules/hexo-util/lib/spawn.js:51:21)</span><br><span class="line">       at ChildProcess.emit (events.js:182:13)</span><br><span class="line">       at Process.ChildProcess._handle.onexit (internal/child_process.js:240:12)  code: 1 &#125; &#125; &#x27;Something\&#x27;s wrong. Maybe you can find the solution here: %s&#x27; &#x27;\u0 01b[4mhttps://hexo.io/docs/troubleshooting.html\u001b[24m&#x27;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>​    这是最主要的问题，问题的关键在于检测不到我的github信息；</p>
<p>​    在 pi 和 root用户下都尝试过 <code>sudo git config --global  xxxxxx</code> 的操作但还是会出现；</p>
<p>​    通过Windows配置时需要通过 <code>Git Bush</code> 进行操作发现有可能是账户的问题，就考虑切换 Git 用户进行 git config</p>
<p>​    最后成功</p>
<p>​    <strong>报错二</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">EACCES: permission denied, unlink</span><br></pre></td></tr></table></figure>
<p>​    权限问题：不加sudo 进行hexo d就会出现报错</p>
<p>​    <strong>报错三</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">xxxx不在sudoers文件中。此时将被报告</span><br></pre></td></tr></table></figure>
<p>​    切换到root，在/etc/sudoers中加上当前用户的名字</p>
<p>​    <strong>报错四</strong></p>
<p>​    在每一次hexo d失败后重新尝试时，都可以将你blog目录下的.deployer_git整个目录删掉再进行尝试。然后终端输入</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git config --global user.name &quot;yourname&quot;</span><br><span class="line">git config --global user.email &quot;youremail&quot;</span><br></pre></td></tr></table></figure>
<p>​    或是直接打开.git/config文件，加上</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">［user］</span><br><span class="line"> 	email＝your email</span><br><span class="line"> 	name＝your name</span><br></pre></td></tr></table></figure>
<p>​    <strong>报错五</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ERROR Deployer not found: git</span><br></pre></td></tr></table></figure>
<p>​    再站点目录安装deployer插件，执行</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo npm uninstall hexo-deployer-git --save</span><br><span class="line">sudo npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure>
<p>​    事实上，在后续的尝试中发现，不需要Git用户进行 <code>sudo hexo d</code> 也可以成功，大致可以知道其实在第四次尝试之前，问题就应该解决了，只不过我没有先进行 root 权限下的push而是用了git用户；也有可能是在git下成功一次之后，hexo 就能够探测到我的 Email地址….相当玄学</p>
<h3 id="域名绑定"><a href="#域名绑定" class="headerlink" title="域名绑定"></a>域名绑定</h3><p>​    阿里云买一个适合自己的域名，看各人博客定位，我选择的是dzyblog.site;</p>
<p>​    实名认证;</p>
<p>​    Github下设置打开仓库的 [Settings]，拖到下方 [Custom domain] 添加自己的域名；</p>
<img src="/upload_image/image-20210113170231119.png" alt="image-20210113170231119" style="zoom:50%;" />

<p>​    这个时候仓库的根目录下面就会出现CNAME的文件，打开之后是域名的名字，如果没有则手动添加；</p>
<p>​    有了域名之后就需要解析；</p>
<p>​    再更新主题之后会有 <code>sudo hexo d</code> 的操作，然后就可以发现浏览器输入独立域名页面Page显示404，但输入 <code>xxxx.github.io</code> 还是能够访问，非常的amazing</p>
<p>​    我以为是我DNS解析出了问题，打开阿里云解析：</p>
<table>
<thead>
<tr>
<th align="center">主机记录</th>
<th align="center">记录类型</th>
<th align="center">解析路线</th>
<th align="center">记录值</th>
</tr>
</thead>
<tbody><tr>
<td align="center">@</td>
<td align="center">A</td>
<td align="center">默认</td>
<td align="center">ip地址(ip地址的获得通过在终端Ping你的 <code>用户名.github.io</code> 获得)</td>
</tr>
<tr>
<td align="center">www</td>
<td align="center">CNAME</td>
<td align="center">默认</td>
<td align="center">用户名.github.io</td>
</tr>
</tbody></table>
<img src="/upload_image/image-20210114093742330.png" alt="image-20210114093742330" style="zoom:50%;" />

<p>​    解析是没有问题的，检查目录结构，发现问题所在：</p>
<p>​    树莓派本地并没有添加上述CNAME的文件，所以在进行一次提交之后，新版本就把原来的老版本里CNAME文件给删除了…</p>
<p>​    需要在本地source文件里添加CNAME文件，再依次执行 <code>hexo clean</code> <code>hexo g</code> <code>hexo s</code> .</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd blog/source</span><br><span class="line">sudo touch CNAME</span><br><span class="line">sudo nano CNAME</span><br><span class="line"><span class="meta">#</span><span class="bash">添加自己的域名</span></span><br></pre></td></tr></table></figure>
<img src="/upload_image/image-20210114094137705.png" alt="image-20210114094137705" style="zoom:50%;" />

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo hexo clean</span><br><span class="line">sudo hexo g</span><br><span class="line">sudo hexo d</span><br></pre></td></tr></table></figure>
<h3 id="其他问题"><a href="#其他问题" class="headerlink" title="其他问题"></a>其他问题</h3><ol>
<li><p>中间做github推送时心态崩溃把整个blog的文件目录都删了准备重建，这时候在blog下执行 <code>sudo hexo init</code>发现报错：</p>
<img src="/upload_image/image-20210112101348945.png" alt="image-20210112101348945" style="zoom: 50%;" />

<p>心态崩溃*2…加上sudo之后再次尝试：</p>
<img src="/upload_image/image-20210112101447248.png" alt="image-20210112101447248" style="zoom:50%;" />

<p>心态崩溃*3…Google了一圈怀疑可能是自己误删了pi根目录下面的一些隐藏文件导致把git也删了…于是重装git：</p>
<img src="/upload_image/image-20210112101622397.png" alt="image-20210112101622397" style="zoom:50%;" />

<p>不对劲，安装git要在pi的根目录下进行：<code>cd ..</code>，安装git</p>
<img src="/upload_image/image-20210112101718817.png" alt="image-20210112101718817" style="zoom:50%;" />

<p>提示缺少<code>package.json</code>文件，印象里确实把它删了，解决方法：将npm初始化</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm init</span><br></pre></td></tr></table></figure>
<p>安装git：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo npm install git</span><br></pre></td></tr></table></figure>
<img src="/upload_image/image-20210112101927936.png" alt="image-20210112101927936" style="zoom:50%;" />

<p>重新搭框架：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd blog </span><br><span class="line">sudo hexo init</span><br></pre></td></tr></table></figure>
<img src="/upload_image/image-20210112102109683.png" alt="image-20210112102109683" style="zoom:50%;" />
</li>
<li><p>git连接不上了: Permission denied (publickey) 的解决方法(树莓派端)</p>
<p><strong>错误报告：</strong><code>Permission denied (publickey).</code></p>
<p><strong>前情提要：</strong>在RaspberryPi本地和Github端都已经设置好ssh公钥…但是当我试图push我的本地hexo时，发现没有成功于是就删掉了本地的.ssh文件，按照之前的github公钥方式再次尝试就不行了…</p>
<p><strong>解决方案：</strong></p>
<ol>
<li><p>先删除GitHub网页中的ssh公钥和树莓派本地/pi/.ssh/这个文件夹；</p>
</li>
<li><p> 不再使用 <code>ssh-keygen -t rsa -C &quot;你的邮箱地址&quot;</code> 这个命令，使用全默认 <code>ssh -keygen -t rsa</code> ;</p>
</li>
<li><p> <code>cat ~/.ssh/id_rsa.pub</code> ，将这段public key复制到Github的 <a href="https://github.com/settings/keys">New ssh</a> 里；</p>
</li>
<li><p>回到shell，删掉原来的remote信息 <code>git remote rm origin</code> ;</p>
</li>
<li><p><code>ssh -T git@github.com</code>，Done. 出现Hi，xxxxx的提示就表示成功。</p>
</li>
</ol>
<img src="/upload_image/image-20210112151849544.png" alt="image-20210112151849544" style="zoom:67%;" />

</li>
</ol>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Github</tag>
        <tag>树莓派</tag>
      </tags>
  </entry>
  <entry>
    <title>D-Bus详解与应用</title>
    <url>/2020/10/28/D-Bus/</url>
    <content><![CDATA[<blockquote>
<p>D-Bus的方式在移动手机操作系统中非常重要，包括Maemo，Moblin等以Linux为基础的操作系统。<br>参考链接：<a href="https://www.freedesktop.org/wiki/Software/dbus/">D-bus简介</a> , <a href="https://www.ibm.com/developerworks/cn/linux/l-dbus.html">使用 D-BUS 连接桌面应用程序</a> , <a href="https://dbus.freedesktop.org/doc/dbus-specification.html">D-总线规格</a> </p>
</blockquote>
<hr>
<a id="more"></a>

<h3 id="D-bus简介"><a href="#D-bus简介" class="headerlink" title="D-bus简介"></a>D-bus简介</h3><h4 id="什么是D-Bus"><a href="#什么是D-Bus" class="headerlink" title="什么是D-Bus"></a>什么是D-Bus</h4><p>有很多IPC（<em>interprocess communication</em> ） ，用于不同的解决方案：CORBA 是用于面向对象编程中复杂的 IPC 的一个强大的解决方案。DCOP 是一个较轻量级的 IPC 框架，功能较少，但是可以很好地集成到 K 桌面环境中。SOAP 和 XML-RPC 设计用于 Web 服务，因而使用 HTTP 作为其传输协议。D-BUS 设计用于桌面应用程序和 OS 通信。D-Bus(其中D原先是代表桌面“Desktop” 的意思)，即：用于桌面操作系统的通信总线。现在逐渐被引入到<strong>嵌入式系统</strong>中，不过名字还是保留原先的叫法而已。</p>
<h4 id="D-Bus的特性"><a href="#D-Bus的特性" class="headerlink" title="D-Bus的特性"></a>D-Bus的特性</h4><ul>
<li>低延迟、低开小，设计小而高效</li>
<li>二进制协议而不是文本，去除了序列化过程</li>
<li>结构化的名字空间</li>
<li>独立于架构的数据格式</li>
<li>支持消息中的大部分通用数据元素</li>
<li>带有异常处理的通用远程调用接口</li>
<li>支持广播类型的通信</li>
</ul>
<h4 id="D-Bus的内容"><a href="#D-Bus的内容" class="headerlink" title="D-Bus的内容"></a>D-Bus的内容</h4><p>D-Bus是一个为<strong>应用程序间通信</strong>的<strong>消息总线系统</strong>, 用于进程之间的通信。它是个3层架构的IPC 系统，包括：</p>
<ul>
<li>函数库<em>libdbus</em> ，用于两个应用程序互相联系和交互消息。</li>
<li>一个基于libdbus构造的消息总线守护进程，可同时与多个应用程序相连，并能把来自一个应用程序的消息路由到0或者多个其他程序。</li>
<li>基于特定应用程序框架的封装库或捆绑（<em>wrapper libraries or bindings</em> ）。例如，libdbus-glib和libdbus-qt，还有绑定在其他语言，例如Python的。大多数开发者都是使用这些封装库的API，因为它们简化了D-Bus编程细节。libdbus被有意设计成为更高层次绑定的底层后端（<em>low-level backend</em> ）。大部分libdbus的 API仅仅是为了用来实现绑定。</li>
</ul>
<h4 id="D-Bus的内部工作方式"><a href="#D-Bus的内部工作方式" class="headerlink" title="D-Bus的内部工作方式"></a>D-Bus的内部工作方式</h4><p>典型的 D-BUS 设置将由几个总线构成。将有一个持久的 <em>系统总线（system bus）</em>，它在 引导时就会启动。这个总线由操作系统和后台进程使用，安全性非常好，以使得任意的应用程序 不能欺骗系统事件。还将有很多 <em>会话总线（session buses）</em>，这些总线当用户登录后启动，属于 那个用户私有。它是用户的应用程序用来通信的一个会话总线。当然，如果一个应用程序需要接收 来自系统总线的消息，它不如直接连接到系统总线 —— 不过，它可以发送的消息将是受限的。</p>
<p>一旦应用程序连接到了一个总线，它们就必须通过添加 <em>匹配器（matchers）</em> 来声明它们希望 收到哪种消息。匹配器为可以基于接口、对象路径和方法进行接收的消息指定一组规则（见后）。 这样就使得应用程序可以集中精力去处理它们想处理的内容，以实现消息的高效路由，并保持总线 上消息的预期数量，以使得不会因为这些消息导致所有应用程序的性能下降并变得很慢。</p>
<h4 id="消息类型"><a href="#消息类型" class="headerlink" title="消息类型"></a>消息类型</h4><p>在 D-BUS 中有四种类型的消息：方法调用（method calls）、方法返回（method returns）、信号（signals） 和错误（errors）。要执行<code>D-BUS</code>对象的方法，您需要向对象发送一个方法调用消息。它将完成一些处理并返回 一个方法返回消息或者错误消息。信号的不同之处在于它们不返回任何内容：既没有“信号返回”消息，也没有 任何类型的错误消息。</p>
<p>消息也可以有任意的参数。参数是强类型的，类型的范围是从基本的非派生类型（布尔（booleans）、 字节（bytes）、整型（integers））到高层次数据结构（字符串（strings）、数组（ arrays）和字典（dictionaries））。</p>
<p><strong>DBusBusType</strong></p>
<table>
<thead>
<tr>
<th>Name</th>
<th>Type</th>
</tr>
</thead>
<tbody><tr>
<td>DBUS_BUS_SESSION</td>
<td>登录的会话总线</td>
</tr>
<tr>
<td>DBUS_BUS_SYSTEM</td>
<td>系统范围的总线</td>
</tr>
<tr>
<td>DBUS_BUS_STARTER</td>
<td>启动的线程(如果有的话)</td>
</tr>
</tbody></table>
<p><strong>DBusHandlerResult</strong></p>
<table>
<thead>
<tr>
<th>Name</th>
<th>Result</th>
</tr>
</thead>
<tbody><tr>
<td>DBUS_HANDLER_RESULT_HANDLED</td>
<td>消息已产生效果-无需运行更多处理程序。</td>
</tr>
<tr>
<td>DBUS_HANDLER_RESULT_NOT_YET_HANDLED</td>
<td>消息没有任何效果-查看其他处理程序是否需要它。</td>
</tr>
<tr>
<td>DBUS_HANDLER_RESULT_NEED_MEMORY</td>
<td>需要更多内存才能返回<code>DBUS_HANDLER_RESULT_HANDLED</code>或<code>DBUS_HANDLER_RESULT_NOT_YET_HANDLED</code>。请稍后再尝试使用更多内存。</td>
</tr>
</tbody></table>
<p><strong>DBusError</strong></p>
<table>
<thead>
<tr>
<th>Usage</th>
<th>Meanings</th>
</tr>
</thead>
<tbody><tr>
<td>const char*    name</td>
<td>公共的error名称字段</td>
</tr>
<tr>
<td>const char*    message</td>
<td>公共的error消息字段</td>
</tr>
</tbody></table>
<hr>
<h3 id="D-bus应用"><a href="#D-bus应用" class="headerlink" title="D-bus应用"></a>D-bus应用</h3><blockquote>
<p>D-Bus文档：<a href="https://dbus.freedesktop.org/doc/api/html/group__DBus.html">D-Bus 1.13.16</a></p>
</blockquote>
<h4 id="常用D-Bus函数"><a href="#常用D-Bus函数" class="headerlink" title="常用D-Bus函数"></a>常用D-Bus函数</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">dbus_g_bus_get (DBusBusType type,</span><br><span class="line">                DBusError* error);</span><br></pre></td></tr></table></figure>
<p>   <strong>Function：</strong></p>
<p>   r给指定的总线返回一个连接，这个连接是与该函数的其他调用者共享的全局变量。</p>
<p>   <strong>Parameters：</strong></p>
<p>   <code>Type</code>：DBusBusType</p>
<p>   <code>error</code>：错误可以被返回的地址</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">dbus_g_thread_init（<span class="keyword">void</span>）;</span><br></pre></td></tr></table></figure>
<p>初始化<code>D-Bus</code>线程系统。此函数只能被调用一次，并且必须调用在<code>D-Bus</code>的API中任何其他函数之前。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">dbus_error_init()</span><br></pre></td></tr></table></figure>
<p><strong>Function：</strong></p>
<p>初始化DBusError结构。</p>
<p><strong>Parameters：</strong></p>
<p><code>error</code>：DBusError</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">dbus_error_free (&amp;error);</span><br></pre></td></tr></table></figure>
<p><strong>Function：</strong></p>
<p>释放已设置或者刚刚初始化的错误，然后像dbus_error_init()一样重新初始化该错误</p>
<p><strong>Parameters：</strong></p>
<p><code>&amp;error</code>：存储错误的内存</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">dbus_connection_setup_with_g_main (DBusConnection *connection,</span><br><span class="line">                                   GMainContext *context);</span><br></pre></td></tr></table></figure>
<p><strong>Function：</strong></p>
<p>设置DBusConnection的监视和超时功能，将连接与GLib主循环集成在一起。 </p>
<p><strong>Parameters：</strong></p>
<p><code>connection</code>：GMainContext内容，如果为NULL，将会使用默认的context；</p>
<p><code>context</code>：设置为<code>True</code>表示循环正在运行；<code>True</code>或者<code>FLASE</code>都无所谓，在调用<code>g_main_loop_run()</code>之后，该设置都会被设置为<code>True</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">dbus_message_new_signal	（	</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> * 	path，</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> * 	iface，</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> * 	name </span><br><span class="line">）	</span><br></pre></td></tr></table></figure>
<p><strong>Function：</strong></p>
<p>构造一个表示消息发射的新消息。</p>
<p>如果无法为消息分配内存，则返回NULL。</p>
<p><strong>Parameters：</strong></p>
<p><code>Path</code>：发出signal的对象路径</p>
<p><code>iface</code>：发出signal的接口</p>
<p><code>name</code>：signal的名称</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">dbus_g_proxy_new_for_name (DBusGConnection *connection,</span><br><span class="line">                           <span class="keyword">const</span> <span class="keyword">char</span> *name,</span><br><span class="line">                           <span class="keyword">const</span> <span class="keyword">char</span> *path,</span><br><span class="line">                           <span class="keyword">const</span> <span class="keyword">char</span> *iface);</span><br></pre></td></tr></table></figure>
<p>为通过消息总线上的连接导出的远程接口创建新的代理。通过该代理的方法调用和信号连接将转到名称所有者；该名称的所有者应支持给定的接口名称。<strong>所有者的名称可能会随着时间变化</strong>，例如在两个不同的方法调用之间，除非名称是唯一的名称。如果需要固定所有者，则需要请求当前所有者，并将代理绑定到其唯一名称而不是通用名称，参考 <code>dbus_g_proxy_new_for_name_owner ()</code>。</p>
<p>与名称相关的代理仅对消息总线有意义，而不适用于应用程序对应用程序的直接dbus连接。</p>
<p>仅当<code>DBusConnection</code>断开连接，该代理没有剩余引用或该名称是唯一名称并且其所有者消失时，此代理才会发出“销毁”信号。 如果一个“众所周知”的名称更改了所有者，则代理将仍然有效。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">dbus_g_proxy_new_for_name_owner（ ，DBusGConnection *connection，</span><br><span class="line">                                  ，</span><br><span class="line">                                  ，</span><br><span class="line">                                  ）;<span class="keyword">const</span> <span class="keyword">char</span> *nameconst <span class="keyword">char</span> *pathconst <span class="keyword">char</span> *ifaceGError **error</span><br></pre></td></tr></table></figure>
<p>和<code>dbus_g_proxy_new_for_name（）</code>类似，但却是想消息总线发出一个往返请求来获取当前名称所有者，然后将代理绑定到当前所有者的唯一名称，而不是<code>well-known name</code>。结果，名称所有者将不随时间改变，并且当所有者从消息总线中消失时，代理将发出“销毁”的信号。</p>
<p><strong>两者区别举例：</strong></p>
<p>如果你使用了<code>org.freedesktop.Database</code>作为一个“well-known name”，哪怕所有者更改，<code>dbus_g_proxy_new_for_name </code>依然会绑定到该名称；而<code>dbus_g_proxy_new_for_name_owner</code>则会绑定到该所有者的唯一名称，而不是通用名称。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">dbus_connection_send_with_reply	(	</span><br><span class="line">DBusConnection * 	connection,</span><br><span class="line">DBusMessage * 	message,</span><br><span class="line">DBusPendingCall ** 	pending_return,</span><br><span class="line"><span class="keyword">int</span> 	timeout_milliseconds </span><br><span class="line">)	</span><br></pre></td></tr></table></figure>
<p><strong>Function：</strong></p>
<p>对要发送的消息进行排队，与<code>dbus_connection_send（）</code>相同，但也返回一个用于接收对消息的答复的<code>DBusPendingCall</code>。<br>如果在给定的超时时间内没有收到任何回复，则此函数会使挂起的回复过期，并生成一个合成错误回复（进程中生成，而不是由远程应用程序生成），指示发生了超时。</p>
<p><strong>Parameters：</strong></p>
<p><code>connection</code>：the connection</p>
<p><code>message</code>：the message to send</p>
<p><code>pending_return</code>：返回<code>DBusPendingCall</code>对象的位置；如果连接断或者尝试在不支持Unix文件描述符的连接数发送它们，则返回NULL</p>
<p><code>timeout_milliseconds</code>:超时以毫秒为单位，-1（或<code>DBUS_timeout_USE_DEFAULT</code>），或<code>DBUS_timeout_INFINITE</code>表示无超时</p>
<h4 id="D-Bus流程"><a href="#D-Bus流程" class="headerlink" title="D-Bus流程"></a>D-Bus流程</h4><p><strong>建立服务的流程：</strong></p>
<blockquote>
<ol>
<li><p>建立一个dbus连接：<code>dbus_bus_get()</code></p>
</li>
<li><p>为这个dbus连接(DbusConnection)起名：<code>dbus_bus_request_name()</code></p>
</li>
<li><p>进入监听循环：<code>dbus_connection_read_write()</code></p>
</li>
<li><p>从总线上取出消息：<code>dbus_connection_pop_message()</code></p>
</li>
<li><p>比对消息中的接口名和方法名：<code>dbus_message_is_method_call()</code></p>
</li>
<li><p>如果比对一致，跳至相应处理，取出调用的参数+建立回传结果的通路：<code>reply_to_method_call()</code>.</p>
<p>注：回传动作本身等同于一次不需要等待结果的远程调用。</p>
</li>
</ol>
</blockquote>
<p><strong>发送信号的流程：</strong></p>
<blockquote>
<p><strong>主函数</strong></p>
<ol>
<li>建立一个dbus连接：<code>dbus_bus_get()</code></li>
<li>为这个dbus连接(<code>DbusConnection</code>)起名：<code>dbus_bus_request_name()</code></li>
<li>将总线设置为接收Glib事件循环:<code>dbus_connection_setup_with_g_main (bus, NULL)</code></li>
<li>总指针设为参数，定时调用一次<code>send()</code>函数：<code> g_timeout_add(time,send(),bus)</code></li>
<li>启动事件循环：<code>g_main_loop_run (loop)</code></li>
</ol>
<p><strong><code>send()</code>函数</strong></p>
<ol>
<li>建立一个发送信号的通道(包括信号的路径、接口名和信号名)：<code>dbus_message_new_signal()</code></li>
<li>将信号对应的相关参数压进去<ul>
<li>将参数附加到消息末尾：<code>dbus_message_iter_init_append(DBusMessage *   message, DBusMessageIter *     iter )</code></li>
<li>向消息追加基本类型值：<code>dbus_message_iter_append_basic(DBusMessageIter *  iter, int     type, const void *     value)</code></li>
<li>在给定变量参数列表的消息中追加字段：<code>dbus_message_append_args(DBusMessage *  message, int     first_arg_type, ... )</code></li>
</ul>
</li>
<li>发送信号：<code>dbus_connection_send()</code>,<code>dbus_connection_flush()</code></li>
<li>释放消息对象：<code> dbus_message_unref (message)</code></li>
<li>return TRUE;</li>
</ol>
</blockquote>
<p><strong>进行一次远程调用的流程：</strong></p>
<blockquote>
<ol>
<li>建立一个dbus连接：<code>dbus_bus_get()</code></li>
<li>为这个dbus连接(<code>DbusConnection</code>)起名：<code>dbus_bus_request_name()</code></li>
<li>申请一个远程调用通道（填入服务器名、接口名、调用名）：<code>dbus_message_new_method_call()</code></li>
<li>压入本次调用的参数：<code>dbus_message_iter_init_append()</code>、<code>dbus_message_iter_append_basic()</code>、<code>dbus_message_append_args()</code></li>
<li>启动发送调用并释放相关的消息：<code>dbus_connection_send_with_reply()</code></li>
<li>用dbus提供的函数提取参数的类型和参数：<code>dbus_message_iter_init()</code>、<code>dbus_message_iter_next()</code>、<code>dbus_message_iter_get_arg_type()</code>、<code>dbus_message_iter_get_basic()</code></li>
</ol>
</blockquote>
<p><strong>信号接收流程：</strong></p>
<blockquote>
<p><strong>main函数</strong></p>
<ol>
<li>建立一个dbus连接：<code>dbus_bus_get()</code></li>
<li>为这个dbus连接(<code>DbusConnection</code>)起名：<code>dbus_bus_request_name()</code></li>
<li>将总线设置为接收Glib事件循环:<code>dbus_connection_setup_with_g_main (bus, NULL)</code></li>
<li>为将要进行的消息循环添加匹配条件（类型和接口）：<code>dbus_bus_add_match()</code></li>
<li>设置通知函数：<code>dbus_connection_add_filter(connection,   function,   user_data,  free_data_function )</code></li>
<li>运行这个事件循环：<code>g_main_loop_run (loop)</code></li>
</ol>
<p><strong>通知函数</strong></p>
<ol>
<li>检测是否连接成功：<code>dbus_message_is_signal(message,   DBUS_INTERFACE_ORG_FREEDESKTOP_LOCAL,  &quot;Disconnected&quot;)</code></li>
<li>若连接成功，进入匹配判断：<code>dbus_message_is_signal(message,   Interface,    Name)</code></li>
<li>error初始化：<code>dbus_error_init(&amp;eror)</code></li>
<li>接收消息，并判断是否有错误：<code>dbus_message_get_args (message, &amp;error,  DBUS_TYPE_STRING, the message address(&amp;s), DBUS_TYPE_INVALID)</code></li>
<li>打印输出相应的结果：<code>g_print()</code></li>
<li>根据结果返回<code>HANDLER</code>类型：<ul>
<li>return DBUS_HANDLER_RESULT_HANDLED;</li>
<li>return DBUS_HANDLER_RESULT_NOT_YET_HANDLED;</li>
</ul>
</li>
</ol>
</blockquote>
<h4 id="D-Bus示例——通过会话总线收发信号"><a href="#D-Bus示例——通过会话总线收发信号" class="headerlink" title="D-Bus示例——通过会话总线收发信号"></a>D-Bus示例——通过会话总线收发信号</h4><ul>
<li><strong>dbus-ping-send.c</strong>：每秒通过会话总线发送一个参数为字符串“Ping!”的信号</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;glib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;dbus/dbus-glib.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">static</span> gboolean <span class="title">send_ping</span> <span class="params">(DBusConnection *bus)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  GMainLoop *loop;							<span class="comment">//定义一个事件循环对象的指针</span></span><br><span class="line">  DBusConnection *bus;						<span class="comment">//定义总线连接对象的指针</span></span><br><span class="line">  DBusError error;							<span class="comment">//定义D-Bus错误消息对象</span></span><br><span class="line">  <span class="comment">/* Create a new event loop to run in */</span></span><br><span class="line">  loop = g_main_loop_new (<span class="literal">NULL</span>, FALSE);		<span class="comment">//创建一个新的GMainLoop结构(新事件循环对象)</span></span><br><span class="line">  <span class="comment">/* Get a connection to the session bus */</span></span><br><span class="line">  dbus_error_init (&amp;error);				   <span class="comment">//初始化DBusError结构</span></span><br><span class="line">  bus = dbus_bus_get (DBUS_BUS_SESSION, &amp;error);<span class="comment">//连接到总线</span></span><br><span class="line">  <span class="keyword">if</span> (!bus) 	<span class="comment">//判断连接是否正确</span></span><br><span class="line">  &#123;	</span><br><span class="line">    g_warning (<span class="string">&quot;Failed to connect to the D-BUS daemon: %s&quot;</span>, error.message); <span class="comment">//使用Glib输出错误警告</span></span><br><span class="line">    dbus_error_free (&amp;error);				<span class="comment">//释放错误</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/* Set up this connection to work in a GLib event loop */</span></span><br><span class="line">  dbus_connection_setup_with_g_main (bus, <span class="literal">NULL</span>);	<span class="comment">//将总线设置为接收Glib事件循环</span></span><br><span class="line">  <span class="comment">/* Every second call send_ping() with the bus as an argument*/</span></span><br><span class="line">  g_timeout_add (<span class="number">1000</span>, (GSourceFunc)send_ping, bus);<span class="comment">//总线指针设为参数，隔1000ms调用一次send_ping()函数</span></span><br><span class="line">  <span class="comment">/* Start the event loop */</span></span><br><span class="line">  g_main_loop_run (loop);			<span class="comment">//启动事件循环</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> gboolean <span class="title">send_ping</span> <span class="params">(DBusConnection *bus)</span>	<span class="comment">//定义发送消息函数的细节</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  DBusMessage *message;	<span class="comment">//创建消息对象指针</span></span><br><span class="line">  <span class="comment">/* Create a new signal &quot;Ping&quot; on the &quot;com.burtonini.dbus.Signal&quot; interface,</span></span><br><span class="line"><span class="comment">   * from the object &quot;/com/burtonini/dbus/ping&quot;. */</span></span><br><span class="line">  message = dbus_message_new_signal (<span class="string">&quot;/com/burtonini/dbus/ping&quot;</span>,</span><br><span class="line">                                     <span class="string">&quot;com.burtonini.dbus.Signal&quot;</span>, <span class="string">&quot;Ping&quot;</span>); <span class="comment">//创建具有对象路径和接口的新Ping信号</span></span><br><span class="line">  <span class="comment">/* Append the string &quot;Ping!&quot; to the signal */</span></span><br><span class="line">  dbus_message_append_args (message,</span><br><span class="line">                            DBUS_TYPE_STRING, <span class="string">&quot;Ping!&quot;</span>,</span><br><span class="line">                            DBUS_TYPE_INVALID);					<span class="comment">//将字符串“Ping!”作为参数添加到信号中</span></span><br><span class="line">  <span class="comment">/* Send the signal */</span></span><br><span class="line">  dbus_connection_send (bus, message, <span class="literal">NULL</span>);				<span class="comment">//通过总线发送</span></span><br><span class="line">  <span class="comment">/* Free the signal now we have finished with it */</span></span><br><span class="line">  dbus_message_unref (message);								<span class="comment">//释放消息对象</span></span><br><span class="line">  <span class="comment">/* Tell the user we send a signal */</span></span><br><span class="line">  g_print(<span class="string">&quot;Ping!\n&quot;</span>);									<span class="comment">//标准输出打印一条消息通知用户</span></span><br><span class="line">  <span class="comment">/* Return TRUE to tell the event loop we want to be called again */</span></span><br><span class="line">  <span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>main函数</strong>：创建一个 <code>GLib</code> 事件循环，获得会话总线的一个连接， 并将<code>D-BUS</code>事件处理集成到 <code>Glib </code>事件循环之中。然后它创建了一个名为 <code>send_ping</code> 间隔为一秒的计时器，并启动事件循环。<code>send_ping</code> 构造一个来自于对象路径 /com/burtonini/dbus/ping 和接口 <code>com.burtonini.dbus.Signal</code> 的新的 Ping 信号。然后，字符串 “Ping!”作为参数添加到信号中并通过总线发送。在标准输出中会打印一条消息以让用户知道发送了 一个信号。</p>
<ul>
<li><strong>dbus-ping-listen.c</strong>：这个程序侦听<code>dbus-ping-send.c</code>正在发出的信号</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;glib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;dbus/dbus-glib.h&gt;</span></span></span><br><span class="line"><span class="keyword">static</span> DBusHandlerResult signal_filter </span><br><span class="line">      (DBusConnection *connection, DBusMessage *message, <span class="keyword">void</span> *user_data);	<span class="comment">//定义接收消息函数的原型</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  GMainLoop *loop;			<span class="comment">//定义一个事件循环对象的指针</span></span><br><span class="line">  DBusConnection *bus;		<span class="comment">//定义总线连接对象的指针</span></span><br><span class="line">  DBusError error;			<span class="comment">//定义D-Bus的错误消息对象</span></span><br><span class="line">  loop = g_main_loop_new (<span class="literal">NULL</span>, FALSE);<span class="comment">//创建新事件循环对象</span></span><br><span class="line">  dbus_error_init (&amp;error);	<span class="comment">//初始化DBusError结构</span></span><br><span class="line">  bus = dbus_bus_get (DBUS_BUS_SESSION, &amp;error);<span class="comment">//错误消息连接到总线</span></span><br><span class="line">  <span class="keyword">if</span> (!bus) &#123;				<span class="comment">//判断</span></span><br><span class="line">    g_warning (<span class="string">&quot;Failed to connect to the D-BUS daemon: %s&quot;</span>, error.message);<span class="comment">//打印错误警告</span></span><br><span class="line">    dbus_error_free (&amp;error);<span class="comment">//释放错误</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  dbus_connection_setup_with_g_main (bus, <span class="literal">NULL</span>);	<span class="comment">//将总线设为接收Glib事件循环</span></span><br><span class="line">  <span class="comment">/* listening to messages from all objects as no path is specified */</span></span><br><span class="line">  dbus_bus_add_match (bus, <span class="string">&quot;type=&#x27;signal&#x27;,interface=&#x27;com.burtonini.dbus.Signal&#x27;&quot;</span>);	<span class="comment">//定义匹配规则的接口和类型</span></span><br><span class="line">  dbus_connection_add_filter (bus, signal_filter, loop, <span class="literal">NULL</span>);	<span class="comment">//将 signal_filter设置为通知函数</span></span><br><span class="line">  g_main_loop_run (loop);		<span class="comment">//运行这个循环</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">static</span> DBusHandlerResult</span><br><span class="line">signal_filter (DBusConnection *connection, DBusMessage *message, <span class="keyword">void</span> *user_data)<span class="comment">//定义消息函数的细节</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">/* User data is the event loop we are running in */</span></span><br><span class="line">  GMainLoop *loop = user_data;		<span class="comment">//定义事件循环对象的指针，user_data与主函数中运行的事件循环</span></span><br><span class="line">  <span class="comment">/* A signal from the bus saying we are about to be disconnected */</span></span><br><span class="line">  <span class="keyword">if</span> (dbus_message_is_signal 		</span><br><span class="line">        (message, DBUS_INTERFACE_ORG_FREEDESKTOP_LOCAL, <span class="string">&quot;Disconnected&quot;</span>)) <span class="comment">//检测是否连接成功</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">/* Tell the main loop to quit */</span></span><br><span class="line">    g_main_loop_quit (loop);			<span class="comment">//连接失败则退出主循环</span></span><br><span class="line">    <span class="comment">/* We have handled this message, don&#x27;t pass it on */</span></span><br><span class="line">    <span class="keyword">return</span> DBUS_HANDLER_RESULT_HANDLED;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/* A Ping signal on the com.burtonini.dbus.Signal interface */</span></span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (dbus_message_is_signal (message, <span class="string">&quot;com.burtonini.dbus.Signal&quot;</span>, <span class="string">&quot;Ping&quot;</span>)) <span class="comment">//检测消息是否满足匹配规则</span></span><br><span class="line">  &#123;</span><br><span class="line">    DBusError error;	<span class="comment">//定义错误类型，详见消息类型</span></span><br><span class="line">    <span class="keyword">char</span> *s;</span><br><span class="line">    dbus_error_init (&amp;error);</span><br><span class="line">    <span class="keyword">if</span> (dbus_message_get_args </span><br><span class="line">       (message, &amp;error, DBUS_TYPE_STRING, &amp;s, DBUS_TYPE_INVALID)) <span class="comment">//接收消息，并判断是否有错误</span></span><br><span class="line">    &#123;</span><br><span class="line">      g_print(<span class="string">&quot;Ping received: %s\n&quot;</span>, s);	<span class="comment">//无误打印输出接收到的消息</span></span><br><span class="line">      dbus_free (s);						<span class="comment">//释放指针</span></span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">    &#123;</span><br><span class="line">      g_print(<span class="string">&quot;Ping received, but error getting message: %s\n&quot;</span>, error.message);<span class="comment">//消息已收到，打印错误信息</span></span><br><span class="line">      dbus_error_free (&amp;error);			<span class="comment">//释放错误</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> DBUS_HANDLER_RESULT_HANDLED;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> DBUS_HANDLER_RESULT_NOT_YET_HANDLED;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个程序侦听 dbus-ping-send.c 正在发出的信号。 <code>main</code> 函数 和前面一样启动，创建一个到总线的连接。然后它声明愿意当具有 <code>com.burtonini.dbus.Signal</code> 接口的信号被发送时得到通知，将 <code>signal_filter</code> 设置为通知函数， 然后进入事件循环。</p>
<p>当满足匹配的消息被发送时， <code>signal_func</code> 会被调用。不过，它也将会 收到来自总线本身的总线管理信号。要确定接收到消息时应该做些什么，仅仅需要检验消息头。如果消息是 总线断开信号，则事件循环终止，因为侦听一个不存在的总线是没有意义的。（告知总线信号已经处理）。 然后，将到来的消息与期望的消息相比较，如果成功，则解出参数并输出。如果到来的消息不是其中的任何一个， 则告知总线没有处理那个消息。</p>
]]></content>
      <categories>
        <category>通信</category>
      </categories>
      <tags>
        <tag>嵌入式</tag>
        <tag>通信</tag>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>远程升级实现——STM32+IAP</title>
    <url>/2020/10/08/STM32+IAP/</url>
    <content><![CDATA[<blockquote>
<p>开发工具： Keil 5<br>开发芯片：   STM32F103RCT6<br>文档编写工具： Markdown</p>
</blockquote>
<p>因为只有一个JTAG的下载器，所以在调试程序的时候想用IAP实现远程修改/升级程序.</p>
<a id="more"></a>

<h4 id="1-IAP的基础知识"><a href="#1-IAP的基础知识" class="headerlink" title="1    IAP的基础知识"></a>1    IAP的基础知识</h4><h5 id="1-1-STM32的编程方式"><a href="#1-1-STM32的编程方式" class="headerlink" title="1.1 STM32的编程方式"></a>1.1 STM32的编程方式</h5><ul>
<li><strong>ISP</strong>：In System Programming （在系统中编程），通过<strong>芯片专用的串行编程接口</strong>对其内部的程序存储器进行擦写。</li>
<li><strong>IAP</strong>：In Application Programming（ 在应用中编程)，通过调用特定的<strong>bootloader</strong>程序，对程序存储器的指定段进行读/写操作，从而实现对目标板的程序的修改。</li>
</ul>
<p>ISP即我们平时所用的JLINK之类的下载器通过专门的接口来下载程序，IAP是通过调用Bootloader来充当下载器的功能实现更新程序的作用。</p>
<h5 id="1-2-Bootloader"><a href="#1-2-Bootloader" class="headerlink" title="1.2 Bootloader"></a>1.2 Bootloader</h5><p><strong>一般程序下载方式：</strong></p>
<img src="/upload_image/20190316201052794.png" alt="img" style="zoom: 67%;" />

<p>STM32的内部内存(FLASH)地址起始于0x08000000，一般程序由此地址写入，0x08000004开始存放中断向量表。当中断开始时，STM32的内部硬件机制会将PC指针定位到“中断向量表”处，并根据中断源取出对应的中断向量执行中断服务程序。</p>
<ol>
<li>STM32复位之后，从0x08000004地址取出复位中断向量的地址，并跳转到复位中断服务程序。</li>
<li>在复位中断服务程序执行完之后，跳转至main函数。main函数执行过程中，如果收到中断请求，STM32将PC指针重新拨回中断向量表处。</li>
<li>根据中断源进入相应的中断服务程序。</li>
<li>在执行完中断服务程序之后，程序再次返回main函数中执行。</li>
</ol>
<p><strong>IAP下程序的运行流程：</strong></p>
<img src="/upload_image/20190316201209186.png" alt="img" style="zoom:67%;" />

<ol>
<li>STM32复位之后，从0x08000004地址取出复位中断向量的地址，并跳转到复位中断服务程序，在运行完复位中断服务程序之后跳转到IAP的main函数；</li>
<li>在执行完IAP以后，跳转至新写入程序的复位向量表，取出新程序的复位中断向量表的地址，并跳转执行新程序的复位中断服务程序，随后跳转至新程序的main函数，上图中②和③；</li>
<li>在main函数执行过程中，如果CPU得到一个中断请求,PC指针仍强制跳转到地址0x08000004中断向量表处，而不是新程序的中断向量表；</li>
<li>程序根据设置的中断向量表偏移量，跳转到对应中断源新的中断服务程序中；</li>
<li>在执行完中断服务程序后，程序返回main函数继续运行。</li>
</ol>
<hr>
<h4 id="2-IAP的实现"><a href="#2-IAP的实现" class="headerlink" title="2    IAP的实现"></a>2    IAP的实现</h4><h5 id="2-1-Keil设置"><a href="#2-1-Keil设置" class="headerlink" title="2.1 Keil设置"></a>2.1 Keil设置</h5><p>keil中需要准备两个工程，一个是IAP，一个是APP。Bootloader通过ISP方式下载到Flash中，APP则是通过串口将编译生成的bin文件发送下载。</p>
<p>使用的STM32型号为STM32F103RCT6，参数如下表所示：</p>
<table>
<thead>
<tr>
<th>基本参数</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>名称</td>
<td>STM32F103RCT6</td>
</tr>
<tr>
<td>架构</td>
<td>ARM Cortex-M3</td>
</tr>
<tr>
<td>Flash容量</td>
<td>256KB</td>
</tr>
<tr>
<td>RAM容量</td>
<td>48K</td>
</tr>
</tbody></table>
<p>两个工程将Flash分成两个区域，Bootloader存储的起始地址为0x08000000，分配大小这里设置为0x2000字节；用户APP信息存储从0x08002000处开始，分配空间大小为(0x08040000-0x08002000=0x803E000)。<strong>IAP工程文件中使用keil默认设置即可</strong>，APP工程中的设置如下图所示。</p>
<p><img src="/upload_image/image-20201010133907154.png" alt="image-20201010133907154" style="zoom:42%;" /><img src="/upload_image/image-20201010133813256.png" alt="image-20201010133813256" style="zoom: 32%;" /></p>
<img src="/upload_image/image-20201010165809674.png" alt="image-20201010165809674" style="zoom: 67%;" />

<img src="/upload_image/image-20201010171514423.png" alt="image-20201010171514423" style="zoom:67%;" />

<h5 id="2-2-驱动程序"><a href="#2-2-驱动程序" class="headerlink" title="2.2 驱动程序"></a>2.2 驱动程序</h5><p><strong>串口接收：</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//串口接收缓冲区</span></span><br><span class="line">u8 serial_Buffer[SERIAL_MAX_LENGTH] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="comment">//串口接收数据长度</span></span><br><span class="line">u16 serial_Buffer_Length = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">u8 receiveMode = <span class="number">0</span>;<span class="comment">//接收参数的中断处理模型,为0的时候是命令模式,为1的时候为下载模式</span></span><br><span class="line">u8 receiveExpectCount = <span class="number">0</span>;<span class="comment">//串口期望接收长度</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//串口中断处理</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">SerialRecv</span><span class="params">(u8 ch)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(receiveMode == <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>((serial_Buffer_Length&amp;<span class="number">0x8000</span>) == <span class="number">0x8000</span>)<span class="comment">//已经接收完成,系统还没处理</span></span><br><span class="line">		&#123;</span><br><span class="line">			serial_Buffer_Length |= <span class="number">0x8000</span>;<span class="comment">//退出</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>((serial_Buffer_Length&amp;<span class="number">0x4000</span>) == <span class="number">0x4000</span>)<span class="comment">//接收到回车还没接收到换行</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(ch == <span class="string">&#x27;\n&#x27;</span>)serial_Buffer_Length |= <span class="number">0x8000</span>;</span><br><span class="line">			<span class="keyword">else</span> </span><br><span class="line">			&#123;</span><br><span class="line">				<span class="comment">//一帧接受失败</span></span><br><span class="line">				serial_Buffer_Length = <span class="number">0</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>((serial_Buffer_Length&amp;<span class="number">0xff</span>) &lt; SERIAL_MAX_LENGTH)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">if</span>(ch == <span class="string">&#x27;\r&#x27;</span>)serial_Buffer_Length |= <span class="number">0x4000</span>;</span><br><span class="line">				<span class="keyword">else</span> </span><br><span class="line">				&#123;</span><br><span class="line">					serial_Buffer[(serial_Buffer_Length&amp;<span class="number">0xff</span>)] = ch;</span><br><span class="line">					serial_Buffer_Length++;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">			&#123;</span><br><span class="line">				<span class="comment">//一帧接受失败</span></span><br><span class="line">				serial_Buffer_Length = <span class="number">0</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//下载模式,只控制字符串的量,数据的第一位是该数据包的长度,接收到这么多长度,接收完成位置一</span></span><br><span class="line">		<span class="comment">//注意,在这种模式下,清除serial_Buffer_Length之前应当清除receiveExpectCount的值</span></span><br><span class="line">		<span class="keyword">if</span>(receiveExpectCount == <span class="number">0</span>)<span class="comment">//期望下载为0,第一个数就是期望下载数</span></span><br><span class="line">		&#123;</span><br><span class="line">			receiveExpectCount = ch;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>((serial_Buffer_Length&amp;<span class="number">0x8000</span>) == <span class="number">0x8000</span>)<span class="comment">//已经接收完成,系统还没处理,此时不接收数据</span></span><br><span class="line">			&#123;</span><br><span class="line">				serial_Buffer_Length |= <span class="number">0x8000</span>;<span class="comment">//退出</span></span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">			&#123;</span><br><span class="line">				serial_Buffer[(serial_Buffer_Length&amp;<span class="number">0xff</span>)] = ch;<span class="comment">//接收数据并保存</span></span><br><span class="line">				serial_Buffer_Length++;</span><br><span class="line">				<span class="keyword">if</span>((serial_Buffer_Length&amp;<span class="number">0xff</span>) == receiveExpectCount)<span class="comment">//接收到了期望长度的数据</span></span><br><span class="line">				&#123;</span><br><span class="line">					serial_Buffer_Length |= <span class="number">0x8000</span>;<span class="comment">//一包接收完成标志</span></span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">USART1_IRQHandler</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	u8 ch = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span>(USART_GetITStatus(USART1, USART_IT_RXNE) == SET)<span class="comment">//检查中断发生</span></span><br><span class="line">	&#123;</span><br><span class="line">		ch = (u8)USART_ReceiveData(USART1);</span><br><span class="line">		USART_ClearITPendingBit(USART1, USART_IT_RXNE);	<span class="comment">//清除中断</span></span><br><span class="line"><span class="comment">//		Debug_Serial_Send_Char(ch);				//将收到的数据发送出去</span></span><br><span class="line">		SerialRecv(ch);							<span class="comment">//处理中断数据</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>IAP程序</strong></p>
<p>IAP程序包括iap_down（下载程序，片机接收来自于上位机的数据），iap_jump_app（IAP跳转到APP的跳转指令），iap_over（指示IAP完成，将系统缓冲区清空），iap_set_flag（检测到该标志时跳转到APP程序中），iap_clear_flag（清除APP标志，让IAP不再自动跳转到APP中），app_jump_iap（app跳转到iap的跳转指令）。</p>
<p>​    <strong>IAP_set_flag</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//设置app固化配置</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">iap_set_flag</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Test_Write(APP_CONFIG_ADDR,APP_CONFIG_SET_VALUE);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;固化成功\r\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//WriteAddr:起始地址</span></span><br><span class="line"><span class="comment">//WriteData:要写入的数据</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Test_Write</span><span class="params">(u32 WriteAddr,u16 WriteData)</span>   	</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    STMFLASH_Write(WriteAddr,&amp;WriteData,<span class="number">1</span>);<span class="comment">//写入一个字 </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在keil中我们设置0x08000000-0x08003000来存放iap代码，并将0x08001FFC作为存放app固化标志的地方，在宏定义中设置各个变量的地址：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> APP_CONFIG_ADDR     0X08001FFC <span class="comment">//配置地址</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> APP_CONFIG_SET_VALUE    0X5555 <span class="comment">//设置值</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> APP_CONFIG_CLEAR_VALUE  0XFFFF <span class="comment">//清零值</span></span></span><br></pre></td></tr></table></figure>
<p>​    <strong>iap_claer_flag</strong></p>
<p>清除标志的方式与写入标志的方式同理，在 APP_CONFIG_ADDR 这个地址写入清零值。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//清除app固化配置</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">iap_clear_flag</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Test_Write(APP_CONFIG_ADDR,APP_CONFIG_CLEAR_VALUE);</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;清除成功\r\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​    <strong>iap_jump_app</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">typedef</span>  <span class="title">void</span> <span class="params">(*iapfun)</span><span class="params">(<span class="keyword">void</span>)</span></span>;				<span class="comment">//定义一个函数类型的参数.</span></span><br><span class="line">iapfun jump2app;</span><br><span class="line"></span><br><span class="line"><span class="comment">//设置栈顶地址</span></span><br><span class="line"><span class="comment">//addr:栈顶地址</span></span><br><span class="line"></span><br><span class="line"><span class="function">__asm <span class="keyword">void</span> <span class="title">MSR_MSP</span><span class="params">(u32 addr)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    MSR MSP, r0 			<span class="comment">//set Main Stack value</span></span><br><span class="line">    BX r14</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//跳转到app区域运行</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">iap_jump_app</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	iap_load_app(FLASH_APP1_ADDR);<span class="comment">//跳转到app的复位向量地址</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//跳转到应用程序段</span></span><br><span class="line"><span class="comment">//appxaddr:用户代码起始地址.</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">iap_load_app</span><span class="params">(u32 appxaddr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(((*(vu32*)appxaddr)&amp;<span class="number">0x2FFE0000</span>)==<span class="number">0x20000000</span>)	<span class="comment">//检查栈顶地址是否合法.0x20000000是sram的起始地址,也是程序的栈顶地址</span></span><br><span class="line">	&#123; </span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;ok\r\n&quot;</span>);</span><br><span class="line">		Delay_Ms(<span class="number">10</span>);</span><br><span class="line">		jump2app=(iapfun)*(vu32*)(appxaddr+<span class="number">4</span>);		<span class="comment">//用户代码区第二个字为程序开始地址(复位地址)		</span></span><br><span class="line">		MSR_MSP(*(vu32*)appxaddr);					<span class="comment">//初始化APP堆栈指针(用户代码区的第一个字用于存放栈顶地址)</span></span><br><span class="line">		jump2app();									<span class="comment">//跳转到APP.</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;program in flash is error\r\n&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​    <strong>程序解释：</strong></p>
<ol>
<li><p>检查栈顶地址</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(((*(vu32*)appxaddr)&amp;<span class="number">0x2FFE0000</span>)==<span class="number">0x20000000</span>)</span><br></pre></td></tr></table></figure>
<p>在实际的程序中，设置APP的起始地址为0x08003000，即appxaddr==0x08003000，而 *(vu32 *)appxaddr即取0x08003000-0x08003003这4个字节的值，因为APP中设置中断向量表放置在0x08003000开始的位置，中断向量表中第一个放的则是栈顶地址的值。通过判断栈顶地址值是否正确（是否在0x2000 0000 - 0x 2000 2000之间） 来判断是否应用程序已经下载了，因为应用程序的启动文件会初始化化栈空间，如果栈顶值对了，说明启动文件的初始化执行了应用程也已经下载了。</p>
</li>
<li><p>程序开始地址</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">jump2app=(iapfun)*(vu32*)(appxaddr+<span class="number">4</span>);		<span class="comment">//用户代码区第二个字为程序开始地址(复位地址)		</span></span><br></pre></td></tr></table></figure>
<p> (appxaddr+4)即0x08003004，这个地址放的时中断向量表的第二项“复位地址”</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">typedef</span>  <span class="title">void</span> <span class="params">(*iapfun)</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br></pre></td></tr></table></figure>
<p>一般，typedef int a，是给整型定义一个别名 a ；而 void (* iapfun)(void) 是声明一个函数指针，加上 typedef 之后 iapfun 只不过是类型 void(*)void 的一个别名。所以，此时的jump2app已经指向了复位函数所在的地址 <strong>Reset_Handler</strong>(中断向量表的第二项)，跳转到main函数。下图为STM32启动文件 startup_stm32f10x_hd.s 中的代码解释：</p>
<p>​        <img src="/upload_image/image-20201012144259212.png" alt="image-20201012144259212" style="zoom: 67%;" /></p>
<blockquote>
<p><em>ST</em>公司都提供了现成的直接可用的启动文件，程序开发人员可以直接引用启动文件后直接进行<em>C</em>应用程序的开发。这样能大大减小开发人员从其它微控制器平台跳转至<em>STM32</em>平台，也降低了适应<em>STM32</em>微控制器的难度。相对于<em>ARM</em>上一代的主流<em>ARM7/ARM9</em>内核架构，新一代<em>Cortex</em>内核架构的启动方式有了比较大的变化。<em>ARM7/ARM9</em>内核的控制器在复位后，<em>CPU</em>会从存储空间的绝对地址<em>0x000000</em>取出第一条指令执行复位中断服务程序的方式启动，即固定了复位后的起始地址为<em>0x000000</em>（<em>PC = 0x000000</em>）同时中断向量表的位置并不是固定的。而<em>Cortex-M3</em>内核则正好相反，有<em>3</em>种情况*:<br>1<em>、 通过</em>boot<em>引脚设置可以将中断向量表定位于</em>SRAM<em>区，即起始地址为</em>0x2000000<em>，同时复位后</em>PC<em>指针位于</em>0x2000000<em>处；<br>2、 通过</em>boot<em>引脚设置可以将中断向量表定位于</em>FLASH<em>区，即起始地址为 <em>0x8000000</em>，同时复位后</em>PC<em>指针位于</em>0x8000000<em>处；<br>3、 通过</em>boot<em>引脚设置可以将中断向量表定位于内置</em>Bootloader<em>区，本文不对这种情况做论述；<br>而Cortex-M3内核规定，<strong>起始地址必须存放堆顶指针</strong>，而<strong>第二个地址则必须存放复位中断入口向量地址</strong>，这样在</em>Cortex-M3<em>内核复位后，会自动从起始地址的下一个</em>32*位空间取出复位中断入口向量，跳转执行复位中断服务程序。</p>
<p><a href="https://blog.csdn.net/yx_l128125/article/details/12992773">STM32 IAP 在线升级详解——CSDN</a></p>
<p><a href="https://blog.csdn.net/weixin_39780116/article/details/88605971?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-4.channel_param&depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-4.channel_param">关于Stm32的IAP详细和应用——CSDN</a></p>
</blockquote>
</li>
</ol>
<p>​    <strong>app_jump_iap</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">app_jump_iap</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	SCB-&gt;VTOR = FLASH_BASE;		<span class="comment">//设置中断向量偏移量</span></span><br><span class="line">	NVIC_SystemReset();			<span class="comment">//复位函数，软件重启</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​    其中，NVIC_SystemReset()这个函数在新版的STM32的官方固件库文件 <strong>core_cm3.h</strong> 中1720行处：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* ##################################    Reset function  ############################################ */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief  Initiate a system reset request.</span></span><br><span class="line"><span class="comment"> *	   系统复位</span></span><br><span class="line"><span class="comment"> * Initiate a system reset request to reset the MCU</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> __INLINE <span class="keyword">void</span> <span class="title">NVIC_SystemReset</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  SCB-&gt;AIRCR  = ((<span class="number">0x5FA</span> &lt;&lt; SCB_AIRCR_VECTKEY_Pos)      | </span><br><span class="line">                 (SCB-&gt;AIRCR &amp; SCB_AIRCR_PRIGROUP_Msk) | </span><br><span class="line">                 SCB_AIRCR_SYSRESETREQ_Msk);                   <span class="comment">/* Keep priority group unchanged */</span>		 <span class="comment">/*保持优先级组不变*/</span></span><br><span class="line">  __DSB();                                                     <span class="comment">/* Ensure completion of memory access */</span>   <span class="comment">/*确保完成内存访问*/</span>           </span><br><span class="line">  <span class="keyword">while</span>(<span class="number">1</span>);                                                    <span class="comment">/* wait until reset */</span>					<span class="comment">/*等待重启*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​    <em>如果使用的是正点原子的老教程，版本文件老旧 core_cm3.h文件可能没有更新，则没有这个函数</em></p>
<p>​    iap和app之间的跳转必须关闭所有中断 ，并且复位NVIC中断寄存器的值，因为跳转函数是用程序指针完成的，但跳转只是强制改变了PC指针的位置，NVIC寄存器的值还是保持着原来main的值，所以一旦发生中断就会指向跳转前的main函数的中断函数入口地址，<strong>程序会卡死</strong>导致 <strong>HardFault</strong>。所以最好的方法是使用上述的软件重启的思路，其余的处理方式还有：①跳转之前复位或者关闭所有打开的中断②跳转后在初始化时加入RCC_DeInit();NVIC_DeInit ();等让中断恢复默认值。</p>
<p>​    <strong>iap_down_s</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FLASH_APP1_ADDR		0x08002000  	<span class="comment">//第一个应用程序起始地址(存放在FLASH)</span></span></span><br><span class="line">											<span class="comment">//保留的空间为IAP使用</span></span><br><span class="line"></span><br><span class="line">u16 iapbuf[<span class="number">1024</span>] = &#123;<span class="number">0</span>&#125;; <span class="comment">//用于缓存数据的数组</span></span><br><span class="line">u16 receiveDataCur = <span class="number">0</span>;	<span class="comment">//当前iapbuffer中已经填充的数据长度,一次填充满了之后写入flash并清零</span></span><br><span class="line">u32 addrCur = FLASH_APP1_ADDR;			<span class="comment">//当前系统写入地址,每次写入之后地址增加2048</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//开始下载</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">iap_down_s</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	u16 i = <span class="number">0</span>;</span><br><span class="line">	u16 temp = <span class="number">0</span>;</span><br><span class="line">	u16 receiveCount;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;begin,wait data download\r\n&quot;</span>);</span><br><span class="line">	receiveMode = <span class="number">1</span>;<span class="comment">//串口进入下载接收数据模式</span></span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//循环接收数据,每次必须要发128个数据下来,如果没有128,说明这是最后一包数据</span></span><br><span class="line">		<span class="comment">//接收到一包数据之后,返回一个小数点,发送完成,系统编程完成之后返回一个iap_over</span></span><br><span class="line">		<span class="keyword">if</span>(serial_Buffer_Length &amp; <span class="number">0x8000</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			receiveCount = (u8)(serial_Buffer_Length&amp;<span class="number">0x00ff</span>);</span><br><span class="line">			<span class="keyword">if</span>(receiveCount == <span class="number">128</span>)<span class="comment">//满足一包,填充并查看是否有了1024字节,有了写入闪存</span></span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; receiveCount; i+=<span class="number">2</span>)</span><br><span class="line">				&#123;</span><br><span class="line">					<span class="comment">//数据八位融合为16位</span></span><br><span class="line">					temp = (((u16)serial_Buffer[i+<span class="number">1</span>])&lt;&lt;<span class="number">8</span>) + ((u16)serial_Buffer[i]);</span><br><span class="line">					iapbuf[receiveDataCur] = temp;</span><br><span class="line">					receiveDataCur++;<span class="comment">//完成之后receiveDataCur++;</span></span><br><span class="line">				&#125;</span><br><span class="line">				receiveExpectCount = <span class="number">0</span>;<span class="comment">//清除期望接收模式</span></span><br><span class="line">				serial_Buffer_Length = <span class="number">0</span>;<span class="comment">//清除串口满标志</span></span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">&quot;.&quot;</span>);<span class="comment">//每次接受一次数据打一个点 </span></span><br><span class="line">				<span class="comment">//此时需要检测receiveDataCur的值,要是放满了,就需要写入</span></span><br><span class="line">				<span class="keyword">if</span>(receiveDataCur == <span class="number">1024</span>)</span><br><span class="line">				&#123;</span><br><span class="line">					<span class="comment">//写入flash中</span></span><br><span class="line">					STMFLASH_Write(addrCur,iapbuf,<span class="number">1024</span>);</span><br><span class="line">					<span class="comment">//printf(&quot;\r\nwrite addr %x,length 1024\r\n&quot;,addrCur);</span></span><br><span class="line">					addrCur += <span class="number">2048</span>;<span class="comment">//地址+2048</span></span><br><span class="line">					<span class="comment">//写完之后receiveDataCur要清零等待下一次传输</span></span><br><span class="line">					receiveDataCur = <span class="number">0</span>;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">else</span> <span class="comment">//有可能最后一包有128个数据但是最终没有2048个数据,此时扩展一个指令用于完成最后一个的写入</span></span><br><span class="line">				&#123;</span><br><span class="line">					</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="comment">//还没放满,等待下一次数据过来</span></span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span>	<span class="comment">//不满足一包,说明数据传送这是最后一包,写入闪存</span></span><br><span class="line">			&#123;</span><br><span class="line">				<span class="comment">//没有一包也要传送到缓存中</span></span><br><span class="line">				<span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; receiveCount; i+=<span class="number">2</span>)</span><br><span class="line">				&#123;</span><br><span class="line">					</span><br><span class="line">					<span class="comment">//数据八位融合为16位</span></span><br><span class="line">					temp = (((u16)serial_Buffer[i+<span class="number">1</span>])&lt;&lt;<span class="number">8</span>) + ((u16)serial_Buffer[i]);</span><br><span class="line">					iapbuf[receiveDataCur] = temp;</span><br><span class="line">					receiveDataCur++;<span class="comment">//完成之后receiveDataCur++;</span></span><br><span class="line">					</span><br><span class="line">				&#125;</span><br><span class="line">				receiveExpectCount = <span class="number">0</span>;<span class="comment">//清除期望接收模式</span></span><br><span class="line">				serial_Buffer_Length = <span class="number">0</span>;<span class="comment">//清除串口满标志</span></span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">&quot;.&quot;</span>);<span class="comment">//每次接受一次数据打一个点 </span></span><br><span class="line">				<span class="comment">//之后就要将这数据写入到闪存中</span></span><br><span class="line">				STMFLASH_Write(addrCur,iapbuf,receiveDataCur);<span class="comment">//将最后的一些内容字节写进去.</span></span><br><span class="line">				<span class="comment">//printf(&quot;\r\nwrite addr %x,length %d\r\n&quot;,addrCur,receiveDataCur);</span></span><br><span class="line">				<span class="comment">//写完之后要把地址恢复到原来的位置</span></span><br><span class="line">				addrCur = FLASH_APP1_ADDR;</span><br><span class="line">				receiveDataCur = <span class="number">0</span>;</span><br><span class="line">				<span class="comment">//写完之后要退出下载循环并告诉上位机,已经下载完了</span></span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">&quot;download over\r\n&quot;</span>);</span><br><span class="line">				<span class="comment">//同时,也要退出下载循环模式</span></span><br><span class="line">				receiveMode = <span class="number">0</span>;</span><br><span class="line">				<span class="keyword">return</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码的核心思想是上位机每次发送128个数据，128个8位数据通过位操作两两融合成16位数据，每个新数据占2个地址，写满2048个addr后写一次flash；当最后一包数据不是128时说明数据发送完成了，将最后的数据烧入flash之后把地址恢复到原来位置<em>addrCur = FLASH_APP1_ADDR</em>，退出下载模式 <strong>receiveMode</strong>从1置为0；可能会出现的情况在于最后一包的数据也是128个，此时iap_down_s的判断机制仍处于下载模式，针对这种情况定义一个新指令iap_over，上位机侦测到最后一包数据也是128个时补充发送该命令，下位机将缓存写入并退出。</p>
<p>​    <strong>iap_over_s</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//最后一包有128个数据但是最终没有2048个数据</span></span><br><span class="line"><span class="comment">//收到这个指令检测receiveDataCur和addrCur的值,</span></span><br><span class="line"><span class="comment">//完成最后的写入</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">iap_over_s</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//这个时候,依然在串口下载模式</span></span><br><span class="line">	<span class="keyword">if</span>(receiveDataCur != <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		STMFLASH_Write(addrCur,iapbuf,receiveDataCur);<span class="comment">//将最后的一些内容字节写进去.</span></span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;write addr %x,length %d&quot;</span>,addrCur,receiveDataCur);</span><br><span class="line">		addrCur = FLASH_APP1_ADDR;</span><br><span class="line">		receiveDataCur = <span class="number">0</span>;</span><br><span class="line">		<span class="comment">//同时,也要退出下载模式</span></span><br><span class="line">		receiveMode = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;最后一包发送完成\r\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>Flash擦写</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//读取指定地址的半字(16位数据)</span></span><br><span class="line"><span class="comment">//faddr:读地址(此地址必须为2的倍数!!)</span></span><br><span class="line"><span class="comment">//返回值:对应数据.</span></span><br><span class="line"><span class="function">u16 <span class="title">STMFLASH_ReadHalfWord</span><span class="params">(u32 faddr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> *(vu16*)faddr; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> STM32_FLASH_WREN	<span class="comment">//如果使能了写   </span></span></span><br><span class="line"><span class="comment">//不检查的写入</span></span><br><span class="line"><span class="comment">//WriteAddr:起始地址</span></span><br><span class="line"><span class="comment">//pBuffer:数据指针</span></span><br><span class="line"><span class="comment">//NumToWrite:半字(16位)数   </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">STMFLASH_Write_NoCheck</span><span class="params">(u32 WriteAddr,u16 *pBuffer,u16 NumToWrite)</span>   </span></span><br><span class="line"><span class="function"></span>&#123; 			 		 </span><br><span class="line">    u16 i;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;NumToWrite;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        FLASH_ProgramHalfWord(WriteAddr,pBuffer[i]);</span><br><span class="line">        WriteAddr+=<span class="number">2</span>;<span class="comment">//地址增加2.</span></span><br><span class="line">    &#125;  </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">//从指定地址开始写入指定长度的数据</span></span><br><span class="line"><span class="comment">//WriteAddr:起始地址(此地址必须为2的倍数!!)</span></span><br><span class="line"><span class="comment">//pBuffer:数据指针</span></span><br><span class="line"><span class="comment">//NumToWrite:半字(16位)数(就是要写入的16位数据的个数.)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> STM32_FLASH_SIZE&lt;256</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> STM_SECTOR_SIZE 1024 <span class="comment">//字节</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span> </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> STM_SECTOR_SIZE	2048</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span>	</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">u16 STMFLASH_BUF[STM_SECTOR_SIZE/<span class="number">2</span>];<span class="comment">//最多是2K字节</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">STMFLASH_Write</span><span class="params">(u32 WriteAddr,u16 *pBuffer,u16 NumToWrite)</span>	</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    u32 secpos;	   <span class="comment">//扇区地址</span></span><br><span class="line">    u16 secoff;	   <span class="comment">//扇区内偏移地址(16位字计算)</span></span><br><span class="line">    u16 secremain; <span class="comment">//扇区内剩余地址(16位字计算)	   </span></span><br><span class="line">    u16 i;    </span><br><span class="line">    u32 offaddr;   <span class="comment">//去掉0X08000000后的地址</span></span><br><span class="line">    <span class="keyword">if</span>(WriteAddr&lt;STM32_FLASH_BASE||(WriteAddr&gt;=(STM32_FLASH_BASE+<span class="number">1024</span>*STM32_FLASH_SIZE)))<span class="keyword">return</span>;<span class="comment">//非法地址</span></span><br><span class="line">    FLASH_Unlock();						<span class="comment">//解锁</span></span><br><span class="line">    offaddr=WriteAddr-STM32_FLASH_BASE;		 <span class="comment">//实际偏移地址.</span></span><br><span class="line">    secpos=offaddr/STM_SECTOR_SIZE;				<span class="comment">//扇区地址  0~127 for STM32F103RBT6</span></span><br><span class="line">    secoff=(offaddr%STM_SECTOR_SIZE)/<span class="number">2</span>;		<span class="comment">//在扇区内的偏移(2个字节为基本单位.)</span></span><br><span class="line">    secremain=STM_SECTOR_SIZE/<span class="number">2</span>-secoff;		<span class="comment">//扇区剩余空间大小   </span></span><br><span class="line">    <span class="keyword">if</span>(NumToWrite&lt;=secremain)secremain=NumToWrite;<span class="comment">//不大于该扇区范围</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) </span><br><span class="line">    &#123;	</span><br><span class="line">        STMFLASH_Read(secpos*STM_SECTOR_SIZE+STM32_FLASH_BASE,STMFLASH_BUF,STM_SECTOR_SIZE/<span class="number">2</span>);<span class="comment">//读出整个扇区的内容</span></span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;secremain;i++)<span class="comment">//校验数据</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(STMFLASH_BUF[secoff+i]!=<span class="number">0XFFFF</span>)<span class="keyword">break</span>;<span class="comment">//需要擦除  	  </span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(i&lt;secremain)<span class="comment">//需要擦除</span></span><br><span class="line">        &#123;</span><br><span class="line">            FLASH_ErasePage(secpos*STM_SECTOR_SIZE+STM32_FLASH_BASE);<span class="comment">//擦除这个扇区</span></span><br><span class="line">            <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;secremain;i++)<span class="comment">//复制</span></span><br><span class="line">            &#123;</span><br><span class="line">                STMFLASH_BUF[i+secoff]=pBuffer[i];	  </span><br><span class="line">            &#125;</span><br><span class="line">            STMFLASH_Write_NoCheck(secpos*STM_SECTOR_SIZE+STM32_FLASH_BASE,STMFLASH_BUF,STM_SECTOR_SIZE/<span class="number">2</span>);<span class="comment">//写入整个扇区  </span></span><br><span class="line">        &#125;<span class="keyword">else</span> STMFLASH_Write_NoCheck(WriteAddr,pBuffer,secremain);<span class="comment">//写已经擦除了的,直接写入扇区剩余区间. 				   </span></span><br><span class="line">        <span class="keyword">if</span>(NumToWrite==secremain)<span class="keyword">break</span>;<span class="comment">//写入结束了</span></span><br><span class="line">        <span class="keyword">else</span><span class="comment">//写入未结束</span></span><br><span class="line">        &#123;</span><br><span class="line">            secpos++;				<span class="comment">//扇区地址增1</span></span><br><span class="line">            secoff=<span class="number">0</span>;				<span class="comment">//偏移位置为0 	 </span></span><br><span class="line">            pBuffer+=secremain;  	<span class="comment">//指针偏移</span></span><br><span class="line">            WriteAddr+=secremain;	<span class="comment">//写地址偏移	   </span></span><br><span class="line">            NumToWrite-=secremain;	<span class="comment">//字节(16位)数递减</span></span><br><span class="line">            <span class="keyword">if</span>(NumToWrite&gt;(STM_SECTOR_SIZE/<span class="number">2</span>))secremain=STM_SECTOR_SIZE/<span class="number">2</span>;<span class="comment">//下一个扇区还是写不完</span></span><br><span class="line">            <span class="keyword">else</span> secremain=NumToWrite;<span class="comment">//下一个扇区可以写完了</span></span><br><span class="line">        &#125;	 </span><br><span class="line">    &#125;;	</span><br><span class="line">    FLASH_Lock();<span class="comment">//上锁</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//从指定地址开始读出指定长度的数据</span></span><br><span class="line"><span class="comment">//ReadAddr:起始地址</span></span><br><span class="line"><span class="comment">//pBuffer:数据指针</span></span><br><span class="line"><span class="comment">//NumToWrite:半字(16位)数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">STMFLASH_Read</span><span class="params">(u32 ReadAddr,u16 *pBuffer,u16 NumToRead)</span>   	</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    u16 i;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;NumToRead;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        pBuffer[i]=STMFLASH_ReadHalfWord(ReadAddr);<span class="comment">//读取2个字节.</span></span><br><span class="line">        ReadAddr+=<span class="number">2</span>;<span class="comment">//偏移2个字节.	</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>用户回调函数</strong></p>
<figure class="highlight cc"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Help_Proc_Func</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;DzyLink shell v1.0\r\n&quot;</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;modify by Dingzy\r\n&quot;</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;2020/10/12 21:44\r\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">List_Proc_Func</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	u8 i = <span class="number">0</span>;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;command num is %d\r\n&quot;</span>,COMMAND_NUM);</span><br><span class="line">	<span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; COMMAND_NUM; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d : %s\r\n&quot;</span>,i,commandStringList[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;*****************************************************\r\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>CommandScan扫描命令函数</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//扫描命令字符串,并调用相应处理函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CommandScan</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	u8 commandLength1;</span><br><span class="line">	u8 commandLength2;</span><br><span class="line">	u8 i = <span class="number">0</span>,j = <span class="number">0</span>;</span><br><span class="line">	<span class="comment">//数据满</span></span><br><span class="line">	<span class="keyword">if</span>((serial_Buffer_Length &amp; <span class="number">0x8000</span>) == <span class="number">0x8000</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//检测命令不是全为空格</span></span><br><span class="line">		<span class="keyword">if</span>(Command_Is_Vailed())</span><br><span class="line">		&#123;</span><br><span class="line">			Command_Copy();<span class="comment">//copy命令字符串等待处理</span></span><br><span class="line">			<span class="comment">//去除命令头上的空白</span></span><br><span class="line">			Command_Remove_Space_Head();</span><br><span class="line">			<span class="comment">//去除命令尾巴上的空格</span></span><br><span class="line">			Command_Remove_Space_End();</span><br><span class="line">			<span class="comment">//去除中间的重复空格</span></span><br><span class="line">			Command_Remove_Space_Inner();</span><br><span class="line">			commandLength1 = Command_Find_Space_Postion(<span class="number">1</span>);<span class="comment">//获取长度</span></span><br><span class="line">			<span class="keyword">if</span>(commandLength1 == <span class="number">0</span>)commandLength1 = commandStringLength;<span class="comment">//当第二个空格获取返回0的时候,说明没有参数,纯命令,所以没有空格</span></span><br><span class="line">			<span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; COMMAND_NUM; i++)</span><br><span class="line">			&#123;</span><br><span class="line">				commandLength2 = StringGetLength(commandStringList[i]);</span><br><span class="line">				<span class="keyword">if</span>(commandLength1 == commandLength2)</span><br><span class="line">				&#123;</span><br><span class="line">					<span class="comment">//长度相同,比对每个字符</span></span><br><span class="line">					<span class="keyword">for</span>(j = <span class="number">0</span>; j &lt; commandLength1; j++)</span><br><span class="line">					&#123;</span><br><span class="line">						<span class="keyword">if</span>(commandStringBuffer[j] == commandStringList[i][j])<span class="keyword">continue</span>;</span><br><span class="line">						<span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">					&#125;</span><br><span class="line">					<span class="keyword">if</span>(j == commandLength1)<span class="comment">//比对成功</span></span><br><span class="line">					&#123;</span><br><span class="line">						<span class="comment">//调用函数</span></span><br><span class="line">						Command_Proc_Func_Table[i]();</span><br><span class="line">						<span class="keyword">return</span>;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">else</span></span><br><span class="line">				&#123;</span><br><span class="line">					<span class="comment">//直接长度不同,不需要比对了</span></span><br><span class="line">					<span class="keyword">continue</span>;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span>(i == COMMAND_NUM)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="comment">//没找到对应命令</span></span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">&quot;not find command\r\n&quot;</span>);</span><br><span class="line">			&#125;</span><br><span class="line">			</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;command can&#x27;t all space\r\n&quot;</span>);</span><br><span class="line">			serial_Buffer_Length = <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//回调函数数组定义,比对成功之后按Command_table中的命令组依次执行</span></span><br><span class="line">Command_Proc_Func Command_Proc_Func_Table[] = </span><br><span class="line">&#123;</span><br><span class="line">	Help_Proc_Func,		<span class="comment">//打印版本、作者和时间信息			</span></span><br><span class="line">	List_Proc_Func,		<span class="comment">//打印命令num		</span></span><br><span class="line">	iap_down_s,			<span class="comment">//iap下载程序</span></span><br><span class="line">	iap_jump_app,		<span class="comment">//iap跳转到app</span></span><br><span class="line">	iap_over_s,			<span class="comment">//最后一包128数据写入</span></span><br><span class="line">	iap_set_flag,		<span class="comment">//设置app固化标志</span></span><br><span class="line">	iap_clear_flag		<span class="comment">//清除app固化标志</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>main函数</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	NVIC_Group_Init();	<span class="comment">//系统默认中断分组</span></span><br><span class="line">	Debug_Serial_Init(<span class="number">115200</span>);</span><br><span class="line">	Delay_Init();</span><br><span class="line">	Command_Init(<span class="number">100</span>);	<span class="comment">//100ms</span></span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(STMFLASH_ReadHalfWord(APP_CONFIG_ADDR) == <span class="number">0x5555</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="comment">//直接跳转到APP</span></span><br><span class="line">			iap_jump_app_s();</span><br><span class="line">		&#125;</span><br><span class="line">		CommandScan();	<span class="comment">//扫描命令处理</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="2-3-APP程序"><a href="#2-3-APP程序" class="headerlink" title="2.3 APP程序"></a>2.3 APP程序</h5><p>app使用最简单的蜂鸣器实验（代码来自正点原子），硬件部分将蜂鸣器的I/O口连接至PB8，代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;sys.h&quot;</span>	</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;delay.h&quot;</span>	</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;led.h&quot;</span> </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;beep.h&quot;</span> </span></span><br><span class="line"><span class="comment">//ALIENTEK战舰STM32开发板实验2</span></span><br><span class="line"><span class="comment">//蜂鸣器实验  </span></span><br><span class="line"><span class="comment">//技术支持：www.openedv.com</span></span><br><span class="line"><span class="comment">//广州市星翼电子科技有限公司 </span></span><br><span class="line"> <span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"> </span>&#123;</span><br><span class="line">	delay_init();	    	 <span class="comment">//延时函数初始化	  </span></span><br><span class="line">	LED_Init();		  	 	<span class="comment">//初始化与LED连接的硬件接口</span></span><br><span class="line">	BEEP_Init();         	<span class="comment">//初始化蜂鸣器端口</span></span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		LED0=<span class="number">0</span>;</span><br><span class="line">		BEEP=<span class="number">0</span>;		  </span><br><span class="line">		delay_ms(<span class="number">300</span>);<span class="comment">//延时300ms</span></span><br><span class="line">		LED0=<span class="number">1</span>;	  </span><br><span class="line">		BEEP=<span class="number">1</span>;  </span><br><span class="line">		delay_ms(<span class="number">300</span>);<span class="comment">//延时300ms</span></span><br><span class="line">	&#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<img src="/upload_image/蜂鸣器.jpg" alt="蜂鸣器" style="zoom: 33%;" />

<h4 id="3-通信协议"><a href="#3-通信协议" class="headerlink" title="3    通信协议"></a>3    通信协议</h4><p>挖坑待填…</p>
<h4 id="4-Q-amp-A"><a href="#4-Q-amp-A" class="headerlink" title="4   Q&amp;A"></a>4   Q&amp;A</h4><h5 id="4-1-报错"><a href="#4-1-报错" class="headerlink" title="4.1 报错"></a>4.1 报错</h5><ul>
<li><pre><code>..\..\Libraries\CMSIS\stm32f10x.h(298): error: #67: expected a &quot;&#125;&quot;
ADC1_2_IRQn = 18, /*!&lt; ADC1 and ADC2 global Interrupt */
..\..\Libraries\CMSIS\stm32f10x.h(472): warning: #12-D: parsing restarts here after previous syntax error&#125; IRQn_Type;
..\..\User\main.c: 1 warning, 1 error
&quot;..\..\User\main.c&quot; - 1 Error(s), 1 Warning(s).
<figure class="highlight lasso"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">  **解决方法：**在C/C++选项卡里，把STM3210X_HD从**Prepocessor symbol <span class="class"><span class="keyword">define</span><span class="title">*</span><span class="title">*</span> 里面删掉。在老版本的官方<span class="title">STM32F10x.h</span>文件里，是`...&amp;&amp;!<span class="title">defined</span></span>(STM32F10X_HD) &amp;&amp; <span class="params">...</span><span class="string">` 原来是有括号的，不做标识符来处理，而新版的直接说明了出来.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">- `</span><span class="string">``</span></span><br><span class="line">  ..\driver\debugSerial.c(<span class="number">14</span>): error:  #260<span class="params">-D</span>: explicit <span class="keyword">type</span> is missing (<span class="string">&quot;int&quot;</span> assumed)</span><br><span class="line">    _sys_exit(int x) </span><br></pre></td></tr></table></figure>
**问题原因：**_sys_exit(int x) 这个函数没有返回类型，产生这个的原因是因为用了C99的库，C99和C89的区别详见https://www.cnblogs.com/ys77/p/11541827.html

**解决方法：**添加 void  不报错，编译通过。

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span>  _sys_exit(<span class="keyword">int</span> x)</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
</ul>
<h5 id="4-2-IAP跳转执行的问题"><a href="#4-2-IAP跳转执行的问题" class="headerlink" title="4.2 IAP跳转执行的问题"></a>4.2 IAP跳转执行的问题</h5><p>在栈顶地址验证通过之后，Flash进行了擦除-拷贝-跳转执行的操作，问题在于跳转执行之后，Bootloader又将其引导回了流程一开始的阶段，两次擦除和拷贝之后，栈顶地址发生了改变，程序无法运行，如图所示：</p>
<img src="/upload_image/XCOM1.jpg" style="zoom:50%;" />

<p>解决方法：跳转程序没有正常执行，三种问题可能会导致APP跳转失败。</p>
<ol>
<li><p>设置了APP标志后，APP能够跳转到IAP中，但IAP马上又会跳转回APP，永远不能等待下载；</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//设置app固化配置</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">iap_set_flag_s</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Test_Write(APP_CONFIG_ADDR,APP_CONFIG_SET_VALUE);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;ok\r\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//清除app固化配置</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">iap_clear_flag</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Test_Write(APP_CONFIG_ADDR,APP_CONFIG_CLEAR_VALUE);</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;ok\r\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>先清除APP标志，然后再跳转到IAP程序中，标志就不会影响IAP的下载流程了。</p>
</li>
<li><p>APP的工程中，不仅是在[Target]中要设置Flash的起始地址和SIze，在Jlink的[Flash Download]中也需要设置芯片的起始地址和Size，如图所示：</p>
<img src="/upload_image/image-20201010133813256.png" alt="image-20201010133813256" style="zoom: 32%;" />

<img src="/upload_image/image-20201010133907154.png" alt="image-20201010133907154" style="zoom:42%;" />
</li>
<li><p>中断向量表的设置。在IAP中不需要考虑中断向量表，IAP的默认程序就是从0x8000000位置开始的，但是APP代码的起始位置必须从IAP程序之后的地址开始，因此必须重新设置中断向量表。在system_stm32f10x.c中又一个system_init的函数，该函数的作用为启动时调用配置系统时钟，该函数的最后为：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> VECT_TAB_SRAM</span></span><br><span class="line">  SCB-&gt;VTOR = SRAM_BASE | VECT_TAB_OFFSET; <span class="comment">/* Vector Table Relocation in Internal SRAM. */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">  SCB-&gt;VTOR = FLASH_BASE | VECT_TAB_OFFSET; <span class="comment">/* Vector Table Relocation in Internal FLASH. */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> </span></span><br></pre></td></tr></table></figure>
<p>其中VECT_TAB_OFFSET就是需要修改的偏移量,也就是APP程序的起始地址偏移,这个设置必须与IAP同步，我们设置为2000。该值的宏就需要修改,在128行的位置，将0x0修改为0x2000(与2中设置同步)。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> VECT_TAB_OFFSET  0x2000 <span class="comment">/*!&lt; Vector Table base offset field. </span></span></span><br><span class="line"><span class="meta"><span class="comment">                                  This value must be a multiple of 0x200. */</span></span></span><br></pre></td></tr></table></figure>



</li>
</ol>
]]></content>
      <categories>
        <category>嵌入式开发</category>
      </categories>
      <tags>
        <tag>嵌入式</tag>
        <tag>驱动开发</tag>
        <tag>通信</tag>
        <tag>Keil</tag>
        <tag>STM32</tag>
        <tag>IAP</tag>
      </tags>
  </entry>
  <entry>
    <title>墨水屏入门功能开发(一)——驱动编写</title>
    <url>/2020/09/06/%E5%A2%A8%E6%B0%B4%E5%B1%8F%E5%85%A5%E9%97%A8%E5%8A%9F%E8%83%BD%E5%BC%80%E5%8F%91(%E4%B8%80)%E2%80%94%E2%80%94%E9%A9%B1%E5%8A%A8%E7%BC%96%E5%86%99/</url>
    <content><![CDATA[<blockquote>
<p>开发工具： Keil 5<br>开发芯片： STM32F1x<br>墨水屏型号：GooDisplay 2.7寸四阶灰度墨水屏(GDEW027W3)<br>文档编写工具： Markdown</p>
</blockquote>
<p>墨水屏入门功能开发，理解局刷、全刷和墨水屏LUT.</p>
<a id="more"></a>

<h3 id="墨水屏简介"><a href="#墨水屏简介" class="headerlink" title="墨水屏简介"></a>墨水屏简介</h3><h4 id="墨水屏特性"><a href="#墨水屏特性" class="headerlink" title="墨水屏特性"></a>墨水屏特性</h4><p><img src="/upload_image/%E5%8E%9F%E7%90%86.png" alt="原理"><br>        墨水屏下包含这很多黑白粒子，黑白例子都是带不同电荷的色素颗粒，初始状态下色素颗粒会在一个单位中漂浮(floating)；当施加过一定方向的电场后，相应的色素颗粒会被推到顶端，使得一个单位呈现相应的颜色，大量的显示单位通过这种显色方式同时工作组成了不同的图案和文字。</p>
<p>以GooDisplay的产品为例，根据它的数据手册将墨水屏原理总结如下：</p>
<ul>
<li><strong>物理原理</strong>：黑色粒子带负电荷，白色粒子带正电荷，通过基板的电压正负控制粒子运动(面板显示的颜色)；</li>
<li><strong>双稳态特性：</strong> 由于电子墨水具有双稳态效应(磁滞效应)，黑白粒子不会回复原状或者变成随机的混沌状态；</li>
<li><strong>低功耗：</strong> 屏幕不变化，屏幕部分耗电量为0，主要耗电来自于电路板待机消耗以及电源内阻消耗；</li>
<li><strong>刷新缺陷：</strong> 同样由于磁滞效应，墨水屏在刷新一次如果不施加反向电压(显示为黑白切换)就有可能导致色素粒子运动混乱，在屏幕中出现“残影”</li>
</ul>
<h4 id="墨水屏光源解决方案"><a href="#墨水屏光源解决方案" class="headerlink" title="墨水屏光源解决方案"></a>墨水屏光源解决方案</h4><p>传统的LCD液晶屏有背光，受外界光源影响较小，只有日光环境下需要调节背光亮度来抵御环境光对屏幕显示的遮盖效果。墨水屏因为其物理特性比较依赖环境光，在实际应用中通常使用<strong>导光板+内置LED光源</strong>进行补光。<br>这在现实应用中已有先例可循，如生活中最常见的 <strong>[安全出口]</strong> 的指示牌就是利用了导光板实现低功耗光源的扩散效果。</p>
<img src="/upload_image/安全出口.jpg" alt="安全出口" style="zoom:150%;" />

<blockquote>
<p>​                                            底部为荧光LED，表面使用导光板</p>
</blockquote>
<h4 id="墨水屏功耗实测"><a href="#墨水屏功耗实测" class="headerlink" title="墨水屏功耗实测"></a>墨水屏功耗实测</h4><p>仍以GooDisplay的GDEW027W3型号的墨水屏为例，手册中给出的功耗如下表所示：</p>
<p><img src="/upload_image/image-20210118143657105.png" alt="image-20210118143657105"></p>
<p>实际应用时需要将墨水屏的驱动板功耗也考虑进去。使用万用表测量墨水屏转接板DESPI-C02上<strong>GND</strong>与<strong>PREVGH</strong>之间的电流，如下图所示：</p>
<blockquote>
<p>待机功耗<br><img src="/upload_image/image-20200831214637793.png" alt="image-20200831214637793" style="zoom: 25%;" /></p>
</blockquote>
<blockquote>
<p>静态画面功耗<br><img src="/upload_image/image-20200831214513063.png" alt="image-20200831214513063"></p>
</blockquote>
<blockquote>
<p>刷新峰值功耗<br><img src="/upload_image/image-20200831214427132.png" alt="image-20200831214427132"></p>
</blockquote>
<p>可以看到墨水屏在实际应用时功耗也相当低，能够满足低功耗的大部分应用场景。</p>
<h4 id="墨水屏的应用问题"><a href="#墨水屏的应用问题" class="headerlink" title="墨水屏的应用问题"></a>墨水屏的应用问题</h4><p>在墨水屏实际应用进行全局刷新时，遇到的最大问题为全局刷新的速度慢，且刷新时面板会出现夸张的黑白影像互换 **(即闪屏现象)**。 如果忽略这一问题进行开发，容易使客户形成产品有问题的印象。</p>
<p>针对这一问题的解决需要从墨水屏的物理原理入手。通过上述墨水屏的简介中可以知道，墨水屏能够在断电后保持原图像是因为墨水屏本身的磁滞效应。<br><img src="/upload_image/磁滞效应.jpg" alt="磁滞效应" style="zoom:120%;" /><br>       上图中，横轴为电压大小，纵轴为灰度(设正轴为白负轴为黑)。电压加大的过程和减小的过程，给予同样的电压，电子墨水黑白程度是不同的，这就是双稳态效应(磁滞效应)。利用这样的效应，我们就可以给一个正电压，电压从0升至B（在图中体现为从原点对应的A点到B点的过程，走下面上升的路线），吸引负电荷，显示正电荷白色给读者，然后断电（电压从B减少到0，走上方那条回来的路线），白色得以保持。墨水屏省电就在于如果不需要显示有所变化，屏幕部分消耗电量为0。</p>
<p>利用上图解释我们在全局刷新时遇到的问题：假设电压从0加大然后又降为0，墨水屏对应的灰度从A点经B最终达到了C点。如果下一次变化，减少电压，使得灰度沿着上图中的路径继续行走则墨水屏工作正常，墨水屏从黑–&gt;白–&gt;黑，这就是全局刷新时“闪屏”现象出现的原因，<strong>本质上为短时间内黑白两色粒子在反向电压下相互交替</strong>，全局刷新的实现手段即施加一个电压之后再施加一个反向电压，在形式上体现为“全部清场”；如果下一次变化不施加反向电压，即这个时刻得到白色之后在下一时刻仍需要这个像素点表现为白色，那么墨水屏在C点的灰度就不再是这个图形，电路驱动的电压对应的灰度将会不准确，白色粒子会堆积在上层，下一次施加反向电压(需要黑色)时，白色粒子在顶层仍有残留，墨水屏的黑白颜色程度就会不相同，出现了残影。</p>
<p>为了避免残影的出现，就必须在刷新时给墨水屏施加最大或者最小电压，使墨水屏的黑白粒子完成磁滞效应图中一个完整的运动周期(A–&gt;B–&gt;C–&gt;D–&gt;A)。</p>
<p>刷新速率慢则是各个厂家不同产品之间的差异，微观上体现为黑白粒子在正反向电压下运动速率。</p>
<hr>
<h3 id="SPI寄存器工作"><a href="#SPI寄存器工作" class="headerlink" title="SPI寄存器工作"></a>SPI寄存器工作</h3><p>SDA以D7、D6、…D0的顺序移位到8位移位寄存器中。移位寄存器中的数据字节在同一时钟内写入图形显示数据RAM(RAM)或命令寄存器。在串行模式下，仅允许写入操作。<br>SDA写入移位寄存器，先Command(发送寄存器指令)再parameter(write Data)，实现大多数的命令+数据写入。</p>
<p>在刷新和初始设置中有一部分指令比较重要，对以下指令作着重介绍。</p>
<h4 id="面板设置指令-R00H-："><a href="#面板设置指令-R00H-：" class="headerlink" title="面板设置指令(R00H)："></a>面板设置指令(<strong>R00H</strong>)：</h4><p>面板设置是执行所有操作之前必须设置的一项，通过面板设置我们可以改变墨水屏的分辨率、灰度初始设置、显示模式切换、调整扫描方向(包括左右扫描方向和上下扫描方向)等，理解这一指令对墨水屏的开发有着关键的意义。</p>
<table>
<thead>
<tr>
<th align="center">W/R</th>
<th align="center">C/D</th>
<th align="center">D7</th>
<th align="center">D6</th>
<th align="center">D5</th>
<th align="center">D4</th>
<th align="center">D3</th>
<th align="center">D2</th>
<th align="center">D1</th>
<th align="center">D0</th>
</tr>
</thead>
<tbody><tr>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">0</td>
</tr>
<tr>
<td align="center">0</td>
<td align="center">1</td>
<td align="center">RES1</td>
<td align="center">RES0</td>
<td align="center">LUT</td>
<td align="center">BWR</td>
<td align="center">UD</td>
<td align="center">SHL</td>
<td align="center">SH</td>
<td align="center">RST</td>
</tr>
</tbody></table>
<blockquote>
<p><strong>RES[1:0]: 显示分辨率设置 (source×gate)</strong><br>00b: 320×300 (default)  , 01b: 300×200<br>10b: 296×160 , 11b: 296×128 </p>
</blockquote>
<blockquote>
<p><strong>LUT: LUT选择设定.</strong><br>0: Using LUT from OTP. (default)<br>1: Using LUT from register. </p>
</blockquote>
<blockquote>
<p><strong>BWR: 颜色选择设定.</strong><br>0: 使用黑/白/红像素点. Run both LU1 and LU2. (default)<br>1: 使用黑/白像素点.  Run LU1 only. </p>
</blockquote>
<blockquote>
<p><strong>UD: Gate 扫描方向</strong><br>0: Scan down First line to last: Gn→…→ G1 (default)<br>1: Scan up. (default) First line to last: G1→…→ Gn </p>
</blockquote>
<blockquote>
<p><strong>SHL: Source偏移方向</strong><br>0: shift left. First data to last data: Sn→…→ S1<br>1: shift right First data to last data: S1→…  →Sn (default) </p>
</blockquote>
<blockquote>
<p><strong>SHD: 升压开关</strong><br>0: Booster OFF，寄存器数据保持不变，SEG / BG / VCOM保持浮动。<br>1: Booster ON（默认）SHD_N变低时，DC-DC将关闭。 寄存器和SRAM数据将一直保持到VDD OFF。  SD输出和VCOM将基于先前的条件并保持浮动。</p>
</blockquote>
<blockquote>
<p><strong>RST: 软复位</strong><br>0: No effect.<br>1: 升压器关闭，寄存器数据设置为其默认值，并且SEG / BG / VCOM：0V。  （默认）当RST_N变为低电平时，驱动器将复位。 所有寄存器将重置为默认值。 驱动程序所有功能将被禁用。  SD输出和VCOM将基于先前的条件并保持浮动。</p>
</blockquote>
<p><strong>应用举例：</strong> </p>
<blockquote>
<p>EPD_W21_WriteCMD(0x90);        </p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">0x90</span>即<span class="number">1001</span> <span class="number">0000</span>(RES1|RES0|LUT_EN|BWR|UD|SHL|SHD_N|RST_N)</span><br><span class="line">RSE[<span class="number">1</span>:<span class="number">0</span>]设为<span class="number">10</span>即设置分辨率为<span class="number">296</span>x160,</span><br><span class="line">LUT_EN为<span class="number">0</span>表示<span class="function">Using LUT from <span class="title">OTP</span><span class="params">(默认设置)</span></span></span><br><span class="line">BWR为1表示仅使用黑白像素点</span><br><span class="line">UD为<span class="number">0</span>设置扫描横方向从左到右,SHL为<span class="number">0</span>设置扫描纵方向从上往下</span><br><span class="line">SHD_N设置为<span class="number">0</span>即设置升压开关状态为OFF</span><br><span class="line">RST_N为<span class="number">0</span>表示所有设置重置为默认值，输出将默认为之前的设定</span><br></pre></td></tr></table></figure>
<h4 id="显示刷新命令-R12H"><a href="#显示刷新命令-R12H" class="headerlink" title="显示刷新命令(R12H)"></a>显示刷新命令(<strong>R12H</strong>)</h4><table>
<thead>
<tr>
<th align="center">W/R</th>
<th align="center">C/D</th>
<th align="center">D7</th>
<th align="center">D6</th>
<th align="center">D5</th>
<th align="center">D4</th>
<th align="center">D3</th>
<th align="center">D2</th>
<th align="center">D1</th>
<th align="center">D0</th>
</tr>
</thead>
<tbody><tr>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">1</td>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">1</td>
<td align="center">0</td>
</tr>
</tbody></table>
<blockquote>
<p> -该命令定义为：当用户发送该命令时，驱动程序将根据SRAM数据和LUT刷新显示(DATA/VCOM)。显示刷新命令后，BUSY_N信号将变为“0”。</p>
</blockquote>
<h4 id="部分数据传输至寄存器1-R14H"><a href="#部分数据传输至寄存器1-R14H" class="headerlink" title="部分数据传输至寄存器1(R14H)"></a>部分数据传输至寄存器1(<strong>R14H</strong>)</h4><table>
<thead>
<tr>
<th align="center">Inst</th>
<th align="center">W/R</th>
<th align="center">C/D</th>
<th align="center">D7</th>
<th align="center">D6</th>
<th align="center">D5</th>
<th align="center">D4</th>
<th align="center">D3</th>
<th align="center">D2</th>
<th align="center">D1</th>
<th align="center">D0</th>
</tr>
</thead>
<tbody><tr>
<td align="center">PDT</td>
<td align="center">w</td>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">1</td>
<td align="center">0</td>
<td align="center">1</td>
<td align="center">0</td>
<td align="center">0</td>
</tr>
<tr>
<td align="center">1st</td>
<td align="center">w</td>
<td align="center">1</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center">x8</td>
</tr>
<tr>
<td align="center">2nd</td>
<td align="center">w</td>
<td align="center">1</td>
<td align="center">x7</td>
<td align="center">x6</td>
<td align="center">x5</td>
<td align="center">x4</td>
<td align="center">x3</td>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">0</td>
</tr>
<tr>
<td align="center">3rd</td>
<td align="center">w</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center">Y8</td>
</tr>
<tr>
<td align="center">4th</td>
<td align="center">w</td>
<td align="center">1</td>
<td align="center">Y7</td>
<td align="center">Y6</td>
<td align="center">Y5</td>
<td align="center">Y4</td>
<td align="center">Y3</td>
<td align="center">Y2</td>
<td align="center">Y1</td>
<td align="center">Y0</td>
</tr>
<tr>
<td align="center">5th</td>
<td align="center">w</td>
<td align="center">1</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center">w8</td>
</tr>
<tr>
<td align="center">6th</td>
<td align="center">w</td>
<td align="center">1</td>
<td align="center">w7</td>
<td align="center">w6</td>
<td align="center">w5</td>
<td align="center">w4</td>
<td align="center">w3</td>
<td align="center">0</td>
<td align="center">0</td>
<td align="center">0</td>
</tr>
<tr>
<td align="center">7th</td>
<td align="center">w</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center">L8</td>
</tr>
<tr>
<td align="center">8th</td>
<td align="center">w</td>
<td align="center">1</td>
<td align="center">L7</td>
<td align="center">L6</td>
<td align="center">L5</td>
<td align="center">L4</td>
<td align="center">L3</td>
<td align="center">L2</td>
<td align="center">L1</td>
<td align="center">L0</td>
</tr>
<tr>
<td align="center">…</td>
<td align="center">…</td>
<td align="center">…</td>
<td align="center">…</td>
<td align="center">…</td>
<td align="center">…</td>
<td align="center">…</td>
<td align="center">…</td>
<td align="center">…</td>
<td align="center">…</td>
<td align="center">…</td>
</tr>
</tbody></table>
<blockquote>
<p>命令定义如下：寄存器IS表示用户开始传输数据，然后写入SRAM。<br>当数据传输完成时，用户必须发送命令11H。<br>然后芯片将开始向面板发送数据/VCOM。<br>在B/W模式下，此命令将“旧”数据写入SRAM。<br>在B/W/Red模式下，此命令将“B/W”数据写入SRAM。 </p>
</blockquote>
<p>局部刷新位置和区域见数据手册</p>
<hr>
<h3 id="墨水屏主要功能实现"><a href="#墨水屏主要功能实现" class="headerlink" title="墨水屏主要功能实现"></a>墨水屏主要功能实现</h3><h4 id="局部刷新"><a href="#局部刷新" class="headerlink" title="局部刷新"></a>局部刷新</h4><p>在分析完墨水屏的物理特性之后了解了全局刷新的缺陷，这种缺陷由墨水屏的先天物理特性决定无法更改。但墨水屏厂家为了应对这一情况，给墨水屏添加了局部刷新的功能，局部刷新模式下能够减少磁滞效应的闪屏和刷新缓慢的影响，但局部刷新多次后需要执行一次全局刷新将残影抹除。</p>
<p>局刷程序的流程为：</p>
<p><strong>面板设置–&gt;色度设置(LUT)–&gt;扫描方向设置–&gt;旧数据写入–&gt;新数据写入–&gt;刷新并将BUSY_N信号置0</strong></p>
<p>其中，新旧数据写入在不同的场景下可以通过模式进行区分</p>
<figure class="highlight gcode"><table><tr><td class="code"><pre><span class="line">旧数据写入：</span><br><span class="line">    模式<span class="number">0</span>：写入刷新区域全白数据，使用场景为第一张图片<span class="comment">(无旧图片替代)</span></span><br><span class="line">    非<span class="number">0</span>模式：写入前一张图像点阵</span><br><span class="line">新数据写入：</span><br><span class="line">    模式<span class="number">2</span>：写入刷新区域全白数据，使用场景为没有新图像以空白刷新</span><br><span class="line">    非<span class="number">2</span>模式：写入新图像的点阵</span><br></pre></td></tr></table></figure>
<p>完整局刷程序如下所示：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//局部刷新程序</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">EPD_partial_display</span><span class="params">(u16 x,u16 y,<span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> *old_data,<span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> *new_data,<span class="keyword">unsigned</span> <span class="keyword">int</span> w,<span class="keyword">unsigned</span> <span class="keyword">int</span> l,<span class="keyword">unsigned</span> <span class="keyword">char</span> mode)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	    <span class="keyword">unsigned</span> <span class="keyword">int</span> i,count;</span><br><span class="line">	    EPD_W21_WriteCMD(<span class="number">0x82</span>);		<span class="comment">//vcom_DC setting  	</span></span><br><span class="line">        EPD_W21_WriteDATA (<span class="number">0x08</span>);	<span class="comment">//VCOM_DC VALUE=-0.5v</span></span><br><span class="line">		EPD_W21_WriteCMD(<span class="number">0X50</span>);     <span class="comment">//vcom和数据间隔设置（CDI）</span></span><br><span class="line">		EPD_W21_WriteDATA(<span class="number">0x47</span>);	<span class="comment">//0x47=0100 0111：01-LUTBW(0→1)，00-B/W两色模式，</span></span><br><span class="line">		                            <span class="comment">//0111-vcom和数据间隔设置为10(默认)	</span></span><br><span class="line">		lut1();	                    <span class="comment">//设置Look-up Table</span></span><br><span class="line">	    EPD_W21_WriteCMD(<span class="number">0x91</span>);		<span class="comment">//This command makes the display enter partial mode</span></span><br><span class="line">		EPD_W21_WriteCMD(<span class="number">0x90</span>);		<span class="comment">//resolution setting </span></span><br><span class="line">        EPD_W21_WriteCMD(<span class="number">0x14</span>);     <span class="comment">//old data 发送到寄存器1(x和w应该是8的整除)</span></span><br><span class="line">		EPD_W21_WriteDATA(<span class="number">0</span>);	    <span class="comment">//x-start</span></span><br><span class="line">		EPD_W21_WriteDATA(x);       <span class="comment">//x-end</span></span><br><span class="line">		EPD_W21_WriteDATA(<span class="number">0</span>);	    <span class="comment">//y-start</span></span><br><span class="line">		EPD_W21_WriteDATA(y);	    <span class="comment">//y-end</span></span><br><span class="line">		EPD_W21_WriteDATA(<span class="number">0</span>);	    <span class="comment">//w-start</span></span><br><span class="line">		EPD_W21_WriteDATA(w);	    <span class="comment">//w-end</span></span><br><span class="line">		EPD_W21_WriteDATA(<span class="number">0</span>);	    <span class="comment">//l-start</span></span><br><span class="line">		EPD_W21_WriteDATA(l);	    <span class="comment">//l-end</span></span><br><span class="line"></span><br><span class="line">    count=w*l/<span class="number">8</span>;    <span class="comment">//计算Byte个数</span></span><br><span class="line">	<span class="keyword">if</span>(mode==<span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">    	<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;count;i++)	     </span><br><span class="line">    	&#123;</span><br><span class="line">    	 EPD_W21_WriteDATA(<span class="number">0x00</span>);  <span class="comment">//全白</span></span><br><span class="line">    	&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">    	 <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;count;i++)	     </span><br><span class="line">    	&#123;</span><br><span class="line">    	EPD_W21_WriteDATA(~old_data[i]);  <span class="comment">//写入旧数据</span></span><br><span class="line">    	&#125; </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">         EPD_W21_WriteCMD(<span class="number">0x15</span>);     <span class="comment">//write new data(发送到寄存器2)</span></span><br><span class="line">		EPD_W21_WriteDATA(<span class="number">0</span>);	    <span class="comment">//x-start</span></span><br><span class="line">		EPD_W21_WriteDATA(x);       <span class="comment">//x-end</span></span><br><span class="line">		EPD_W21_WriteDATA(<span class="number">0</span>);	    <span class="comment">//y-start</span></span><br><span class="line">		EPD_W21_WriteDATA(y);	    <span class="comment">//y-end</span></span><br><span class="line">		EPD_W21_WriteDATA(<span class="number">0</span>);	    <span class="comment">//w-start</span></span><br><span class="line">		EPD_W21_WriteDATA(w);	    <span class="comment">//w-end</span></span><br><span class="line">		EPD_W21_WriteDATA(<span class="number">0</span>);	    <span class="comment">//l-start</span></span><br><span class="line">		EPD_W21_WriteDATA(l);	    <span class="comment">//l-end</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(mode!=<span class="number">2</span>) <span class="comment">//new  datas</span></span><br><span class="line">    	&#123;</span><br><span class="line">    		<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;count;i++)	     </span><br><span class="line">    	    &#123;</span><br><span class="line">    		EPD_W21_WriteDATA(~new_data[i]);  </span><br><span class="line">    		<span class="comment">//old_data[i]=new_data[i];</span></span><br><span class="line">    	    &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">else</span>  <span class="comment">//white</span></span><br><span class="line">     &#123;</span><br><span class="line">    		<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;count;i++)	     </span><br><span class="line">    		&#123;</span><br><span class="line">    		 EPD_W21_WriteDATA(<span class="number">0x00</span>);  </span><br><span class="line">    		&#125;		</span><br><span class="line">     &#125;		</span><br><span class="line"></span><br><span class="line">        EPD_W21_WriteCMD(<span class="number">0x16</span>);     <span class="comment">//write display position</span></span><br><span class="line">		EPD_W21_WriteDATA(<span class="number">0</span>);	    <span class="comment">//x-start</span></span><br><span class="line">		EPD_W21_WriteDATA(x);       <span class="comment">//x-end</span></span><br><span class="line">		EPD_W21_WriteDATA(<span class="number">0</span>);	    <span class="comment">//y-start</span></span><br><span class="line">		EPD_W21_WriteDATA(y);	    <span class="comment">//y-end</span></span><br><span class="line">		EPD_W21_WriteDATA(<span class="number">0</span>);	    <span class="comment">//w-start</span></span><br><span class="line">		EPD_W21_WriteDATA(w);	    <span class="comment">//w-end</span></span><br><span class="line">		EPD_W21_WriteDATA(<span class="number">0</span>);	    <span class="comment">//l-start</span></span><br><span class="line">		EPD_W21_WriteDATA(l);	    <span class="comment">//l-end</span></span><br><span class="line">	    lcd_chkstatus();</span><br><span class="line">    	</span><br><span class="line">		EPD_W21_WriteCMD(<span class="number">0x12</span>);		 <span class="comment">//DISPLAY REFRESH</span></span><br><span class="line">		<span class="comment">//发出此命令后，驱动程序将根据SRAM数据和LUT刷新显示（数据/ VCOM）。 </span></span><br><span class="line">		<span class="comment">//显示刷新命令后，BUSY_N信号将变为“ 0”。 </span></span><br><span class="line">		<span class="comment">//该命令仅在BUSY_N =“ 1”时有效。           </span></span><br><span class="line">		driver_delay_xms(<span class="number">1</span>);     <span class="comment">//!!!The delay here is necessary, 200uS at least!!!     </span></span><br><span class="line">		lcd_chkstatus();        <span class="comment">//Check BUSY_N  </span></span><br><span class="line">		<span class="comment">//当BUSY_N为低电平时，芯片的操作不中断，并且不向模块发出任何命令。</span></span><br><span class="line">	  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="灰度调节"><a href="#灰度调节" class="headerlink" title="灰度调节"></a>灰度调节</h4><p>随着对墨水屏了解的深入，发现手册中介绍了墨水屏的另一个功能——<strong>灰度调节</strong></p>
<h5 id="灰度功能简介"><a href="#灰度功能简介" class="headerlink" title="灰度功能简介"></a>灰度功能简介</h5><p>这个功能由LUT(Look-Up-Table)实现，针对LUT搜集到的资料如下：</p>
<blockquote>
<p><strong>定义</strong>：LUT指显示查找表（Look-Up-Table)，本质上就是一个RAM。可以应用到一张像素灰度值的映射表，它将实际采样到的像素灰度值经过一定的变换如阈值、反转、二值化、对比度调整、线性变换等，变成了另外一个与之对应的灰度值，这样可以起到突出图像的有用信息，增强图像的光对比度的作用。</p>
<p><strong>参考链接</strong>：</p>
<p><a href="https://baike.baidu.com/item/LUT/9096116">LUT(Look-Up-Table)-百度百科</a></p>
<p><a href="https://blog.csdn.net/liuligui5200/article/details/79553233?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522159533369819195264557086%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fall.%2522%257D&request_id=159533369819195264557086&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v3~pc_rank_v3-2-79553233.pc_ecpm_v3_pc_rank_v3&utm_term=LED%E7%9A%84LUT&spm=1018.2118.3001.4187">TW8836字体OSD~第一节LUT-CSDN</a></p>
<p><a href="https://www.jacksonlin.net/20170914-luts-function/">LUT的3種不同用途解析</a></p>
</blockquote>
<h5 id="LUT函数的实现"><a href="#LUT函数的实现" class="headerlink" title="LUT函数的实现"></a>LUT函数的实现</h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">lut</span><span class="params">(<span class="keyword">void</span>)</span><span class="comment">//改变画面的曝光与色彩，增强图像的光对比度的作用      </span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> count;</span><br><span class="line">	EPD_W21_WriteCMD(<span class="number">0x20</span>);    <span class="comment">//使用该指令为VCOM建立一个显示查找表（Look-Up-Table)</span></span><br><span class="line">	<span class="keyword">for</span>(count=<span class="number">0</span>;count&lt;<span class="number">44</span>;count++)	     </span><br><span class="line">		&#123;EPD_W21_WriteDATA(lut_vcomDC[count]);&#125;</span><br><span class="line"></span><br><span class="line">	EPD_W21_WriteCMD(<span class="number">0x21</span>);    <span class="comment">//使用该指令建立一个白色-白色的显示查找表</span></span><br><span class="line">	<span class="keyword">for</span>(count=<span class="number">0</span>;count&lt;<span class="number">42</span>;count++)	     </span><br><span class="line">		&#123;EPD_W21_WriteDATA(lut_ww[count]);&#125;   </span><br><span class="line">	</span><br><span class="line">	EPD_W21_WriteCMD(<span class="number">0x22</span>);    <span class="comment">//使用该指令建立一个黑色-白色的显示查找表</span></span><br><span class="line">	<span class="keyword">for</span>(count=<span class="number">0</span>;count&lt;<span class="number">42</span>;count++)	     </span><br><span class="line">		&#123;EPD_W21_WriteDATA(lut_bw[count]);&#125; </span><br><span class="line"></span><br><span class="line">	EPD_W21_WriteCMD(<span class="number">0x23</span>);    <span class="comment">//使用该指令建立一个白色-黑色的显示查找表</span></span><br><span class="line">	<span class="keyword">for</span>(count=<span class="number">0</span>;count&lt;<span class="number">42</span>;count++)	     </span><br><span class="line">		&#123;EPD_W21_WriteDATA(lut_wb[count]);&#125; </span><br><span class="line"></span><br><span class="line">	EPD_W21_WriteCMD(<span class="number">0x24</span>);    <span class="comment">//使用该指令建立一个黑色-黑色的显示查找表</span></span><br><span class="line">	<span class="keyword">for</span>(count=<span class="number">0</span>;count&lt;<span class="number">42</span>;count++)	     </span><br><span class="line">		&#123;EPD_W21_WriteDATA(lut_bb[count]);&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>手册中并没有告诉我lut_ww，lut_bw，lut_wb，lut_bb这些数组的作用，也并不清楚IC(驱动芯片)是如何工作的，因此我翻了国内外一些关于墨水屏开发的视频，<a href="https://www.youtube.com/watch?v=MsbiO8EAsGw&t=1113s">E-paper hacking: fastest possible refresh rate-YouTube</a>中详细讲解了各个数组和波形的用途。</p>
<p>查询GooDisplay墨水屏手册我了解到该型号墨水屏的驱动芯片(IC)为IL91874。在搜集了国外微雪的资料再结合视频中的知识之后，发现IL91874的波形与微雪的IC的波形在数据格式上是基本一致的，主要的区别在于GooDisplay中设置时钟频率和门电路的Byte放在前两位，而微雪则是放在最后两位 <em>(这一点在做不同厂家墨水屏开发程序之间的迁移时需要格外注意)</em> 。</p>
<blockquote>
<p>微雪墨水屏数据手册：<br><img src="/upload_image/20200715160631675.jpg" alt="img"></p>
</blockquote>
<blockquote>
<p>GooDisplay的数据手册：<br>![LUT for Vcom](/upload_image/LUT for Vcom.jpg)</p>
</blockquote>
<p>分析上表：</p>
<ul>
<li><p>1st Parameter： </p>
<ul>
<li><p>这个byte可以设置四个波形，第一个波形使用D7-D6指定，第二个波形使用D5-D4指定，第三个波形D3-D2，第四个波形D1-D0.</p>
</li>
<li><p>其中，Level selection的定义在数据手册中定义如下：</p>
<blockquote>
<p>  00: -VCM_DC </p>
<p>  01: VSH-VCM_DC，为VCOMH，给VCOM正电</p>
<p>  10: VSL-VCM_DC，为VCOML，给VCOM负电</p>
<p>  11: Floating. </p>
</blockquote>
</li>
<li><p>00和11在电压正常情况下，黑白粒子的位置会保持不变，灰度不变；</p>
</li>
<li><p>如果VCOM使用01b(正电)，结合前边的内容理解，屏幕会更黑；</p>
</li>
<li><p>如果VCOM使用10b(负电)，屏幕会更白。</p>
</li>
</ul>
</li>
<li><p>2nd Parameter： Frame number[7：0]，指定帧数[0~255]</p>
</li>
<li><p>3rd Parameter： Frame number[7：0]，指定帧数[0~255]</p>
</li>
<li><p>4th Parameter： Frame number[7：0]，指定帧数[0~255]</p>
</li>
<li><p>5th Parameter： Frame number[7：0]，指定帧数[0~255]</p>
</li>
<li><p>6th Parameter： Repeat number[7：0]，bytes2到bytes6做出的波形，要重复的次数[0~255]</p>
</li>
</ul>
<p>如此，1-6定义一个子波形，7-13定义第二个子波形，等等等等以此类推。一共42/6=7个子波形，他们共同拼接成一整个波形。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> lut_ww[] =&#123;	</span><br><span class="line"><span class="number">0x40</span>	,<span class="number">0x08</span>	,<span class="number">0x00</span>	,<span class="number">0x00</span>	,<span class="number">0x00</span>	,<span class="number">0x02</span>,	</span><br><span class="line"><span class="number">0x90</span>	,<span class="number">0x28</span>	,<span class="number">0x28</span>	,<span class="number">0x00</span>	,<span class="number">0x00</span>	,<span class="number">0x01</span>,	</span><br><span class="line"><span class="number">0x40</span>	,<span class="number">0x14</span>	,<span class="number">0x00</span>	,<span class="number">0x00</span>	,<span class="number">0x00</span>	,<span class="number">0x01</span>,	</span><br><span class="line"><span class="number">0xA0</span>	,<span class="number">0x12</span>	,<span class="number">0x12</span>	,<span class="number">0x00</span>	,<span class="number">0x00</span>	,<span class="number">0x01</span>,	</span><br><span class="line"><span class="number">0x00</span>	,<span class="number">0x00</span>	,<span class="number">0x00</span>	,<span class="number">0x00</span>	,<span class="number">0x00</span>	,<span class="number">0x00</span>,	</span><br><span class="line"><span class="number">0x00</span>	,<span class="number">0x00</span>	,<span class="number">0x00</span>	,<span class="number">0x00</span>	,<span class="number">0x00</span>	,<span class="number">0x00</span>,	</span><br><span class="line"><span class="number">0x00</span>	,<span class="number">0x00</span>	,<span class="number">0x00</span>	,<span class="number">0x00</span>	,<span class="number">0x00</span>	,<span class="number">0x00</span>,	&#125;;</span><br></pre></td></tr></table></figure>
<p>以上述截图中的lut_ww(white-white)数组为例，一行6个Parameter共7行，第一个波形执行了两次(0x02)，第二个波形执行了一次(0x01)……实现的功能是通过控制VCOM的上电时间控制墨水屏例子显示的颜色，如在清屏之后的屏幕上(<strong>0.5单位的黑色+0.5单位的白色</strong>)的情况下，给墨水屏上1.5秒的负电，此时墨水屏中粒子的黑色浓度变成了(<strong>0.5单位的黑色+1.5单位的白色=1单位的白色</strong>)，墨水屏的颜色就从黑白平衡变成了纯白，lut_ww的”white-white”的功能就实现了。</p>
<h5 id="分析lut函数的意义"><a href="#分析lut函数的意义" class="headerlink" title="分析lut函数的意义"></a>分析lut函数的意义</h5><ol>
<li><p>根据以上3个场景，可以推理出其他色阶的展示。灰阶，就是波形的产物；</p>
</li>
<li><p>只要波形设置到位，可以显示任意灰阶；</p>
</li>
<li><p>在波形叠加的情况下，也可以从任意灰阶，直接跳到另一灰阶；</p>
</li>
<li><p>墨水屏上的灰度，可以对这个Vcom施加不同时长的正负电，以实现灰度；</p>
</li>
<li><p><del>(猜想)对于宋体字在墨水屏中显示单薄/不好看的问题，可以通过调整灰度来使”黑的更黑白的更白”，而不再需要更换字库中的字体。</del> </p>
<p>7.23更新：暂时放弃，改善会议中提出的清晰度问题，通过改字库的方法更方便。这条可备用后续功能 <strong>[调整面板对比度]</strong></p>
</li>
</ol>
<h4 id="BUSY状态检查"><a href="#BUSY状态检查" class="headerlink" title="BUSY状态检查"></a>BUSY状态检查</h4><p>使用SPI指令时需要用到自锁lcd_chkstatus程序(检查Busy状态)，引入这一信号量来保证指令之间不互相干涉。</p>
<p>检查Busy状态的操作流程为：</p>
<ol>
<li>开机指令后，驱动器将根据开机顺序开机。接通电源命令后，BUSY_N信号将从高降至低；</li>
<li>当完成断电序列时，BUSY_N信号将从低上升到高；</li>
<li>BUSY_N=“0”：驱动程序繁忙，数据/VCOM正在转换。BUSY_N=“1”：非忙，主机端可以向驱动程序发送命令/数据。</li>
</ol>
<p>代码实现：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">lcd_chkstatus</span><span class="params">(<span class="keyword">void</span>)</span>    <span class="comment">//Check BUSY_N </span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">char</span> busy;</span><br><span class="line">	<span class="keyword">do</span></span><br><span class="line">	&#123;</span><br><span class="line">		EPD_W21_WriteCMD(<span class="number">0x71</span>);     <span class="comment">//读取IC状态</span></span><br><span class="line">		busy = isEPD_W21_BUSY;</span><br><span class="line">		busy =!(busy &amp; <span class="number">0x01</span>);       <span class="comment">//    xxxx xxxx&amp;0000 0001    </span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span>(busy);           <span class="comment">//若BUSN_N为低电平，则循环查询</span></span><br><span class="line">	driver_delay_xms(<span class="number">200</span>);                       </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="墨水屏开发小结"><a href="#墨水屏开发小结" class="headerlink" title="墨水屏开发小结"></a>墨水屏开发小结</h3><p>读懂墨水屏的英文开发文档之后再结合相关知识，我发现墨水屏的低功耗、局部快速刷新功能具有相当的实用价值。如果在实际应用中能够接受偶尔全局刷新的闪屏(约5-10次局部刷新之后)和墨水屏的成本较高等缺陷，那么墨水屏就可以作为工业显示仪表中传统LED屏幕的有力替代方案。</p>
<p>第一阶段的开发过程有很多不足，需要在下一阶段继续调试和研究：</p>
<ol>
<li>项目开发的最终目标为在更低功耗的MSP430上运行，目前开发环境为STM32F1X芯片，需要重新比对两者区别，后续完成程序的移植；</li>
<li>同一厂家的墨水屏硬件也不相同，同时字库的设置会因为字体要求不同而反复调整，为了方便维护，准备引入宏定义增加程序可移植性；</li>
<li>墨水屏的汉字索引目前的方法为预先建立字库调用，效率较低，下一阶段准备使用2312汉字字库匹配的方式在程序中实现“所现即所求”。</li>
</ol>
]]></content>
      <categories>
        <category>嵌入式开发</category>
      </categories>
      <tags>
        <tag>嵌入式</tag>
        <tag>驱动开发</tag>
        <tag>E-paper</tag>
        <tag>低功耗</tag>
        <tag>Keil</tag>
        <tag>STM32</tag>
      </tags>
  </entry>
  <entry>
    <title>树莓派平台自建博客(一)——搭建树莓派托管平台</title>
    <url>/2021/01/11/%E8%87%AA%E5%BB%BA%E5%8D%9A%E5%AE%A2(%E4%B8%80)%E2%80%94%E2%80%94%E6%90%AD%E5%BB%BA%E6%A0%91%E8%8E%93%E6%B4%BE%E6%89%98%E7%AE%A1%E5%B9%B3%E5%8F%B0/</url>
    <content><![CDATA[<blockquote>
<p>博客搭载我选择了以树莓派作为平台，理由在前言中有详细且 <code>真实</code> 的表达<br>但考虑到树莓派平台本身的局限性，最后还会作一个多PC的推送，初步将这个系列分为四部分</p>
</blockquote>
<a id="more"></a>

<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>​    选择树莓派作为博客搭管平台的理由:</p>
<p>​    一，大多数博客都是在上班学习新知识时完成，主要写在公司的PC上；</p>
<p>​    二，公司开发产品的环境会选择旧版本，与工作内容不相关的其他环境建在工作PC上容易造成意想不到的麻烦；</p>
<p>​    三，树莓派系统读写在SD卡上，断电拔插解千愁(大不了重装系统)；</p>
<p>​    四，穷。</p>
<h3 id="树莓派环境"><a href="#树莓派环境" class="headerlink" title="树莓派环境"></a>树莓派环境</h3><h4 id="树莓派的连接"><a href="#树莓派的连接" class="headerlink" title="树莓派的连接"></a>树莓派的连接</h4><p>​    首先烧写树莓派系统，这里选择的是<code>2017-04-10-ssh-china-raspbian-jessie.img</code>，新版的系统怕遇到新麻烦难以解决搞球不来所以选了个熟悉的旧版本；</p>
<p>​    内存卡方面选择了A1的16G的金士顿，用<code>Win32DiskImager</code>工具烧完系统；</p>
<p>​    先将自己显示器的HDMI接口连接至树莓派(没有显示器的看这里：<a href="https://segmentfault.com/a/1190000010976507#articleHeader3">树莓派如何完全无头(无屏无网线无键盘鼠标)安装</a> )；</p>
<p>​    插卡，上电(5v2A)，开机，手动连接至PC连接的同一局域网；</p>
<p>​    打开终端，输入：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ifconfig</span><br></pre></td></tr></table></figure>
<p>​    获取树莓派的ip地址，记住树莓派的默认username是<code>pi</code>，默认密码是<code>raspberry</code></p>
<p>​    下载<code>Putty</code>或者<code>xshell</code>通过SSH方式连接树莓派，这里用的是Putty，<a href="https://www.chiark.greenend.org.uk/~sgtatham/putty/latest.html">附上下载链接</a>，选择<code>putty.exe(the SSH and Telnet client itself)</code>。打开Putty，按图中顺序输入IP地址，点击[Open]。</p>
<img src="/upload_image/image-20210110185859101.png" alt="image-20210110185859101" style="zoom:67%;" />

<p>​    打开之后，输入正确的用户名和密码，回车*2。</p>
<img src="/upload_image/image-20210110190526959.png" alt="image-20210110190526959" style="zoom:50%;" />

<h4 id="树莓派的硬件驱动"><a href="#树莓派的硬件驱动" class="headerlink" title="树莓派的硬件驱动"></a>树莓派的硬件驱动</h4><p>​    因为大学里也阔过所以还有一块微雪的3.5寸的触摸屏，树莓派默认1080分辨率的HDMI视频输出，因此使用这块屏幕需要下载专门的驱动；</p>
<p>​    终端输入：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git clone https://github.com/waveshare/LCD-show.git</span><br><span class="line">cd LCD-show/</span><br><span class="line">sudo ./LCD35-show</span><br></pre></td></tr></table></figure>
<p>​    这种驱动工作的话执行apt-get upgrade会导致LCD无法正常工作，解决方法：</p>
<p>​    关机，拔下SD卡，读卡器插入PC，boot根目录下找到 config.txt 文件并打开，找到并删除这一句：<code>dtoverlay=ads7846,</code></p>
<p>​    Ctrl+S保存config.txt文件并关闭，重新给树莓派插上SD卡，开机；</p>
<p>​    树莓派的系统就适配在3.5寸屏幕上了，因为初始的桌面方向底部在电源口方向我很不方便，所以需要旋转屏幕，还是putty打开终端输入</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd LCD-show/</span><br><span class="line"><span class="meta">#</span><span class="bash">X可选0、90、180和270。分别表示LCD旋转0度、90度、180度和270度。</span></span><br><span class="line">sudo ./LCD35-show X</span><br><span class="line"><span class="meta">#</span><span class="bash">这里X我选的是180，个人喜爱</span></span><br></pre></td></tr></table></figure>
<p>​    <em>请不要输入0！！！请不要输入0！！！请不要输入0！！！会直接白屏，如果手贱已输，网上攻略让找找config.txt文件注释LCD一些设置或者跟我一样选择重装系统…</em></p>
<h4 id="为树莓派修改更新源"><a href="#为树莓派修改更新源" class="headerlink" title="为树莓派修改更新源"></a>为树莓派修改更新源</h4><p>​    因为社会主义网络下载资本主义的系统源和软件源会非常非常非常慢，所以需要在手贱进行<code>sudo apt-get upgrade</code>之前将镜像源换掉，    终端输入：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo nano /etc/apt/sources.list</span><br><span class="line"><span class="meta">#</span><span class="bash">修改软件更新源</span></span><br></pre></td></tr></table></figure>
<p>​    如下图所示：</p>
<p><img src="/upload_image/1.jpg" alt="修改前sources.list"></p>
<p>​    用 # 号将原来的国外镜像源注释掉，并添加国内的清华源，在文件后添加如下代码：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">deb http://mirrors.tuna.tsinghua.edu.cn/raspbian/raspbian/ buster main contrib non-free rpi</span><br><span class="line"><span class="meta">#</span><span class="bash">deb-src http://mirrors.tuna.tsinghua.edu.cn/raspbian/raspbian/ buster main contrib non-free rpi</span></span><br></pre></td></tr></table></figure>
<p>​    完成后如图所示：</p>
<p><img src="/upload_image/2.jpg" alt="修改后的sources.list"></p>
<p>​    <code>Ctrl+X</code>退出，然后按<code>Y</code>保存，回车退出。</p>
<p>​    终端输入：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo nano /etc/apt/sources.list.d/raspi.list</span><br><span class="line"><span class="meta">#</span><span class="bash">修改系统更新源</span></span><br></pre></td></tr></table></figure>
<p>​    如下图所示：</p>
<p><img src="/upload_image/3.jpg" alt="修改前的raspi.list内容"></p>
<p>​    注释第一行，末尾加上添加的新源地址：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">deb http://mirrors.ustc.edu.cn/archive.raspberrypi.org/debian/ buster main uih</span><br></pre></td></tr></table></figure>
<p>​    完成如图所示：</p>
<p><img src="/upload_image/4.jpg" alt="修改后的raspi.list内容"></p>
<p>​    <code>Ctrl+X</code>退出，然后按<code>Y</code>保存，回车退出。</p>
<h4 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h4><p>​    更新树莓派系统，在终端输入<code>sudo apt-get update</code></p>
<p>​    更新树莓派软件，在终端输入<code>sudo apt-get upgrade</code></p>
<p>​    过程漫长，开始煲汤…</p>
<p>​    第二步结束之后，卡住不动出现changelogs说明第一阶段结束，一直按回车到变更记录底部</p>
<img src="/upload_image/image-20210110191529225.png" alt="image-20210110191529225" style="zoom:50%;" />

<p>​    出现提示：<code>q to quit</code>，按下q，然后回车。</p>
<img src="/upload_image/image-20210110191444420.png" alt="image-20210110191444420" style="zoom:50%;" />

<p>​    Done.</p>
<h3 id="安装Git"><a href="#安装Git" class="headerlink" title="安装Git"></a>安装Git</h3><p>​    终端输入：<code>sudo apt-get install git</code></p>
<p>​    修改全局用户名：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git config --global user.name &quot;你的GitHub/Gitee用户名&quot;</span><br><span class="line">git config --global user.email &quot;你的GitHub/Gitee邮箱&quot;</span><br></pre></td></tr></table></figure>
<p>​    Email不知道是啥的点进Github右上角头像[Settings]，找到<code>Emails</code></p>
<img src="/upload_image/image-20210110194209174.png" alt="image-20210110194209174" style="zoom: 33%;" />

<p>​    查看自己是不是已经修改成功：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git config --list</span><br></pre></td></tr></table></figure>
<p>​    如图则成功：</p>
<img src="/upload_image/image-20210110194529563.png" alt="image-20210110194529563" style="zoom:50%;" />

<h3 id="安装Node-js"><a href="#安装Node-js" class="headerlink" title="安装Node.js"></a>安装Node.js</h3><p>​    <strong>前排提示可能是最坑的一步要来了…</strong></p>
<p>​    先装个傻子假装不知道树莓派的架构，打开终端输入：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">uname -a</span><br></pre></td></tr></table></figure>
<img src="/upload_image/image-20210110194811054.png" alt="image-20210110194811054" style="zoom:50%;" />

<p>​    可以看到树莓派是armv71架构，即ARM7.</p>
<p>​    登录 <a href="https://nodejs.org/en/download/">Node.js官网</a>，可以看到Node.js很贴心的给出了推荐版本，点开<code>Linux Binaries (ARM)</code>下支持<code>ARMv7</code>架构的最新版本是<code>v14.15.4</code>。</p>
<img src="/upload_image/image-20210110195145708.png" alt="image-20210110195145708" style="zoom: 33%;" />

<p>​    <u>—以下是一次试错记录，仅供阅读不推荐亲自尝试，直到下一次提示出现否则不要尝试—</u></p>
<p>​    下载node.js：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">wget https://nodejs.org/dist/v14.15.4/node-v14.15.4-linux-armv7l.tar.xz</span><br></pre></td></tr></table></figure>
<p>​    <em>注意将版本改为当前的最新版本，更改命令中数字即可，下面的命令全部都要作出相应修改</em></p>
<img src="/upload_image/image-20210110195755526.png" alt="image-20210110195755526" style="zoom:50%;" />

<p>​    解压二进制包：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">xz -d node-v14.15.4-linux-armv7l.tar.xz</span><br><span class="line">tar -xavf node-v14.15.4-linux-armv7l.tar</span><br></pre></td></tr></table></figure>
<p>​    删除系统内原本存在的<code>/usr/bin.node</code>:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo rm -rf /usr/bin/node</span><br><span class="line">sudo rm -rf /usr/bin/npm</span><br><span class="line"><span class="meta">#</span><span class="bash">如果不存在，忽略此步骤</span></span><br></pre></td></tr></table></figure>
<p>​    解压后将解压文件移动到<code>/usr/local/node</code>下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo mv ./node-v14.15.4-linux-armv7l /usr/local/node</span><br></pre></td></tr></table></figure>
<p>​    为node和npm建立软连接（就是上上步骤删除的那个）：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo ln -s /usr/local/node/bin/node /usr/bin/node</span><br><span class="line">sudo ln -s /usr/local/node/bin/npm /usr/bin/npm</span><br><span class="line"><span class="meta">#</span><span class="bash">这类似于Windows中的快捷方式</span></span><br></pre></td></tr></table></figure>
<p>​    查看版本号：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">node -v &amp;&amp; npm -v</span><br></pre></td></tr></table></figure>
<p>​    坑爹的来了…提示报错</p>
<p> <code>node: /usr/lib/arm-linux-gnueabihf/libstdc++.so.6: version&#39;CXXABI_1.3.9&#39;not found (required by node) </code></p>
<p> <code>node: /usr/lib/arm-linux-gnueabihf/libstdc++.so.6: version ‘GLIBCXX_3.4.21’not found (required by node)</code></p>
<img src="/upload_image/image-20210110200800909.png" alt="image-20210110200800909" style="zoom:50%;" />

<p>​    上论坛找解决方案，找到了几个跟我同病相怜的哥们：</p>
<p>​    <a href="https://github.com/nvm-sh/nvm/issues/2044">问题原因</a>&amp;<a href="https://stackoverflow.com/questions/32563173/installing-node-js-on-raspberry-pi-2">解决方案</a></p>
<p>​    <strong>原因：坑爹的树莓派老Raspbian系统不支持较新的node.js…</strong></p>
<p>​    将刚才的步骤一步步回溯：</p>
<ol>
<li><p>删除软连接：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo rm -rf /usr/bin/node</span><br><span class="line">sudo rm -rf /usr/bin/npm</span><br></pre></td></tr></table></figure></li>
<li><p>删除<code>/usr/local/node</code>下的文件</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd /usr/local</span><br><span class="line">rm -f -R -v node</span><br><span class="line"><span class="meta">#</span><span class="bash">不要再root模式下输入最后一个命令&amp;不要自行加sudo</span></span><br></pre></td></tr></table></figure>
<img src="/upload_image/image-20210110202351885.png" alt="image-20210110202351885" style="zoom:50%;" />



</li>
</ol>
<ol start="3">
<li><p>回到pi目录下，删除刚刚下载的v14.15.4的压缩包</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd ..</span><br><span class="line">cd ..</span><br><span class="line">cd home</span><br><span class="line">cd pi</span><br><span class="line">rm node-v14.15.4-linux-armv7l.tar</span><br></pre></td></tr></table></figure></li>
<li><p>下载当前系统支持的node.js版本</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">wget https://nodejs.org/download/release/v0.10.0/node-v0.10.0-linux-arm-pi.tar.gz</span><br></pre></td></tr></table></figure>
<p>解压到local文件夹下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd /usr/local/node</span><br><span class="line"></span><br><span class="line">sudo tar xzvf ~/node-v0.10.0-linux-arm-pi.tar.gz --strip=1</span><br></pre></td></tr></table></figure>
<p>检查目录内容：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ls -l</span><br></pre></td></tr></table></figure>
<img src="/upload_image/image-20210110202954600.png" alt="image-20210110202954600" style="zoom:50%;" />
</li>
<li><p>建立软连接&amp;查看版本号</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo ln -s /usr/local/node/bin/node /usr/bin/node</span><br><span class="line">sudo ln -s /usr/local/node/bin/npm /usr/bin/npm</span><br><span class="line">node -v &amp;&amp; npm -v</span><br></pre></td></tr></table></figure>
<img src="/upload_image/image-20210110203111090.png" alt="image-20210110203111090" style="zoom:50%;" />

<p>DONE！</p>
</li>
</ol>
<p>​    由于网速问题npm的包管理器的速度很慢，所以使用npm安装cnpm即淘宝源，终端输入：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm install -g cnpm --registry=https://registry.npm.taobao.org</span><br></pre></td></tr></table></figure>
<img src="/upload_image/image-20210111094319946.png" alt="image-20210111094319946" style="zoom:50%;" />

<p>​    要求<code>node&gt;= 6.0.0</code>。。。。。。</p>
<p>​    打开 <a href="https://nodejs.org/en/download/">Node.js官网</a>，点开<code>Previous Releases</code>，根据发布日期选择一个不晚于树莓派当前系统镜像制作时间的版本</p>
<img src="/upload_image/image-20210111101246619.png" alt="image-20210111101246619" style="zoom: 50%;" />

<p>​    我选的是<code>Node.js 7.3.0</code>，步骤同上述步骤1-5，如果在<code>node -v &amp;&amp; npm -v</code></p>
<img src="/upload_image/image-20210111101553050.png" alt="image-20210111101553050" style="zoom:50%;" />

<p>​    读条，煲汤…</p>
<p>​    成功之后如下：（两个WARN总感觉给自己挖了个大坑=~=|||）</p>
<img src="/upload_image/image-20210111102233699.png" alt="image-20210111102233699" style="zoom:50%;" />

<p>​    三分钟之后，果然是坑…在安装Hexo步骤时成功崩溃：Hexo安装需要有Node.js的版本支持：</p>
<img src="/upload_image/image-20210111113028964.png" alt="image-20210111113028964" style="zoom:50%;" />

<p><u>————————试错结束，正确的打开方式如下————————</u>    </p>
<p>重新安装Node.js 10.13.0，步骤上同。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo rm -rf /usr/bin/node</span><br><span class="line">sudo rm -rf /usr/bin/npm</span><br><span class="line">cd /usr/local</span><br><span class="line">rm -f -R -v node</span><br><span class="line">cd ..</span><br><span class="line">cd ..</span><br><span class="line">cd home</span><br><span class="line">cd pi</span><br><span class="line">wget https://nodejs.org/dist/v10.13.0/node-v10.13.0-linux-armv7l.tar.xz</span><br><span class="line">cd /usr/local/node</span><br><span class="line">sudo tar xavf ~/node-v10.13.0-linux-arm-pi.tar.gz --strip=1</span><br><span class="line">sudo ln -s /usr/local/node/bin/node /usr/bin/node</span><br><span class="line">sudo ln -s /usr/local/node/bin/npm /usr/bin/npm</span><br><span class="line">node -v &amp;&amp; npm -v</span><br></pre></td></tr></table></figure>
<p>​                                        <img src="/upload_image/image-20210111113144727.png" alt="image-20210111113144727" style="zoom:50%;" /></p>
<p>​    <strong>填坑小结：</strong></p>
<ol>
<li>看论坛注意时间戳，解决方案具有时效性；</li>
<li>以第一目标所需配置为目标进行检索，比如安装hexo应当优先关注的是hexo所需的版本要求而不是先根据自身硬件条件去猜支持的版本；</li>
<li>安装路径很重要，如建立软连接<code>sudo ln -s /usr/local/node/bin/node /usr/bin/node </code>，需要注意前面一个路径是否正确；如果没有设置正确，在 node -v 时会出现找不到对象；解决方法是cd到node目录下，<code>ls -l</code>查看当前文件目录，有的时候使用其他的解压文件方式会使得在node文件夹下建立了一个和压缩包同名的文件夹，按照各个博客里的命令设置软连接肯定是会撞在南墙上的。</li>
</ol>
<h3 id="安装Hexo"><a href="#安装Hexo" class="headerlink" title="安装Hexo"></a>安装Hexo</h3><p>​    <strong>方式一：cnpm/npm安装</strong></p>
<p>​    国内网速较慢，nmp包管理器的速度会较慢，利用nmp安装cnpm即淘宝源，在终端输入：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm install -g cnpm --registry=https://registry.npm.taobao.org</span><br></pre></td></tr></table></figure>
<img src="/upload_image/image-20210111114225195.png" alt="image-20210111114225195" style="zoom:50%;" />

<p>​    报错…Hexo论坛查找问题发现大多数人都遇到过，原因是安装权限不足，在命令前加上sudo即可，下面涉及安装的作同类处理</p>
<p>​                                        <img src="/upload_image/image-20210111131013291.png" alt="image-20210111131013291" style="zoom:50%;" /></p>
<p>​    为cnpm建立软连接，在终端输入：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo ln -s /usr/local/node/bin/cnpm /usr/bin/cnpm</span><br></pre></td></tr></table></figure>
<p>​    安装hexo博客框架，在终端输入：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo cnpm install -g hexo-cli</span><br></pre></td></tr></table></figure>
<img src="/upload_image/image-20210111132437986.png" alt="image-20210111132437986" style="zoom:50%;" />

<p>​    这时候输入<code>hexo -v</code>是找不到hexo的…说明安装的步骤出了问题(或者可以跳转到下文中hexo路径配置尝试，我这里选择直接换方法)</p>
<p>​    cnpm有时候确实鸡肋，因为下文npm安装下载速度并不像那些推荐cnpm的博主所说的那样慢，改用npm安装：</p>
<p>​    通过ape-get安装npm的需要下载以下nodejs的legacy：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt-get install nodejs-legacy</span><br></pre></td></tr></table></figure>
<p>​    y，回车</p>
<img src="/upload_image/image-20210111133211425.png" alt="image-20210111133211425" style="zoom:50%;" />

<p>​    虽然hexo官方的文档强烈建议<strong>不要</strong>使用 root、sudo 等方法覆盖权限，但其他方法太麻烦了，sudo走一个</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo npm install -g hexo-cli</span><br></pre></td></tr></table></figure>
<img src="/upload_image/image-20210111134702577.png" alt="image-20210111134702577" style="zoom:50%;" />

<img src="/upload_image/image-20210111141122455.png" alt="image-20210111141122455" style="zoom:50%;" />

<p>​    骂骂咧咧找问题…</p>
<p>​    第一步，先检查当前npm的镜像</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm get registry</span><br></pre></td></tr></table></figure>
<p>​    如果不是<code>https://registry.npmjs.org/</code>，终端输入<code>npm config set registry https://registry.npmjs.org/</code>从淘宝源换回官方源；</p>
<p>​    重试<code>sudo npm install -g hexo</code> ，不出意外还是失败，淦…</p>
<p>​    第二步，清除cache</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm cacha cleam --force</span><br></pre></td></tr></table></figure>
<p>​    npm官方提醒：I sure hope you know what you are doing. （=//=）</p>
<img src="/upload_image/image-20210111142126335.png" alt="image-20210111142126335" style="zoom: 80%;" />

<p>​    第三步，设置npm的官方源以防万一</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm config set registry http://registry.cnpmjs.org</span><br></pre></td></tr></table></figure>
<p>​    好了，继续</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo npm install -g hexo</span><br></pre></td></tr></table></figure>
<img src="/upload_image/image-20210111142658630.png" alt="image-20210111142658630" style="zoom:80%;" />

<p>​    胜利在望！！！！</p>
<p>​    查看hexo版本：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hexo -v</span><br></pre></td></tr></table></figure>
<img src="/upload_image/image-20210111142832673.png" alt="image-20210111142832673" style="zoom:80%;" />

<p>​    骂骂咧咧找问题*2…</p>
<p>​    【安装hexo提示command not found】</p>
<p>​    在知乎找到了答案：</p>
<img src="/upload_image/image-20210111143337916.png" alt="image-20210111143337916" style="zoom:50%;" />

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm -root -g</span><br></pre></td></tr></table></figure>
<p>​    回复：<code>/usr/local/node/lib/node_modules</code>，cd到这个目录下不停, <code>ls -l</code> 或者用VNC工具查看树莓派文件夹，目的是为了找到hexo</p>
<img src="/upload_image/image-20210111143559765.png" alt="image-20210111143559765" style="zoom:80%;" />

<p>​    路径是<code>/usr/local/node/lib/node_modules/hexo/bin/hexo</code>，我们重新设置软连接到 <code>/usr/bin/</code> 文件夹下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo ln -s /usr/local/node/lib/node_modules/hexo/bin/hexo /usr/bin/hexo</span><br></pre></td></tr></table></figure>
<p>​    查看hexo版本：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hexo -v</span><br></pre></td></tr></table></figure>
<img src="/upload_image/image-20210111143812943.png" alt="image-20210111143812943" style="zoom:80%;" />

<p>​    终于，成功了…</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>经过这一整套的折腾，发现树莓派作为博客搭载的平台确实是个很草率的决定；</p>
<p>但这一系列的折腾让我不得不又把那本Linux手册又重新捡起来复习，算是意料之外的收获；</p>
<p>考虑到接下来修改主题配置文件，如果让我重来一次我一定会选择Windows…</p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Github</tag>
        <tag>树莓派</tag>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>MSP430单片机(四)——电源管理和监控</title>
    <url>/2021/01/18/MSP430%E5%8D%95%E7%89%87%E6%9C%BA%E5%85%A5%E9%97%A8(4)%E2%80%94%E2%80%94%E7%94%B5%E6%BA%90%E7%AE%A1%E7%90%86PMM/</url>
    <content><![CDATA[<blockquote>
<p>PMM( Power Management Module )管理与电源有关的所有功能及其对设备的监控。<br>它的主要功能是首先为内核逻辑生成电源电压，其次，为监视和监视施加到设备的电压（DVCC）和为内核生成的电压（VCORE）提供几种机制。<br>本文以翻译数据手册为主，辅助理解；没什么大用，代码为Ti官方提供，直接使用即可</p>
</blockquote>
<a id="more"></a>

<h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><h4 id="电源管理和电压监控"><a href="#电源管理和电压监控" class="headerlink" title="电源管理和电压监控"></a>电源管理和电压监控</h4><p>PMM使用集成的低压差稳压器（LDO）从施加在设备上的初级电压（DVcc）产生次级核心电压（Vcore）。通常，VCORE提供CPU，存储器（闪存/ RAM）和数字模块，而DVcc提供I/O和所有模拟模块（包括振荡器）。VCORE输出使用专用参考电压进行维护。</p>
<p>内核所需的最小电压取决于所选的MCLK速率。下图显示了给定内核电压设置的系统频率与施加到器件的最低要求电压之间的关系。下图仅作为示例，应参考具体器件的数据手册来确定所支持的内核电压水平以及可能的系统性能水平。</p>
<img src="/upload_image/image-20210122091826335.png" alt="image-20210122091826335" style="zoom:50%;" />

<p>PMM模块提供了一种对DVCC和VCORE进行监督和监视的方法。这两个功能均可检测电压何时降至特定阈值以下。通常，区别在于监管导致上电复位（power-on reset，POR）事件，而监控导致产生软件可以处理的中断标志。这样，DVcc分别由高端监督（?乱翻的，和SVM作区别）器（high-side superviso，SVSH）和高端监控器（high-side monito，SVMH）进行监控。Vcore分别由低端监督器（low-side superviso，SVSL）和低端监控器（low-side monitor，SVML）进行监控。因此，有四个单独的监督/监视模块可以在任何给定时间处于活动状态。但可以使用相应的使能位（SVSHE / SVMHE / SVSLE / SVMLE）禁用每个模块，从而节省了一些功率。</p>
<h4 id="原理框图"><a href="#原理框图" class="headerlink" title="原理框图"></a>原理框图</h4><p><strong>高端SVS和SVM：</strong></p>
<img src="/upload_image/image-20210122113703508.png" alt="image-20210122113703508" style="zoom: 67%;" />

<p><strong>低端SVS和SVM：</strong></p>
<img src="/upload_image/image-20210122115155072.png" alt="image-20210122115155072" style="zoom: 67%;" />

<h4 id="寄存器"><a href="#寄存器" class="headerlink" title="寄存器"></a>寄存器</h4><p>对照框图理解下文寄存器工作原理：）</p>
<blockquote>
<p>PMMCTL0寄存器中定义的密码控制对所有PMM，SVS和SVM寄存器的访问。<br>输入正确的密码后，将启用写访问权限。 通过在字节模式下将错误密码写入PMMCTL0高字节来禁用写访问。<br>Word使用错误的密码访问PMMCTL0会触发PUC。<br>未启用写访问权限时，对除PMMCTL0以外的寄存器的写访问都会导致PUC。</p>
</blockquote>
<h5 id="电源管理模块控制寄存器0-PMMCTL0（Power-Management-Module-Control-Register-0）："><a href="#电源管理模块控制寄存器0-PMMCTL0（Power-Management-Module-Control-Register-0）：" class="headerlink" title="电源管理模块控制寄存器0 PMMCTL0（Power Management Module Control Register 0）："></a>电源管理模块控制寄存器0 PMMCTL0（Power Management Module Control Register 0）：</h5><table>
<thead>
<tr>
<th align="center">15</th>
<th align="center">14</th>
<th align="center">13</th>
<th align="center">12</th>
<th align="center">11</th>
<th align="center">10</th>
<th align="center">9</th>
<th align="center">8</th>
</tr>
</thead>
<tbody><tr>
<td align="center">rw-1</td>
<td align="center">rw-0</td>
<td align="center">rw-0</td>
<td align="center">rw-1</td>
<td align="center">rw-0</td>
<td align="center">rw-1</td>
<td align="center">rw-1</td>
<td align="center">rw-0</td>
</tr>
</tbody></table>
<p><strong>PMMPW</strong>              15-8位        PMM密码，始终读为096h，必须写入0A5h或生成PUC。</p>
<table>
<thead>
<tr>
<th align="center">7</th>
<th align="center">6</th>
<th align="center">5</th>
<th align="center">4</th>
<th align="center">3</th>
<th align="center">2</th>
<th align="center">1</th>
<th align="center">0</th>
</tr>
</thead>
<tbody><tr>
<td align="center">PMMHPMRE</td>
<td align="center">Reserved</td>
<td align="center">Reserved</td>
<td align="center">PMMREGOFF</td>
<td align="center">PMMSWPOR</td>
<td align="center">PMMSWBOR</td>
<td align="center">PMMCOREV</td>
<td align="center">PMMCOREV</td>
</tr>
<tr>
<td align="center">rw-0</td>
<td align="center">r-0</td>
<td align="center">r-0</td>
<td align="center">rw-0</td>
<td align="center">rw-0</td>
<td align="center">rw-0</td>
<td align="center">rw-[0]</td>
<td align="center">rw-[0]</td>
</tr>
</tbody></table>
<p><strong>PMMHPMRE</strong>         位7            全局大功率模块请求使能。如果PMMHPMRE置1，则任何模块都可以请求PMM高功率模式。<br><strong>Reserved</strong>              位6-5         保留。始终读取0。<br><strong>PMMREGOFF</strong>       位4            稳压器关闭（有关更多详细信息，参考SYS章）<br><strong>PMMSWPOR</strong>        位3            软件上电复位。将该位置1将触发POR。这一点是自我清除。<br><strong>PMMSWBOR</strong>        位2            软件掉电复位。将该位置1可触发BOR。这一点是自我清除。<br><strong>PMMCOREV</strong>         位1-0         内核电压（有关支持的电平和相应电压，请参见器件特定的数据手册）<br>​                                                00 VCORE电平0<br>​                                                01 VCORE电平1<br>​                                                10 VCORE电平2<br>​                                                11 VCORE电平3</p>
<hr>
<h5 id="高端监控寄存器-SVSMHCTL（Supply-Voltage-Supervisor-and-Monitor-High-Side-Control-Register）："><a href="#高端监控寄存器-SVSMHCTL（Supply-Voltage-Supervisor-and-Monitor-High-Side-Control-Register）：" class="headerlink" title="高端监控寄存器 SVSMHCTL（Supply Voltage Supervisor and Monitor High-Side Control Register）："></a>高端监控寄存器 SVSMHCTL（Supply Voltage Supervisor and Monitor High-Side Control Register）：</h5><table>
<thead>
<tr>
<th align="center">15</th>
<th align="center">14</th>
<th align="center">13</th>
<th align="center">12</th>
<th align="center">11</th>
<th align="center">10</th>
<th align="center">9</th>
<th align="center">8</th>
</tr>
</thead>
<tbody><tr>
<td align="center">SVMHFP</td>
<td align="center">SVMHE</td>
<td align="center">Reserved</td>
<td align="center">SVMHOVPE</td>
<td align="center">SVSHFP</td>
<td align="center">SVSHE</td>
<td align="center">SVSHRVL</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">rw-0</td>
<td align="center">rw-1</td>
<td align="center">rw-0</td>
<td align="center">rw-0</td>
<td align="center">rw-0</td>
<td align="center">rw-1</td>
<td align="center">rw-0</td>
<td align="center">rw-0</td>
</tr>
</tbody></table>
<p><strong>SVMHFP</strong>             位15             SVM高端全性能模式。如果该位置1，则SVMH以全性能模式运行。<br>                                                       0-正常模式。<br>                                                       1-全性能模式。<br><strong>SVMHE</strong>               位14             SVM高端使能。如果该位置1，则启用SVMH。<br><strong>Reserved</strong>            位13             保留。始终读取0。<br><strong>SVMHOVPE</strong>       位12             SVM高端过压使能。如果该位置1，则启用SVMH过压检测。如果还设置了SVMHVLRPE，则在过压条件下会发生POR。<br><strong>SVSHFP</strong>             位11             SVS高端全性能模式。如果该位置1，则SVSH处于全性能模式。<br>                                                       0-正常模式。<br>                                                       1-全性能模式。<br><strong>SVSHE</strong>                位10             SVS高端使能。如果该位置1，则启用SVSH。<br><strong>SVSHRVL</strong>           位9-8            SVS高端复位电压电平。如果DVcc低于SVSHRVL选择的SVSH电压电平，则触发复位（如果SVSHPE = 1）。电压等级见手册。</p>
<table>
<thead>
<tr>
<th align="center">7</th>
<th align="center">6</th>
<th align="center">5</th>
<th align="center">4</th>
<th align="center">3</th>
<th align="center">2</th>
<th align="center">1</th>
<th align="center">0</th>
</tr>
</thead>
<tbody><tr>
<td align="center">SVSMHACE</td>
<td align="center">SVSMHEVM</td>
<td align="center">Reserved</td>
<td align="center">SVSHMD</td>
<td align="center">SVSMHDLYST</td>
<td align="center">SVSMHRRL</td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">rw-0</td>
<td align="center">rw-0</td>
<td align="center">rw-0</td>
<td align="center">rw-0</td>
<td align="center">rw-0</td>
<td align="center">rw-0</td>
<td align="center">rw-0</td>
<td align="center">rw-0</td>
</tr>
</tbody></table>
<p><strong>SVSMHACE</strong>         位7             SVS和SVM高端自动控制使能。 如果该位置1，则SVSH和SVMH电路的低功耗模式处于硬件控制之下。<br><strong>SVSMHEVM</strong>         位6             SVS和SVM高端事件掩码。 如果该位置1，则SVSH和SVMH事件被屏蔽。<br>                                                       0-没有任何事件被屏蔽。<br>                                                       1-所有事件均被屏蔽。<br><strong>Reserved</strong>             位5             保留。 始终读取0。<br><strong>SVSHMD</strong>              位4             SVS高端模式。 如果该位置1，则在掉电情况下，在LPM2，LPM3和LPM4中设置SVSH中断标志。 如果未设置此位，则不会在LPM2，LPM3和LPM4中设置SVSH中断。<br><strong>SVSMHDLYST</strong>     位3             SVS和SVM高端延迟状态。该位置1则SVSH和SVMH事件将被屏蔽一段时间。 延迟时间取决于SVSH和SVMH的电源模式。 如果SVMHFP = 1和SVSHFP = 1，即全性能模式，则延迟会更短。如果延迟已过期，则该位将由硬件清除。<br><strong>SVSMHRRL</strong>         位2-0          SVS和SVM高端复位释放电压电平，这些位定义了SVSH的复位释放电压电平。SVMH还可以使用它来定义达到的电压水平。</p>
<hr>
<h5 id="低端监控寄存器-SVSMLCTL（Supply-Voltage-Supervisor-and-Monitor-Low-Side-Control-Register-）："><a href="#低端监控寄存器-SVSMLCTL（Supply-Voltage-Supervisor-and-Monitor-Low-Side-Control-Register-）：" class="headerlink" title="低端监控寄存器 SVSMLCTL（Supply Voltage Supervisor and Monitor Low-Side Control Register ）："></a>低端监控寄存器 SVSMLCTL（Supply Voltage Supervisor and Monitor Low-Side Control Register ）：</h5><table>
<thead>
<tr>
<th align="center">15</th>
<th align="center">14</th>
<th align="center">13</th>
<th align="center">12</th>
<th align="center">11</th>
<th align="center">10</th>
<th align="center">9</th>
<th align="center">8</th>
</tr>
</thead>
<tbody><tr>
<td align="center">SVMLFP</td>
<td align="center">SVMLE</td>
<td align="center">Reserved</td>
<td align="center">SVMLOVPE</td>
<td align="center">SVSLFP</td>
<td align="center">SVSLE</td>
<td align="center">SVSLRVL</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">rw-0</td>
<td align="center">rw-1</td>
<td align="center">rw-0</td>
<td align="center">rw-0</td>
<td align="center">rw-0</td>
<td align="center">rw-1</td>
<td align="center">rw-0</td>
<td align="center">rw-0</td>
</tr>
</tbody></table>
<p><strong>SVMLFP</strong>             位15             SVM低端全性能模式。如果该位置1，则SVML以全性能模式运行。<br>                                                       0-正常模式。<br>                                                       1-全性能模式。<br><strong>SVMLE</strong>               位14             SVM低端使能。如果该位置1，则启用SVML。<br><strong>Reserved</strong>           位13             保留。始终读取0。<br><strong>SVMLOVPE</strong>       位12             SVM低端过压使能。如果该位置1，则启用SVML过压检测。<br><strong>SVSLFP</strong>             位11             SVS低端全性能模式。如果该位置1，则SVSL处于全性能模式。<br>                                                       0-正常模式。<br>                                                       1-全性能模式。<br><strong>SVSLE</strong>                位10             SVS低端使能。如果该位置1，则启用SVSL。<br><strong>SVSLRVL</strong>           位9-8            SVS低端复位电压电平。如果DVcc低于SVSHRVL选择的SVSL电压电平，则触发复位（如果SVSLPE = 1）。 </p>
<table>
<thead>
<tr>
<th align="center">7</th>
<th align="center">6</th>
<th align="center">5</th>
<th align="center">4</th>
<th align="center">3</th>
<th align="center">2</th>
<th align="center">1</th>
<th align="center">0</th>
</tr>
</thead>
<tbody><tr>
<td align="center">SVSMLACE</td>
<td align="center">SVSMLEVM</td>
<td align="center">Reserved</td>
<td align="center">SVSLMD</td>
<td align="center">SVSMLDLYST</td>
<td align="center">SVSMLRRL</td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">rw-0</td>
<td align="center">rw-0</td>
<td align="center">rw-0</td>
<td align="center">rw-0</td>
<td align="center">rw-0</td>
<td align="center">rw-0</td>
<td align="center">rw-0</td>
<td align="center">rw-0</td>
</tr>
</tbody></table>
<p><strong>SVSMLACE</strong>         位7             SVS和SVM低端自动控制使能。 如果该位置1，则SVSL和SVML电路的低功耗模式处于硬件控制之下。<br><strong>SVSMLEVM</strong>         位6             SVS和SVM低端事件掩码。 如果该位置1，则SVSL和SVML事件被屏蔽。<br>                                                       0-没有任何事件被屏蔽。<br>                                                       1-所有事件均被屏蔽。<br><strong>Reserved</strong>             位5             保留。始终读取0。<br><strong>SVSLMD</strong>              位4             SVS低端模式。如果该位置1，则在掉电情况下，在LPM2，LPM3和LPM4中设置SVSL中断标志。 如果未设置此位，则不会在LPM2，LPM3和LPM4中设置SVSL中断。<br><strong>SVSMLDLYST</strong>     位3             SVS和SVM低端延迟状态。如果该位置1，则SVSL和SVML事件将被屏蔽一段时间。 延迟时间取决于SVSL和SVML的电源模式。 如果SVMLFP = 1和SVSLFP = 1，即全性能模式，则延迟会更短。如果延迟已过期，则该位将由硬件清除。<br><strong>SVSMLRRL</strong>         位2-0          SVS和SVM低端复位释放电压电平，这些位定义了SVSL的复位释放电压电平。SVML还可以使用它来定义达到的电压水平。 </p>
<hr>
<h5 id="电源管理模块中断标志寄存器-PMMIFG（Power-Management-Module-Interrupt-Flag-Register）"><a href="#电源管理模块中断标志寄存器-PMMIFG（Power-Management-Module-Interrupt-Flag-Register）" class="headerlink" title="电源管理模块中断标志寄存器 PMMIFG（Power Management Module Interrupt Flag Register）"></a>电源管理模块中断标志寄存器 PMMIFG（Power Management Module Interrupt Flag Register）</h5><table>
<thead>
<tr>
<th align="center">15</th>
<th align="center">14</th>
<th align="center">13</th>
<th align="center">12</th>
<th align="center">11</th>
<th align="center">10</th>
<th align="center">9</th>
<th align="center">8</th>
</tr>
</thead>
<tbody><tr>
<td align="center">PMMLPM5IFG</td>
<td align="center">Reserved</td>
<td align="center">SVSLIFG</td>
<td align="center">SVSHFG</td>
<td align="center">Reserved</td>
<td align="center">PMMPORIFG</td>
<td align="center">PMMRSTIFG</td>
<td align="center">PMMBORIFG</td>
</tr>
<tr>
<td align="center">rw-0</td>
<td align="center">rw-0</td>
<td align="center">rw-0</td>
<td align="center">rw-0</td>
<td align="center">rw-0</td>
<td align="center">rw-0</td>
<td align="center">rw-0</td>
<td align="center">rw-0</td>
</tr>
</tbody></table>
<p><strong>PMMLPM5IFG</strong>        位15        LPM5标志。如果系统以前在LPM5中，则该位置1。该位可通过软件或通过读取复位向量字来清除。DVcc域上的电源故障将清除该位。<br>                                                           0-没有待处理的中断<br>                                                           1-待处理的中断<br><strong>Reserved</strong>                位14        始终读取0。<br><strong>SVSLIFG</strong>                位13         SVS低端中断标志。该位可通过软件或通过读取复位向量字来清除。<br>                                                           0-没有待处理的中断<br>                                                           1-待处理的中断<br><strong>SVSHIFG</strong>                位12         SVS高侧中断标志。该位可通过软件或通过读取复位向量字来清除。<br>                                                           0-没有待处理的中断<br>                                                           1-待处理的中断<br><strong>Reserved</strong>                 位11        保留。始终读取0。<br><strong>PMMPORIFG</strong>            位10       PMM软件上电复位中断标志。如果触发了软件POR，则设置该中断标志。该位可通过软件或通过读取复位向量字来清除。<br>                                                           0-没有待处理的中断<br>                                                           1-待处理的中断<br><strong>PMMRSTIFG</strong>            位9         PMM复位引脚中断标志。 如果RST / NMI引脚为复位源，则设置该中断标志。 该位可通过软件或通过读取复位向量字来清除。<br>                                                           0-没有待处理的中断<br>                                                           1-待处理的中断<br><strong>PMMBORIFG</strong>            位8         PMM软件掉电复位中断标志。如果触发了软件BOR(PMMSWBOR)，则设置该中断标志。该位可通过软件或通过读取复位向量字来清除。<br>                                                           0-无中断待决<br>                                                           1-中断待决</p>
<table>
<thead>
<tr>
<th align="center">7</th>
<th align="center">6</th>
<th align="center">5</th>
<th align="center">4</th>
<th align="center">3</th>
<th align="center">2</th>
<th align="center">1</th>
<th align="center">0</th>
</tr>
</thead>
<tbody><tr>
<td align="center">Reserved</td>
<td align="center">SVMHVLRIFG</td>
<td align="center">SVMHIFG</td>
<td align="center">SVSMHDLYIFG</td>
<td align="center">Reserved</td>
<td align="center">SVMLVLRIFG</td>
<td align="center">SVMLIFG</td>
<td align="center">SVSMLDLYIFG</td>
</tr>
<tr>
<td align="center">rw-0</td>
<td align="center">rw-0</td>
<td align="center">rw-0</td>
<td align="center">rw-0</td>
<td align="center">rw-0</td>
<td align="center">rw-0</td>
<td align="center">rw-0</td>
<td align="center">rw-0</td>
</tr>
</tbody></table>
<p><strong>Reserved</strong>            位7            保留。始终读取0。<br><strong>SVMHVLRIFG</strong>    位6             SVM高端电压电平达到中断标志。该位可通过软件或通过读取复位向量（SVSHPE = 1）字或通过读取中断向量（SVSHPE = 0）字来清除。<br>                                                       0-没有待处理的中断<br>                                                       1-待处理的中断<br><strong>SVMHIFG</strong>               位5          SVM高侧中断标志。 该位由软件清除。<br>                                                       0-没有待处理的中断<br>                                                       1-待处理的中断<br><strong>SVSMHDLYIFG</strong>      位4          SVS和SVM高侧延迟已到期的中断标志。如果延迟元素过期，则设置该中断标志。该位通过软件或读取中断向量字清除。<br>                                                       0-没有待处理的中断<br>                                                       1-待处理的中断<br><strong>Reserved</strong>                位3         保留。始终读取0。<br><strong>SVMLVLRIFG</strong>         位2         SVM低侧电压电平已达到中断标志。该位可通过软件或通过读取复位向量（SVSLPE = 1）字或通过读取中断向量（SVSLPE = 0）字来清除。<br>                                                       0-无中断待决<br>                                                       1-中断待决<br><strong>SVMLIFG</strong>                 位1         SVM低端中断标志。 该位由软件清除。<br>                                                       0-无待处理的中断<br>                                                       1-待处理的中断<br><strong>SVSMLDLYIFG</strong>        位0         SVS和SVM低端延迟已过期的中断标志。 如果延迟元素过期，则设置该中断标志。该位通过软件或读取中断向量字清除。<br>                                                       0-无中断待决<br>                                                       1-中断待决</p>
<h3 id="PMM-操作"><a href="#PMM-操作" class="headerlink" title="PMM 操作"></a>PMM 操作</h3><h4 id="PMM操作流程"><a href="#PMM操作流程" class="headerlink" title="PMM操作流程"></a>PMM操作流程</h4><p>至关重要的是，<strong>VCORE级别一次只能增加一个级别</strong>，以下步骤1至4显示了将VCORE增加一级的过程。重复此顺序以更改VCORE级别，直到获得目标级别为止：</p>
<ol>
<li>将SVMH和SVSH编程到下一个级别，以确保DVCC对于下一个VCORE级别足够高。</li>
<li>将SVML编程到下一个级别，然后等待（SVSMLDLYIFG）设置；</li>
<li>将PMMCOREV编程到下一个VCORE级别；</li>
<li>等待达到电压电平（SVMLVLRIFG）标志；</li>
<li>将SVSL编程到下一个级别。</li>
</ol>
<h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><p>寄存器的结果见注释，//开头的注释为官方注释，/* */注释为添加的解释</p>
<p>总结：<strong>直接用即可…</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*              TI官方VCORE升级函数         */</span></span><br><span class="line"><span class="comment">/*          VCORE级别一次只能增加一个级别    */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SetVcoreUp</span> <span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> level)</span>            </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> 1  <span class="comment">//仿真时修改为0，否则会卡在死循环里</span></span></span><br><span class="line">  <span class="comment">// Open PMM registers for write</span></span><br><span class="line">  <span class="comment">/*	PMMCTL0高八位设0xA5设置电源管理模块控制寄存器为写入模式		*/</span></span><br><span class="line">  PMMCTL0_H = PMMPW_H;</span><br><span class="line">  <span class="comment">// Set SVS/SVM high side new level</span></span><br><span class="line">  <span class="comment">/*0X0400u + 0x0100u*level + 0x4000u + 0x0001u*level*/</span></span><br><span class="line">  <span class="comment">/*level 1：0100 0101 0000 0001 启用SVMH，启用SVSH，SVS高端复位电平设置01，SVSH复位释放电压电平为01*/</span></span><br><span class="line">  <span class="comment">/*level 2：0100 0110 0000 0010 启用SVMH，启用SVSH，SVS高端复位电平设置10，SVSH复位释放电压电平为10*/</span></span><br><span class="line">  <span class="comment">/*level 3：0100 0111 0000 0011 启用SVMH，启用SVSH，SVS高端复位电平设置11，SVSH复位释放电压电平为11*/</span></span><br><span class="line">  SVSMHCTL = SVSHE + SVSHRVL0 * level + SVMHE + SVSMHRRL0 * level;</span><br><span class="line">  <span class="comment">// Set SVM low side to new level</span></span><br><span class="line">  <span class="comment">/*	0x400u + 0x4000u + 0x0001u*level	*/</span></span><br><span class="line">  <span class="comment">/*level 1：0100 0100 0000 0001 启用SVML，启用SVSL，SVS高端复位电平设置01，SVSH复位释放电压电平为01*/</span></span><br><span class="line">  <span class="comment">/*level 2：0100 0100 0000 0010 启用SVML，启用SVSL，SVS高端复位电平设置10，SVSH复位释放电压电平为10*/</span></span><br><span class="line">  <span class="comment">/*level 3：0100 0100 0000 0011 启用SVML，启用SVSL，SVS高端复位电平设置11，SVSH复位释放电压电平为11*/</span>  </span><br><span class="line">  SVSMLCTL = SVSLE + SVMLE + SVSMLRRL0 * level;</span><br><span class="line">  <span class="comment">// Wait till SVM is settled</span></span><br><span class="line">  <span class="keyword">while</span> ((PMMIFG &amp; SVSMLDLYIFG) == <span class="number">0</span>);</span><br><span class="line">  <span class="comment">// Clear already set flags</span></span><br><span class="line">  PMMIFG &amp;= ~(SVMLVLRIFG + SVMLIFG);</span><br><span class="line">  <span class="comment">// Set VCore to new level</span></span><br><span class="line">  <span class="comment">/*	PMMCTL0低八位设置	*/</span></span><br><span class="line">  PMMCTL0_L = PMMCOREV0 * level;</span><br><span class="line">  <span class="comment">// Wait till new level reached</span></span><br><span class="line">  <span class="keyword">if</span> ((PMMIFG &amp; SVMLIFG))</span><br><span class="line">    <span class="keyword">while</span> ((PMMIFG &amp; SVMLVLRIFG) == <span class="number">0</span>);</span><br><span class="line">  <span class="comment">// Set SVS/SVM low side to new level</span></span><br><span class="line">  SVSMLCTL = SVSLE + SVSLRVL0 * level + SVMLE + SVSMLRRL0 * level;</span><br><span class="line">  <span class="comment">// Lock PMM registers for write access</span></span><br><span class="line">  PMMCTL0_H = <span class="number">0x00</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​    上述代码为Ti官方提供的PMM代码，除了打开SVM / SVS和控制Vcore以外其余都是默认，在电源控制寄存器里还有其他有意思的设置，如下：</p>
<table>
<thead>
<tr>
<th align="center">功能</th>
<th align="center">寄存器( *表示H/L )</th>
<th align="center">Bit</th>
</tr>
</thead>
<tbody><tr>
<td align="center">SVM全性能模式</td>
<td align="center">SVSM * CTL</td>
<td align="center">Bit 15</td>
</tr>
<tr>
<td align="center">SVS全性能模式</td>
<td align="center">SVSM * CTL</td>
<td align="center">Bit 11</td>
</tr>
<tr>
<td align="center">SVS和SVM自动控制使能(低功耗由硬件控制)</td>
<td align="center">SVSM * ACE</td>
<td align="center">Bit7</td>
</tr>
</tbody></table>
<p>调用时注意只能一级一级地升：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">SetVcoreUp(<span class="number">1</span>);</span><br><span class="line">SetVcoreUp(<span class="number">2</span>);</span><br><span class="line">SetVcoreUp(<span class="number">3</span>);</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>嵌入式开发</category>
      </categories>
      <tags>
        <tag>嵌入式</tag>
        <tag>MSP430</tag>
        <tag>C/C++</tag>
        <tag>IAR</tag>
      </tags>
  </entry>
  <entry>
    <title>树莓派安装motion的问题</title>
    <url>/2021/01/27/%E8%A7%A3%E5%86%B3%E6%A0%91%E8%8E%93%E6%B4%BE%E5%AE%89%E8%A3%85motion%E7%9A%84%E4%BE%9D%E8%B5%96%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<p>在安装motion的时候出现了依赖错误的问题</p>
<a id="more"></a>

<p><img src="/upload_image/image-20210127163232404.png" alt="image-20210127163232404"></p>
<p>解决方法是把更换的清华源再更改回树莓派的官方源就可以了…</p>
<p><strong>接下来就是motion的安装：</strong></p>
<p>步骤一：修改树莓派显存</p>
<p>​     <code>sudo nano /boot/config.txt</code> ，修改 <code>gpu_mem=256</code> ，Ctrl+x ，Y，回车.</p>
<p>步骤二：安装命令</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt-get install ffmpeg v4l-utils (脚本里有安装,保险起见再来一次)</span><br><span class="line">sudo apt-get install libmariadbclient18 libpq5 (脚本里有安装,保险起见再来一次)</span><br><span class="line">sudo apt-get install python-pip python-dev libssl-dev (脚本里有安装,保险起见再来一次)</span><br><span class="line">sudo apt-get install motion</span><br></pre></td></tr></table></figure>
<p>步骤三：参数配置</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo nano /etc/default/motion</span><br></pre></td></tr></table></figure>
<p>＃no修改成yes:<br><code>start_motion_daemon=yes</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo nano /etc/motion/motion.conf</span><br></pre></td></tr></table></figure>
<p>daemon off 改成 on<br>stream_localhost on 改成 off ,其它电脑就可以访问摄像头了(这个文件的非常后面，一直PgDn直到看到 <code>stream_port</code> 停止往下翻两页就到)</p>
<p>启动motion服务：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo service motion start</span><br><span class="line">sudo motion</span><br></pre></td></tr></table></figure>
<p>关闭motion的命令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo killall -TERM motion</span><br></pre></td></tr></table></figure>
<p><strong>遇到motion很卡的情况解决方法：</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo nano /etc/motion/motion.conf</span><br></pre></td></tr></table></figure>
<ol>
<li><code>daemon</code> 的值修改为 <code>on</code>，让 motion 后台运行</li>
<li><code>rotate</code> 旋转画面，如果需要90°、180°旋转，可以在这里配置</li>
<li><code>width</code> 和 <code>height</code> 修改画面分辨率（默认为 320*240 像素），我修改成了 <code>800</code> 和 <code>600</code></li>
<li><code>framerate</code> 捕获的帧率，我修改为了 <code>300</code></li>
<li><code>stream_maxrate</code> 修改流的帧率，在配置文件的非常后面，这个默认值是 1，所以画面会变成PPT，我这里修改成了 100</li>
<li><code>stream_localhost</code> 的值修改为 <code>off</code>，允许通过非 localhost 来查看视频</li>
</ol>
<p>其余配置如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">daemon=on</span><br><span class="line">norm=3</span><br><span class="line">input=8</span><br><span class="line">auto_brightness=off			#自动曝光，别开</span><br><span class="line">framerate=300</span><br><span class="line">height=600</span><br><span class="line">width=800</span><br><span class="line">jpeg_filename=motion/%Y%m%d/%v-%H%M%S-%q</span><br><span class="line">noise_tune=on</span><br><span class="line">output_all=off</span><br><span class="line">output_motion=on</span><br><span class="line">output_normal=on</span><br><span class="line">quality=1000</span><br><span class="line">snapshot_interval=500</span><br><span class="line">target_dir=/home/pi/motion</span><br><span class="line">text_left=(c) Nestcam</span><br><span class="line">text_right=%d %b %Y\n%k:%M:%S</span><br><span class="line">threshold=500</span><br></pre></td></tr></table></figure>
<p>每次修改完配置后都需要将motion关闭 <code>sudo killall -TEMP motion</code> ，然后重启motion <code>sudo motion</code> 即可。</p>
<p><strong>完整的shell安装过程（不必下拉，无后文）：</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">pi@raspberrypi:~ $ sudo nano /etc/apt/sources.list</span><br><span class="line">pi@raspberrypi:~ $ sudo apt-get install motion</span><br><span class="line">正在读取软件包列表... 完成</span><br><span class="line">正在分析软件包的依赖关系树</span><br><span class="line">正在读取状态信息... 完成</span><br><span class="line">E: 未发现软件包 motion</span><br><span class="line">pi@raspberrypi:~ $ sudo apt-get update</span><br><span class="line">命中 http://mirrors.ustc.edu.cn buster InRelease</span><br><span class="line">命中 http://mirrors.ustc.edu.cn buster/main armhf Packages</span><br><span class="line">命中 http://mirrors.ustc.edu.cn buster/ui armhf Packages</span><br><span class="line">获取：1 http://mirrordirector.raspbian.org jessie InRelease [15.0 kB]</span><br><span class="line">获取：2 http://archive.raspbian.org jessie InRelease [15.0 kB]</span><br><span class="line">忽略 http://mirrors.ustc.edu.cn buster/main Translation-zh_CN</span><br><span class="line">忽略 http://mirrors.ustc.edu.cn buster/main Translation-zh</span><br><span class="line">忽略 http://mirrors.ustc.edu.cn buster/main Translation-en</span><br><span class="line">忽略 http://mirrors.ustc.edu.cn buster/ui Translation-zh_CN</span><br><span class="line">忽略 http://mirrors.ustc.edu.cn buster/ui Translation-zh</span><br><span class="line">忽略 http://mirrors.ustc.edu.cn buster/ui Translation-en</span><br><span class="line">获取：3 http://archive.raspbian.org jessie/main Sources [7,767 kB]</span><br><span class="line">获取：4 http://mirrordirector.raspbian.org jessie/main armhf Packages [9,539 kB]</span><br><span class="line">获取：5 http://mirrordirector.raspbian.org jessie/contrib armhf Packages [43.3 kB]</span><br><span class="line">获取：6 http://mirrordirector.raspbian.org jessie/non-free armhf Packages [88.2 kB]</span><br><span class="line">获取：7 http://mirrordirector.raspbian.org jessie/rpi armhf Packages [1,356 B]</span><br><span class="line">忽略 http://mirrordirector.raspbian.org jessie/contrib Translation-zh_CN</span><br><span class="line">忽略 http://mirrordirector.raspbian.org jessie/contrib Translation-zh</span><br><span class="line">忽略 http://mirrordirector.raspbian.org jessie/contrib Translation-en</span><br><span class="line">忽略 http://mirrordirector.raspbian.org jessie/main Translation-zh_CN</span><br><span class="line">忽略 http://mirrordirector.raspbian.org jessie/main Translation-zh</span><br><span class="line">忽略 http://mirrordirector.raspbian.org jessie/main Translation-en</span><br><span class="line">忽略 http://mirrordirector.raspbian.org jessie/non-free Translation-zh_CN</span><br><span class="line">忽略 http://mirrordirector.raspbian.org jessie/non-free Translation-zh</span><br><span class="line">忽略 http://mirrordirector.raspbian.org jessie/non-free Translation-en</span><br><span class="line">忽略 http://mirrordirector.raspbian.org jessie/rpi Translation-zh_CN</span><br><span class="line">忽略 http://mirrordirector.raspbian.org jessie/rpi Translation-zh</span><br><span class="line">忽略 http://mirrordirector.raspbian.org jessie/rpi Translation-en</span><br><span class="line">获取：8 http://archive.raspbian.org jessie/contrib Sources [64.5 kB]</span><br><span class="line">获取：9 http://archive.raspbian.org jessie/non-free Sources [113 kB]</span><br><span class="line">获取：10 http://archive.raspbian.org jessie/rpi Sources [1,132 B]</span><br><span class="line">下载 17.6 MB，耗时 26分 25秒 (11.1 kB/s)</span><br><span class="line">正在读取软件包列表... 完成</span><br><span class="line">pi@raspberrypi:~ $ apt-get upgrade -y</span><br><span class="line">E: 无法打开锁文件 /var/lib/dpkg/lock - open (13: 权限不够)</span><br><span class="line">E: 无法对状态列表目录加锁(/var/lib/dpkg/)，请查看您是否正以 root 用户运行？</span><br><span class="line">pi@raspberrypi:~ $ sudo apt-get upgrade -y</span><br><span class="line">正在读取软件包列表... 完成</span><br><span class="line">正在分析软件包的依赖关系树</span><br><span class="line">正在读取状态信息... 完成</span><br><span class="line">正在对升级进行计算... 下列软件包是自动安装的并且现在不需要了：</span><br><span class="line">  libasprintf0c2 libboost-filesystem1.55.0 libboost-program-options1.55.0</span><br><span class="line">  libboost-regex1.55.0 lxkeymap python-gobject python-xklavier tcpd</span><br><span class="line">使用&#x27;apt-get autoremove&#x27;来卸载它(它们)。</span><br><span class="line">完成</span><br><span class="line">下列软件包的版本将保持不变：</span><br><span class="line">  bluej bluez chromium-browser dhcpcd5 firmware-ralink gir1.2-gtk-3.0</span><br><span class="line">  greenfoot gstreamer1.0-omx gstreamer1.0-plugins-good libasound2</span><br><span class="line">  libasound2-data libcairo2 libcupsfilters1 libdrm-amdgpu1 libdrm2</span><br><span class="line">  libegl1-mesa libfm-gtk4 libfm-modules libfm4 libgbm1 libgl1-mesa-dri</span><br><span class="line">  libgl1-mesa-glx libglapi-mesa libgles2-mesa libgtk-3-0 libgtk-3-bin</span><br><span class="line">  libgtk2.0-0 libgtk2.0-bin libpam-modules libpam-modules-bin libplymouth4</span><br><span class="line">  libpolkit-agent-1-0 libpolkit-backend-1-0 libpolkit-gobject-1-0 libpulse0</span><br><span class="line">  libpulsedsp libreoffice libreoffice-avmedia-backend-gstreamer</span><br><span class="line">  libreoffice-base libreoffice-base-core libreoffice-base-drivers</span><br><span class="line">  libreoffice-calc libreoffice-common libreoffice-core libreoffice-draw</span><br><span class="line">  libreoffice-impress libreoffice-java-common libreoffice-math</span><br><span class="line">  libreoffice-report-builder-bin libreoffice-sdbc-hsqldb libreoffice-writer</span><br><span class="line">  librtimulib-dev librtimulib-utils librtimulib7 libsdl1.2debian</span><br><span class="line">  libwayland-egl1-mesa lxappearance-obconf lxinput lxpanel lxpanel-data</span><br><span class="line">  lxsession lxterminal mesa-va-drivers nodered omxplayer openbox openssl</span><br><span class="line">  pcmanfm pi-bluetooth pi-package pi-package-data pi-package-session piclone</span><br><span class="line">  pigpio pimixer pix-icons pix-plym-splash plymouth plymouth-themes</span><br><span class="line">  policykit-1 pulseaudio pulseaudio-module-bluetooth pulseaudio-utils</span><br><span class="line">  python-gpiozero python-openssl python-pip python-rpi.gpio python-rtimulib</span><br><span class="line">  python3-gpiozero python3-openssl python3-pip python3-rpi.gpio</span><br><span class="line">  python3-rtimulib python3-spidev python3-uno raspberrypi-net-mods</span><br><span class="line">  raspberrypi-sys-mods raspberrypi-ui-mods rpi-chromium-mods sense-emu-tools</span><br><span class="line">  uno-libs3 ure wolfram-engine x11-xserver-utils xserver-xorg-core</span><br><span class="line">  xserver-xorg-video-fbturbo</span><br><span class="line">升级了 0 个软件包，新安装了 0 个软件包，要卸载 0 个软件包，有 106 个软件包未被升级。</span><br><span class="line">有 34 个软件包没有被完全安装或卸载。</span><br><span class="line">解压缩后会消耗掉 0 B 的额外空间。</span><br><span class="line">正在设置 console-setup-linux (1.193~deb10u1) ...</span><br><span class="line">insserv: FATAL: service udev is missed in the runlevels 2 3 4 5 to use service raspi-config</span><br><span class="line">insserv: exiting now!</span><br><span class="line">update-rc.d: error: insserv rejected the script header</span><br><span class="line">dpkg: 处理软件包 console-setup-linux (--configure)时出错：</span><br><span class="line"> 子进程 已安装 post-installation 脚本 返回错误状态 1</span><br><span class="line">dpkg: 依赖关系问题使得 console-setup 的配置工作不能继续：</span><br><span class="line"> console-setup 依赖于 console-setup-linux | console-setup-freebsd | hurd；然而：</span><br><span class="line">  软件包 console-setup-linux 尚未配置。</span><br><span class="line">  未安装软件包 console-setup-freebsd。</span><br><span class="line">  未安装软件包 hurd。</span><br><span class="line"></span><br><span class="line">dpkg: 处理软件包 console-setup (--configure)时出错：</span><br><span class="line"> 依赖关系问题 - 仍未被配置</span><br><span class="line">正在设置 x11-common (1:7.7+19) ...</span><br><span class="line">update-rc.d: warning: start and stop actions are no longer supported; falling back to defaults</span><br><span class="line">insserv: FATAL: service udev is missed in the runlevels 2 3 4 5 to use service raspi-config</span><br><span class="line">insserv: exiting now!</span><br><span class="line">update-rc.d: error: insserv rejected the script header</span><br><span class="line">dpkg: 处理软件包 x11-common (--configure)时出错：</span><br><span class="line"> 子进程 已安装 post-installation 脚本 返回错误状态 1</span><br><span class="line">dpkg: 依赖关系问题使得 libxss1:armhf 的配置工作不能继续：</span><br><span class="line"> libxss1:armhf 依赖于 x11-common；然而：</span><br><span class="line">  软件包 x11-common 尚未配置。</span><br><span class="line"></span><br><span class="line">dpkg: 处理软件包 libxss1:armhf (--configure)时出错：</span><br><span class="line"> 依赖关系问题 - 仍未被配置</span><br><span class="line">dpkg: 依赖关系问题使得 libtk8.6:armhf 的配置工作不能继续：</span><br><span class="line"> libtk8.6:armhf 依赖于 libxss1；然而：</span><br><span class="line">  软件包 libxss1:armhf 尚未配置。</span><br><span class="line"></span><br><span class="line">dpkg: 处理软件包 libtk8.6:armhf (--configure)时出错：</span><br><span class="line"> 依赖关系问题 - 仍未被配置</span><br><span class="line">dpkg: 依赖关系问题使得 tk8.6-blt2.5 的配置工作不能继续：</span><br><span class="line"> tk8.6-blt2.5 依赖于 libtk8.6 (&gt;= 8.6.0)；然而：</span><br><span class="line">  软件包 libtk8.6:armhf 尚未配置。</span><br><span class="line"></span><br><span class="line">dpkg: 处理软件包 tk8.6-blt2.5 (--configure)时出错：</span><br><span class="line"> 依赖关系问题 - 仍未被配置</span><br><span class="line">dpkg: 依赖关系问题使得 blt 的配置工作不能继续：</span><br><span class="line"> blt 依赖于 tk8.6-blt2.5 (= 2.5.3+dfsg-4)；然而：</span><br><span class="line">  软件包 tk8.6-blt2.5 尚未配置。</span><br><span class="line"></span><br><span class="line">dpkg: 处理软件包 blt (--configure)时出错：</span><br><span class="line"> 依赖关系问题 - 仍未被配置</span><br><span class="line">正在设置 dphys-swapfile (20100506-5+rpt2) ...</span><br><span class="line">insserv: FATAL: service udev is missed in the runlevels 2 3 4 5 to use service raspi-config</span><br><span class="line">insserv: exiting now!</span><br><span class="line">update-rc.d: error: insserv rejected the script header</span><br><span class="line">dpkg: 处理软件包 dphys-swapfile (--configure)时出错：</span><br><span class="line"> 子进程 已安装 post-installation 脚本 返回错误状态 1</span><br><span class="line">dpkg: 依赖关系问题使得 xfonts-utils 的配置工作不能继续：</span><br><span class="line"> xfonts-utils 依赖于 x11-common；然而：</span><br><span class="line">  软件包 x11-common 尚未配置。</span><br><span class="line"></span><br><span class="line">dpkg: 处理软件包 xfonts-utils (--configure)时出错：</span><br><span class="line"> 依赖关系问题 - 仍未被配置</span><br><span class="line">dpkg: 依赖关系问题使得 gsfonts-x11 的配置工作不能继续：</span><br><span class="line"> gsfonts-x11 依赖于 xfonts-utils (&gt;= 1:7.5+2)；然而：</span><br><span class="line">  软件包 xfonts-utils 尚未配置。</span><br><span class="line"></span><br><span class="line">dpkg: 处理软件包 gsfonts-x11 (--configure)时出错：</span><br><span class="line"> 依赖关系问题 - 仍未被配置</span><br><span class="line">dpkg: 依赖关系问题使得 python-tk 的配置工作不能继续：</span><br><span class="line"> python-tk 依赖于 blt (&gt;= 2.4z-9)；然而：</span><br><span class="line">  软件包 blt 尚未配置。</span><br><span class="line"> python-tk 依赖于 libtk8.6 (&gt;= 8.6.0)；然而：</span><br><span class="line">  软件包 libtk8.6:armhf 尚未配置。</span><br><span class="line"> python-tk 依赖于 tk8.6-blt2.5 (&gt;= 2.5.3)；然而：</span><br><span class="line">  软件包 tk8.6-blt2.5 尚未配置。</span><br><span class="line"></span><br><span class="line">dpkg: 处理软件包 python-tk (--configure)时出错：</span><br><span class="line"> 依赖关系问题 - 仍未被配置</span><br><span class="line">dpkg: 依赖关系问题使得 idle-python2.7 的配置工作不能继续：</span><br><span class="line"> idle-python2.7 依赖于 python-tk (&gt;= 2.6~a3)；然而：</span><br><span class="line">  软件包 python-tk 尚未配置。</span><br><span class="line"> idle-python2.7 依赖于 python2.7-tk；然而：</span><br><span class="line">  未安装软件包 python2.7-tk。</span><br><span class="line">  软件包 python-tk 提供了 python2.7-tk，但它尚未被配置。</span><br><span class="line"></span><br><span class="line">dpkg: 处理软件包 idle-python2.7 (--configure)时出错：</span><br><span class="line"> 依赖关系问题 - 仍未被配置</span><br><span class="line">dpkg: 依赖关系问题使得 libice6:armhf 的配置工作不能继续：</span><br><span class="line"> libice6:armhf 依赖于 x11-common；然而：</span><br><span class="line">  软件包 x11-common 尚未配置。</span><br><span class="line"></span><br><span class="line">dpkg: 处理软件包 libice6:armhf (--configure)时出错：</span><br><span class="line"> 依赖关系问题 - 仍未被配置</span><br><span class="line">dpkg: 依赖关系问题使得 libsm6:armhf 的配置工作不能继续：</span><br><span class="line"> libsm6:armhf 依赖于 libice6 (&gt;= 1:1.0.0)；然而：</span><br><span class="line">  软件包 libice6:armhf 尚未配置。</span><br><span class="line"></span><br><span class="line">dpkg: 处理软件包 libsm6:armhf (--configure)时出错：</span><br><span class="line"> 依赖关系问题 - 仍未被配置</span><br><span class="line">dpkg: 依赖关系问题使得 libxt6:armhf 的配置工作不能继续：</span><br><span class="line"> libxt6:armhf 依赖于 libice6 (&gt;= 1:1.0.0)；然而：</span><br><span class="line">  软件包 libice6:armhf 尚未配置。</span><br><span class="line"> libxt6:armhf 依赖于 libsm6；然而：</span><br><span class="line">  软件包 libsm6:armhf 尚未配置。</span><br><span class="line"></span><br><span class="line">dpkg: 处理软件包 libxt6:armhf (--configure)时出错：</span><br><span class="line"> 依赖关系问题 - 仍未被配置</span><br><span class="line">dpkg: 依赖关系问题使得 libaudio2:armhf 的配置工作不能继续：</span><br><span class="line"> libaudio2:armhf 依赖于 libxt6；然而：</span><br><span class="line">  软件包 libxt6:armhf 尚未配置。</span><br><span class="line"></span><br><span class="line">dpkg: 处理软件包 libaudio2:armhf (--configure)时出错：</span><br><span class="line"> 依赖关系问题 - 仍未被配置</span><br><span class="line">dpkg: 依赖关系问题使得 libxmu6:armhf 的配置工作不能继续：</span><br><span class="line"> libxmu6:armhf 依赖于 libxt6；然而：</span><br><span class="line">  软件包 libxt6:armhf 尚未配置。</span><br><span class="line"></span><br><span class="line">dpkg: 处理软件包 libxmu6:armhf (--configure)时出错：</span><br><span class="line"> 依赖关系问题 - 仍未被配置</span><br><span class="line">dpkg: 依赖关系问题使得 libgtkglext1:armhf 的配置工作不能继续：</span><br><span class="line"> libgtkglext1:armhf 依赖于 libice6 (&gt;= 1:1.0.0)；然而：</span><br><span class="line">  软件包 libice6:armhf 尚未配置。</span><br><span class="line"> libgtkglext1:armhf 依赖于 libsm6；然而：</span><br><span class="line">  软件包 libsm6:armhf 尚未配置。</span><br><span class="line"> libgtkglext1:armhf 依赖于 libxmu6；然而：</span><br><span class="line">  软件包 libxmu6:armhf 尚未配置。</span><br><span class="line"> libgtkglext1:armhf 依赖于 libxt6；然而：</span><br><span class="line">  软件包 libxt6:armhf 尚未配置。</span><br><span class="line"></span><br><span class="line">dpkg: 处理软件包 libgtkglext1:armhf (--configure)时出错：</span><br><span class="line"> 依赖关系问题 - 仍未被配置</span><br><span class="line">dpkg: 依赖关系问题使得 libxaw7:armhf 的配置工作不能继续：</span><br><span class="line"> libxaw7:armhf 依赖于 libxmu6；然而：</span><br><span class="line">  软件包 libxmu6:armhf 尚未配置。</span><br><span class="line"> libxaw7:armhf 依赖于 libxt6；然而：</span><br><span class="line">  软件包 libxt6:armhf 尚未配置。</span><br><span class="line"></span><br><span class="line">dpkg: 处理软件包 libxaw7:armhf (--configure)时出错：</span><br><span class="line"> 依赖关系问题 - 仍未被配置</span><br><span class="line">dpkg: 依赖关系问题使得 x11-xkb-utils 的配置工作不能继续：</span><br><span class="line"> x11-xkb-utils 依赖于 libxaw7；然而：</span><br><span class="line">  软件包 libxaw7:armhf 尚未配置。</span><br><span class="line"> x11-xkb-utils 依赖于 libxt6；然而：</span><br><span class="line">  软件包 libxt6:armhf 尚未配置。</span><br><span class="line"></span><br><span class="line">dpkg: 处理软件包 x11-xkb-utils (--configure)时出错：</span><br><span class="line"> 依赖关系问题 - 仍未被配置</span><br><span class="line">dpkg: 依赖关系问题使得 libxklavier16:armhf 的配置工作不能继续：</span><br><span class="line"> libxklavier16:armhf 依赖于 x11-xkb-utils；然而：</span><br><span class="line">  软件包 x11-xkb-utils 尚未配置。</span><br><span class="line"></span><br><span class="line">dpkg: 处理软件包 libxklavier16:armhf (--configure)时出错：</span><br><span class="line"> 依赖关系问题 - 仍未被配置</span><br><span class="line">dpkg: 依赖关系问题使得 liblightdm-gobject-1-0:armhf 的配置工作不能继续：</span><br><span class="line"> liblightdm-gobject-1-0:armhf 依赖于 libxklavier16 (&gt;= 5.0)；然而：</span><br><span class="line">  软件包 libxklavier16:armhf 尚未配置。</span><br><span class="line"></span><br><span class="line">dpkg: 处理软件包 liblightdm-gobject-1-0:armhf (--configure)时出错：</span><br><span class="line"> 依赖关系问题 - 仍未被配置</span><br><span class="line">dpkg: 依赖关系问题使得 libxtst6:armhf 的配置工作不能继续：</span><br><span class="line"> libxtst6:armhf 依赖于 x11-common；然而：</span><br><span class="line">  软件包 x11-common 尚未配置。</span><br><span class="line"></span><br><span class="line">dpkg: 处理软件包 libxtst6:armhf (--configure)时出错：</span><br><span class="line"> 依赖关系问题 - 仍未被配置</span><br><span class="line">dpkg: 依赖关系问题使得 pi-greeter 的配置工作不能继续：</span><br><span class="line"> pi-greeter 依赖于 liblightdm-gobject-1-0 (&gt;= 1.8.7)；然而：</span><br><span class="line">  软件包 liblightdm-gobject-1-0:armhf 尚未配置。</span><br><span class="line"></span><br><span class="line">dpkg: 处理软件包 pi-greeter (--configure)时出错：</span><br><span class="line"> 依赖关系问题 - 仍未被配置</span><br><span class="line">正在设置 raspi-config (20210119) ...</span><br><span class="line">insserv: FATAL: service udev is missed in the runlevels 2 3 4 5 to use service raspi-config</span><br><span class="line">insserv: exiting now!</span><br><span class="line">update-rc.d: error: insserv rejected the script header</span><br><span class="line">dpkg: 处理软件包 raspi-config (--configure)时出错：</span><br><span class="line"> 子进程 已安装 post-installation 脚本 返回错误状态 1</span><br><span class="line">dpkg: 依赖关系问题使得 rc-gui 的配置工作不能继续：</span><br><span class="line"> rc-gui 依赖于 raspi-config；然而：</span><br><span class="line">  软件包 raspi-config 尚未配置。</span><br><span class="line"></span><br><span class="line">dpkg: 处理软件包 rc-gui (--configure)时出错：</span><br><span class="line"> 依赖关系问题 - 仍未被配置</span><br><span class="line">dpkg: 依赖关系问题使得 x11-utils 的配置工作不能继续：</span><br><span class="line"> x11-utils 依赖于 libxaw7；然而：</span><br><span class="line">  软件包 libxaw7:armhf 尚未配置。</span><br><span class="line"> x11-utils 依赖于 libxmu6；然而：</span><br><span class="line">  软件包 libxmu6:armhf 尚未配置。</span><br><span class="line"> x11-utils 依赖于 libxt6 (&gt;= 1:1.1.0)；然而：</span><br><span class="line">  软件包 libxt6:armhf 尚未配置。</span><br><span class="line"> x11-utils 依赖于 libxtst6；然而：</span><br><span class="line">  软件包 libxtst6:armhf 尚未配置。</span><br><span class="line"></span><br><span class="line">dpkg: 处理软件包 x11-utils (--configure)时出错：</span><br><span class="line"> 依赖关系问题 - 仍未被配置</span><br><span class="line">dpkg: 依赖关系问题使得 x2x 的配置工作不能继续：</span><br><span class="line"> x2x 依赖于 libxtst6；然而：</span><br><span class="line">  软件包 libxtst6:armhf 尚未配置。</span><br><span class="line"></span><br><span class="line">dpkg: 处理软件包 x2x (--configure)时出错：</span><br><span class="line"> 依赖关系问题 - 仍未被配置</span><br><span class="line">dpkg: 依赖关系问题使得 xfonts-100dpi 的配置工作不能继续：</span><br><span class="line"> xfonts-100dpi 依赖于 xfonts-utils (&gt;= 1:7.5+2)；然而：</span><br><span class="line">  软件包 xfonts-utils 尚未配置。</span><br><span class="line"></span><br><span class="line">dpkg: 处理软件包 xfonts-100dpi (--configure)时出错：</span><br><span class="line"> 依赖关系问题 - 仍未被配置</span><br><span class="line">dpkg: 依赖关系问题使得 xfonts-base 的配置工作不能继续：</span><br><span class="line"> xfonts-base 依赖于 xfonts-utils (&gt;= 1:7.5+2)；然而：</span><br><span class="line">  软件包 xfonts-utils 尚未配置。</span><br><span class="line"></span><br><span class="line">dpkg: 处理软件包 xfonts-base (--configure)时出错：</span><br><span class="line"> 依赖关系问题 - 仍未被配置</span><br><span class="line">dpkg: 依赖关系问题使得 xinit 的配置工作不能继续：</span><br><span class="line"> xinit 依赖于 x11-common；然而：</span><br><span class="line">  软件包 x11-common 尚未配置。</span><br><span class="line"></span><br><span class="line">dpkg: 处理软件包 xinit (--configure)时出错：</span><br><span class="line"> 依赖关系问题 - 仍未被配置</span><br><span class="line">dpkg: 依赖关系问题使得 xserver-common 的配置工作不能继续：</span><br><span class="line"> xserver-common 依赖于 x11-common；然而：</span><br><span class="line">  软件包 x11-common 尚未配置。</span><br><span class="line"> xserver-common 依赖于 x11-xkb-utils；然而：</span><br><span class="line">  软件包 x11-xkb-utils 尚未配置。</span><br><span class="line"></span><br><span class="line">dpkg: 处理软件包 xserver-common (--configure)时出错：</span><br><span class="line"> 依赖关系问题 - 仍未被配置</span><br><span class="line">正在设置 fake-hwclock (0.11+rpt1) ...</span><br><span class="line">update-rc.d: warning: start and stop actions are no longer supported; falling back to defaults</span><br><span class="line">insserv: FATAL: service udev is missed in the runlevels 2 3 4 5 to use service raspi-config</span><br><span class="line">insserv: exiting now!</span><br><span class="line">update-rc.d: error: insserv rejected the script header</span><br><span class="line">dpkg: 处理软件包 fake-hwclock (--configure)时出错：</span><br><span class="line"> 子进程 已安装 post-installation 脚本 返回错误状态 1</span><br><span class="line">正在设置 triggerhappy (0.5.0-1) ...</span><br><span class="line">insserv: FATAL: service udev is missed in the runlevels 2 3 4 5 to use service raspi-config</span><br><span class="line">insserv: exiting now!</span><br><span class="line">update-rc.d: error: insserv rejected the script header</span><br><span class="line">dpkg: 处理软件包 triggerhappy (--configure)时出错：</span><br><span class="line"> 子进程 已安装 post-installation 脚本 返回错误状态 1</span><br><span class="line">在处理时有错误发生：</span><br><span class="line"> console-setup-linux</span><br><span class="line"> console-setup</span><br><span class="line"> x11-common</span><br><span class="line"> libxss1:armhf</span><br><span class="line"> libtk8.6:armhf</span><br><span class="line"> tk8.6-blt2.5</span><br><span class="line"> blt</span><br><span class="line"> dphys-swapfile</span><br><span class="line"> xfonts-utils</span><br><span class="line"> gsfonts-x11</span><br><span class="line"> python-tk</span><br><span class="line"> idle-python2.7</span><br><span class="line"> libice6:armhf</span><br><span class="line"> libsm6:armhf</span><br><span class="line"> libxt6:armhf</span><br><span class="line"> libaudio2:armhf</span><br><span class="line"> libxmu6:armhf</span><br><span class="line"> libgtkglext1:armhf</span><br><span class="line"> libxaw7:armhf</span><br><span class="line"> x11-xkb-utils</span><br><span class="line"> libxklavier16:armhf</span><br><span class="line"> liblightdm-gobject-1-0:armhf</span><br><span class="line"> libxtst6:armhf</span><br><span class="line"> pi-greeter</span><br><span class="line"> raspi-config</span><br><span class="line"> rc-gui</span><br><span class="line"> x11-utils</span><br><span class="line"> x2x</span><br><span class="line"> xfonts-100dpi</span><br><span class="line"> xfonts-base</span><br><span class="line"> xinit</span><br><span class="line"> xserver-common</span><br><span class="line"> fake-hwclock</span><br><span class="line"> triggerhappy</span><br><span class="line">E: Sub-process /usr/bin/dpkg returned an error code (1)</span><br><span class="line">pi@raspberrypi:~ $ sudo apt-get install motion</span><br><span class="line">正在读取软件包列表... 完成</span><br><span class="line">正在分析软件包的依赖关系树</span><br><span class="line">正在读取状态信息... 完成</span><br><span class="line">下列软件包是自动安装的并且现在不需要了：</span><br><span class="line">  libasprintf0c2 libboost-filesystem1.55.0 libboost-program-options1.55.0</span><br><span class="line">  libboost-regex1.55.0 libsoxr0 lxkeymap python-gobject python-xklavier tcpd</span><br><span class="line">使用&#x27;apt-get autoremove&#x27;来卸载它(它们)。</span><br><span class="line">将会安装下列额外的软件包：</span><br><span class="line">  libmysqlclient18 libsoxr0 mysql-common</span><br><span class="line">建议安装的软件包：</span><br><span class="line">  mysql-client postgresql-client</span><br><span class="line">推荐安装的软件包：</span><br><span class="line">  ffmpeg</span><br><span class="line">下列【新】软件包将被安装：</span><br><span class="line">  libmysqlclient18 libsoxr0 motion mysql-common</span><br><span class="line">升级了 0 个软件包，新安装了 4 个软件包，要卸载 0 个软件包，有 106 个软件包未被升级。</span><br><span class="line">有 34 个软件包没有被完全安装或卸载。</span><br><span class="line">需要下载 996 kB 的软件包。</span><br><span class="line">解压缩后会消耗掉 4,308 kB 的额外空间。</span><br><span class="line">您希望继续执行吗？ [Y/n] y</span><br><span class="line">获取：1 http://mirrordirector.raspbian.org/raspbian/ jessie/main mysql-common all 5.5.62-0+deb8u1 [75.7 kB]</span><br><span class="line">获取：2 http://mirrordirector.raspbian.org/raspbian/ jessie/main libmysqlclient18 armhf 5.5.62-0+deb8u1 [619 kB]</span><br><span class="line">获取：3 http://mirrordirector.raspbian.org/raspbian/ jessie/main libsoxr0 armhf 0.1.1-1 [71.7 kB]</span><br><span class="line">获取：4 http://mirrordirector.raspbian.org/raspbian/ jessie/main motion armhf 3.2.12+git20140228-4+b2 [230 kB]</span><br><span class="line">下载 996 kB，耗时 9秒 (107 kB/s)</span><br><span class="line">正在预设定软件包 ...</span><br><span class="line">正在选中未选择的软件包 mysql-common。</span><br><span class="line">(正在读取数据库 ... 系统当前共安装有 120664 个文件和目录。)</span><br><span class="line">正准备解包 .../mysql-common_5.5.62-0+deb8u1_all.deb  ...</span><br><span class="line">正在解包 mysql-common (5.5.62-0+deb8u1) ...</span><br><span class="line">正在选中未选择的软件包 libmysqlclient18:armhf。</span><br><span class="line">正准备解包 .../libmysqlclient18_5.5.62-0+deb8u1_armhf.deb  ...</span><br><span class="line">正在解包 libmysqlclient18:armhf (5.5.62-0+deb8u1) ...</span><br><span class="line">正在选中未选择的软件包 libsoxr0:armhf。</span><br><span class="line">正准备解包 .../libsoxr0_0.1.1-1_armhf.deb  ...</span><br><span class="line">正在解包 libsoxr0:armhf (0.1.1-1) ...</span><br><span class="line">正在选中未选择的软件包 motion。</span><br><span class="line">正准备解包 .../motion_3.2.12+git20140228-4+b2_armhf.deb  ...</span><br><span class="line">正在解包 motion (3.2.12+git20140228-4+b2) ...</span><br><span class="line">正在处理用于 man-db (2.7.5-1~bpo8+1) 的触发器 ...</span><br><span class="line">正在处理用于 systemd (215-17+deb8u13) 的触发器 ...</span><br><span class="line">正在设置 console-setup-linux (1.193~deb10u1) ...</span><br><span class="line">insserv: FATAL: service udev is missed in the runlevels 2 3 4 5 to use service raspi-config</span><br><span class="line">insserv: exiting now!</span><br><span class="line">update-rc.d: error: insserv rejected the script header</span><br><span class="line">dpkg: 处理软件包 console-setup-linux (--configure)时出错：</span><br><span class="line"> 子进程 已安装 post-installation 脚本 返回错误状态 1</span><br><span class="line">dpkg: 依赖关系问题使得 console-setup 的配置工作不能继续：</span><br><span class="line"> console-setup 依赖于 console-setup-linux | console-setup-freebsd | hurd；然而：</span><br><span class="line">  软件包 console-setup-linux 尚未配置。</span><br><span class="line">  未安装软件包 console-setup-freebsd。</span><br><span class="line">  未安装软件包 hurd。</span><br><span class="line"></span><br><span class="line">dpkg: 处理软件包 console-setup (--configure)时出错：</span><br><span class="line"> 依赖关系问题 - 仍未被配置</span><br><span class="line">正在设置 x11-common (1:7.7+19) ...</span><br><span class="line">update-rc.d: warning: start and stop actions are no longer supported; falling back to defaults</span><br><span class="line">insserv: FATAL: service udev is missed in the runlevels 2 3 4 5 to use service raspi-config</span><br><span class="line">insserv: exiting now!</span><br><span class="line">update-rc.d: error: insserv rejected the script header</span><br><span class="line">dpkg: 处理软件包 x11-common (--configure)时出错：</span><br><span class="line"> 子进程 已安装 post-installation 脚本 返回错误状态 1</span><br><span class="line">dpkg: 依赖关系问题使得 libxss1:armhf 的配置工作不能继续：</span><br><span class="line"> libxss1:armhf 依赖于 x11-common；然而：</span><br><span class="line">  软件包 x11-common 尚未配置。</span><br><span class="line"></span><br><span class="line">dpkg: 处理软件包 libxss1:armhf (--configure)时出错：</span><br><span class="line"> 依赖关系问题 - 仍未被配置</span><br><span class="line">dpkg: 依赖关系问题使得 libtk8.6:armhf 的配置工作不能继续：</span><br><span class="line"> libtk8.6:armhf 依赖于 libxss1；然而：</span><br><span class="line">  软件包 libxss1:armhf 尚未配置。</span><br><span class="line"></span><br><span class="line">dpkg: 处理软件包 libtk8.6:armhf (--configure)时出错：</span><br><span class="line"> 依赖关系问题 - 仍未被配置</span><br><span class="line">dpkg: 依赖关系问题使得 tk8.6-blt2.5 的配置工作不能继续：</span><br><span class="line"> tk8.6-blt2.5 依赖于 libtk8.6 (&gt;= 8.6.0)；然而：</span><br><span class="line">  软件包 libtk8.6:armhf 尚未配置。</span><br><span class="line"></span><br><span class="line">dpkg: 处理软件包 tk8.6-blt2.5 (--configure)时出错：</span><br><span class="line"> 依赖关系问题 - 仍未被配置</span><br><span class="line">dpkg: 依赖关系问题使得 blt 的配置工作不能继续：</span><br><span class="line"> blt 依赖于 tk8.6-blt2.5 (= 2.5.3+dfsg-4)；然而：</span><br><span class="line">  软件包 tk8.6-blt2.5 尚未配置。</span><br><span class="line"></span><br><span class="line">dpkg: 处理软件包 blt (--configure)时出错：</span><br><span class="line"> 依赖关系问题 - 仍未被配置</span><br><span class="line">正在设置 dphys-swapfile (20100506-5+rpt2) ...</span><br><span class="line">insserv: FATAL: service udev is missed in the runlevels 2 3 4 5 to use service raspi-config</span><br><span class="line">insserv: exiting now!</span><br><span class="line">update-rc.d: error: insserv rejected the script header</span><br><span class="line">dpkg: 处理软件包 dphys-swapfile (--configure)时出错：</span><br><span class="line"> 子进程 已安装 post-installation 脚本 返回错误状态 1</span><br><span class="line">dpkg: 依赖关系问题使得 xfonts-utils 的配置工作不能继续：</span><br><span class="line"> xfonts-utils 依赖于 x11-common；然而：</span><br><span class="line">  软件包 x11-common 尚未配置。</span><br><span class="line"></span><br><span class="line">dpkg: 处理软件包 xfonts-utils (--configure)时出错：</span><br><span class="line"> 依赖关系问题 - 仍未被配置</span><br><span class="line">dpkg: 依赖关系问题使得 gsfonts-x11 的配置工作不能继续：</span><br><span class="line"> gsfonts-x11 依赖于 xfonts-utils (&gt;= 1:7.5+2)；然而：</span><br><span class="line">  软件包 xfonts-utils 尚未配置。</span><br><span class="line"></span><br><span class="line">dpkg: 处理软件包 gsfonts-x11 (--configure)时出错：</span><br><span class="line"> 依赖关系问题 - 仍未被配置</span><br><span class="line">dpkg: 依赖关系问题使得 python-tk 的配置工作不能继续：</span><br><span class="line"> python-tk 依赖于 blt (&gt;= 2.4z-9)；然而：</span><br><span class="line">  软件包 blt 尚未配置。</span><br><span class="line"> python-tk 依赖于 libtk8.6 (&gt;= 8.6.0)；然而：</span><br><span class="line">  软件包 libtk8.6:armhf 尚未配置。</span><br><span class="line"> python-tk 依赖于 tk8.6-blt2.5 (&gt;= 2.5.3)；然而：</span><br><span class="line">  软件包 tk8.6-blt2.5 尚未配置。</span><br><span class="line"></span><br><span class="line">dpkg: 处理软件包 python-tk (--configure)时出错：</span><br><span class="line"> 依赖关系问题 - 仍未被配置</span><br><span class="line">dpkg: 依赖关系问题使得 idle-python2.7 的配置工作不能继续：</span><br><span class="line"> idle-python2.7 依赖于 python-tk (&gt;= 2.6~a3)；然而：</span><br><span class="line">  软件包 python-tk 尚未配置。</span><br><span class="line"> idle-python2.7 依赖于 python2.7-tk；然而：</span><br><span class="line">  未安装软件包 python2.7-tk。</span><br><span class="line">  软件包 python-tk 提供了 python2.7-tk，但它尚未被配置。</span><br><span class="line"></span><br><span class="line">dpkg: 处理软件包 idle-python2.7 (--configure)时出错：</span><br><span class="line"> 依赖关系问题 - 仍未被配置</span><br><span class="line">dpkg: 依赖关系问题使得 libice6:armhf 的配置工作不能继续：</span><br><span class="line"> libice6:armhf 依赖于 x11-common；然而：</span><br><span class="line">  软件包 x11-common 尚未配置。</span><br><span class="line"></span><br><span class="line">dpkg: 处理软件包 libice6:armhf (--configure)时出错：</span><br><span class="line"> 依赖关系问题 - 仍未被配置</span><br><span class="line">dpkg: 依赖关系问题使得 libsm6:armhf 的配置工作不能继续：</span><br><span class="line"> libsm6:armhf 依赖于 libice6 (&gt;= 1:1.0.0)；然而：</span><br><span class="line">  软件包 libice6:armhf 尚未配置。</span><br><span class="line"></span><br><span class="line">dpkg: 处理软件包 libsm6:armhf (--configure)时出错：</span><br><span class="line"> 依赖关系问题 - 仍未被配置</span><br><span class="line">dpkg: 依赖关系问题使得 libxt6:armhf 的配置工作不能继续：</span><br><span class="line"> libxt6:armhf 依赖于 libice6 (&gt;= 1:1.0.0)；然而：</span><br><span class="line">  软件包 libice6:armhf 尚未配置。</span><br><span class="line"> libxt6:armhf 依赖于 libsm6；然而：</span><br><span class="line">  软件包 libsm6:armhf 尚未配置。</span><br><span class="line"></span><br><span class="line">dpkg: 处理软件包 libxt6:armhf (--configure)时出错：</span><br><span class="line"> 依赖关系问题 - 仍未被配置</span><br><span class="line">dpkg: 依赖关系问题使得 libaudio2:armhf 的配置工作不能继续：</span><br><span class="line"> libaudio2:armhf 依赖于 libxt6；然而：</span><br><span class="line">  软件包 libxt6:armhf 尚未配置。</span><br><span class="line"></span><br><span class="line">dpkg: 处理软件包 libaudio2:armhf (--configure)时出错：</span><br><span class="line"> 依赖关系问题 - 仍未被配置</span><br><span class="line">dpkg: 依赖关系问题使得 libxmu6:armhf 的配置工作不能继续：</span><br><span class="line"> libxmu6:armhf 依赖于 libxt6；然而：</span><br><span class="line">  软件包 libxt6:armhf 尚未配置。</span><br><span class="line"></span><br><span class="line">dpkg: 处理软件包 libxmu6:armhf (--configure)时出错：</span><br><span class="line"> 依赖关系问题 - 仍未被配置</span><br><span class="line">dpkg: 依赖关系问题使得 libgtkglext1:armhf 的配置工作不能继续：</span><br><span class="line"> libgtkglext1:armhf 依赖于 libice6 (&gt;= 1:1.0.0)；然而：</span><br><span class="line">  软件包 libice6:armhf 尚未配置。</span><br><span class="line"> libgtkglext1:armhf 依赖于 libsm6；然而：</span><br><span class="line">  软件包 libsm6:armhf 尚未配置。</span><br><span class="line"> libgtkglext1:armhf 依赖于 libxmu6；然而：</span><br><span class="line">  软件包 libxmu6:armhf 尚未配置。</span><br><span class="line"> libgtkglext1:armhf 依赖于 libxt6；然而：</span><br><span class="line">  软件包 libxt6:armhf 尚未配置。</span><br><span class="line"></span><br><span class="line">dpkg: 处理软件包 libgtkglext1:armhf (--configure)时出错：</span><br><span class="line"> 依赖关系问题 - 仍未被配置</span><br><span class="line">dpkg: 依赖关系问题使得 libxaw7:armhf 的配置工作不能继续：</span><br><span class="line"> libxaw7:armhf 依赖于 libxmu6；然而：</span><br><span class="line">  软件包 libxmu6:armhf 尚未配置。</span><br><span class="line"> libxaw7:armhf 依赖于 libxt6；然而：</span><br><span class="line">  软件包 libxt6:armhf 尚未配置。</span><br><span class="line"></span><br><span class="line">dpkg: 处理软件包 libxaw7:armhf (--configure)时出错：</span><br><span class="line"> 依赖关系问题 - 仍未被配置</span><br><span class="line">dpkg: 依赖关系问题使得 x11-xkb-utils 的配置工作不能继续：</span><br><span class="line"> x11-xkb-utils 依赖于 libxaw7；然而：</span><br><span class="line">  软件包 libxaw7:armhf 尚未配置。</span><br><span class="line"> x11-xkb-utils 依赖于 libxt6；然而：</span><br><span class="line">  软件包 libxt6:armhf 尚未配置。</span><br><span class="line"></span><br><span class="line">dpkg: 处理软件包 x11-xkb-utils (--configure)时出错：</span><br><span class="line"> 依赖关系问题 - 仍未被配置</span><br><span class="line">dpkg: 依赖关系问题使得 libxklavier16:armhf 的配置工作不能继续：</span><br><span class="line"> libxklavier16:armhf 依赖于 x11-xkb-utils；然而：</span><br><span class="line">  软件包 x11-xkb-utils 尚未配置。</span><br><span class="line"></span><br><span class="line">dpkg: 处理软件包 libxklavier16:armhf (--configure)时出错：</span><br><span class="line"> 依赖关系问题 - 仍未被配置</span><br><span class="line">dpkg: 依赖关系问题使得 liblightdm-gobject-1-0:armhf 的配置工作不能继续：</span><br><span class="line"> liblightdm-gobject-1-0:armhf 依赖于 libxklavier16 (&gt;= 5.0)；然而：</span><br><span class="line">  软件包 libxklavier16:armhf 尚未配置。</span><br><span class="line"></span><br><span class="line">dpkg: 处理软件包 liblightdm-gobject-1-0:armhf (--configure)时出错：</span><br><span class="line"> 依赖关系问题 - 仍未被配置</span><br><span class="line">dpkg: 依赖关系问题使得 libxtst6:armhf 的配置工作不能继续：</span><br><span class="line"> libxtst6:armhf 依赖于 x11-common；然而：</span><br><span class="line">  软件包 x11-common 尚未配置。</span><br><span class="line"></span><br><span class="line">dpkg: 处理软件包 libxtst6:armhf (--configure)时出错：</span><br><span class="line"> 依赖关系问题 - 仍未被配置</span><br><span class="line">dpkg: 依赖关系问题使得 pi-greeter 的配置工作不能继续：</span><br><span class="line"> pi-greeter 依赖于 liblightdm-gobject-1-0 (&gt;= 1.8.7)；然而：</span><br><span class="line">  软件包 liblightdm-gobject-1-0:armhf 尚未配置。</span><br><span class="line"></span><br><span class="line">dpkg: 处理软件包 pi-greeter (--configure)时出错：</span><br><span class="line"> 依赖关系问题 - 仍未被配置</span><br><span class="line">正在设置 raspi-config (20210119) ...</span><br><span class="line">insserv: FATAL: service udev is missed in the runlevels 2 3 4 5 to use service raspi-config</span><br><span class="line">insserv: exiting now!</span><br><span class="line">update-rc.d: error: insserv rejected the script header</span><br><span class="line">dpkg: 处理软件包 raspi-config (--configure)时出错：</span><br><span class="line"> 子进程 已安装 post-installation 脚本 返回错误状态 1</span><br><span class="line">dpkg: 依赖关系问题使得 rc-gui 的配置工作不能继续：</span><br><span class="line"> rc-gui 依赖于 raspi-config；然而：</span><br><span class="line">  软件包 raspi-config 尚未配置。</span><br><span class="line"></span><br><span class="line">dpkg: 处理软件包 rc-gui (--configure)时出错：</span><br><span class="line"> 依赖关系问题 - 仍未被配置</span><br><span class="line">dpkg: 依赖关系问题使得 x11-utils 的配置工作不能继续：</span><br><span class="line"> x11-utils 依赖于 libxaw7；然而：</span><br><span class="line">  软件包 libxaw7:armhf 尚未配置。</span><br><span class="line"> x11-utils 依赖于 libxmu6；然而：</span><br><span class="line">  软件包 libxmu6:armhf 尚未配置。</span><br><span class="line"> x11-utils 依赖于 libxt6 (&gt;= 1:1.1.0)；然而：</span><br><span class="line">  软件包 libxt6:armhf 尚未配置。</span><br><span class="line"> x11-utils 依赖于 libxtst6；然而：</span><br><span class="line">  软件包 libxtst6:armhf 尚未配置。</span><br><span class="line"></span><br><span class="line">dpkg: 处理软件包 x11-utils (--configure)时出错：</span><br><span class="line"> 依赖关系问题 - 仍未被配置</span><br><span class="line">dpkg: 依赖关系问题使得 x2x 的配置工作不能继续：</span><br><span class="line"> x2x 依赖于 libxtst6；然而：</span><br><span class="line">  软件包 libxtst6:armhf 尚未配置。</span><br><span class="line"></span><br><span class="line">dpkg: 处理软件包 x2x (--configure)时出错：</span><br><span class="line"> 依赖关系问题 - 仍未被配置</span><br><span class="line">dpkg: 依赖关系问题使得 xfonts-100dpi 的配置工作不能继续：</span><br><span class="line"> xfonts-100dpi 依赖于 xfonts-utils (&gt;= 1:7.5+2)；然而：</span><br><span class="line">  软件包 xfonts-utils 尚未配置。</span><br><span class="line"></span><br><span class="line">dpkg: 处理软件包 xfonts-100dpi (--configure)时出错：</span><br><span class="line"> 依赖关系问题 - 仍未被配置</span><br><span class="line">dpkg: 依赖关系问题使得 xfonts-base 的配置工作不能继续：</span><br><span class="line"> xfonts-base 依赖于 xfonts-utils (&gt;= 1:7.5+2)；然而：</span><br><span class="line">  软件包 xfonts-utils 尚未配置。</span><br><span class="line"></span><br><span class="line">dpkg: 处理软件包 xfonts-base (--configure)时出错：</span><br><span class="line"> 依赖关系问题 - 仍未被配置</span><br><span class="line">dpkg: 依赖关系问题使得 xinit 的配置工作不能继续：</span><br><span class="line"> xinit 依赖于 x11-common；然而：</span><br><span class="line">  软件包 x11-common 尚未配置。</span><br><span class="line"></span><br><span class="line">dpkg: 处理软件包 xinit (--configure)时出错：</span><br><span class="line"> 依赖关系问题 - 仍未被配置</span><br><span class="line">dpkg: 依赖关系问题使得 xserver-common 的配置工作不能继续：</span><br><span class="line"> xserver-common 依赖于 x11-common；然而：</span><br><span class="line">  软件包 x11-common 尚未配置。</span><br><span class="line"> xserver-common 依赖于 x11-xkb-utils；然而：</span><br><span class="line">  软件包 x11-xkb-utils 尚未配置。</span><br><span class="line"></span><br><span class="line">dpkg: 处理软件包 xserver-common (--configure)时出错：</span><br><span class="line"> 依赖关系问题 - 仍未被配置</span><br><span class="line">正在设置 fake-hwclock (0.11+rpt1) ...</span><br><span class="line">update-rc.d: warning: start and stop actions are no longer supported; falling back to defaults</span><br><span class="line">insserv: FATAL: service udev is missed in the runlevels 2 3 4 5 to use service raspi-config</span><br><span class="line">insserv: exiting now!</span><br><span class="line">update-rc.d: error: insserv rejected the script header</span><br><span class="line">dpkg: 处理软件包 fake-hwclock (--configure)时出错：</span><br><span class="line"> 子进程 已安装 post-installation 脚本 返回错误状态 1</span><br><span class="line">正在设置 triggerhappy (0.5.0-1) ...</span><br><span class="line">insserv: FATAL: service udev is missed in the runlevels 2 3 4 5 to use service raspi-config</span><br><span class="line">insserv: exiting now!</span><br><span class="line">update-rc.d: error: insserv rejected the script header</span><br><span class="line">dpkg: 处理软件包 triggerhappy (--configure)时出错：</span><br><span class="line"> 子进程 已安装 post-installation 脚本 返回错误状态 1</span><br><span class="line">正在设置 mysql-common (5.5.62-0+deb8u1) ...</span><br><span class="line">正在设置 libmysqlclient18:armhf (5.5.62-0+deb8u1) ...</span><br><span class="line">正在设置 libsoxr0:armhf (0.1.1-1) ...</span><br><span class="line">正在设置 motion (3.2.12+git20140228-4+b2) ...</span><br><span class="line">正在添加组&quot;motion&quot; (GID 121)...</span><br><span class="line">完成。</span><br><span class="line">警告：您指定的主目录 /var/lib/motion 已存在。</span><br><span class="line">正在添加系统用户&quot;motion&quot; (UID 114)...</span><br><span class="line">正在将新用户&quot;motion&quot; (UID 114)添加到组&quot;motion&quot;...</span><br><span class="line">主目录&quot;/var/lib/motion&quot;已经存在。没有从&quot;/etc/skel&quot;复制文件。</span><br><span class="line">adduser：警告：主目录 /var/lib/motion 不属于您当前创建的用户。</span><br><span class="line">正在添加用户&quot;motion&quot;到&quot;video&quot;组...</span><br><span class="line">正在将用户“motion”加入到“video”组中</span><br><span class="line">完成。</span><br><span class="line">insserv: FATAL: service udev is missed in the runlevels 2 3 4 5 to use service raspi-config</span><br><span class="line">insserv: exiting now!</span><br><span class="line">update-rc.d: error: insserv rejected the script header</span><br><span class="line">dpkg: 处理软件包 motion (--configure)时出错：</span><br><span class="line"> 子进程 已安装 post-installation 脚本 返回错误状态 1</span><br><span class="line">正在处理用于 libc-bin (2.19-18+deb8u10) 的触发器 ...</span><br><span class="line">正在处理用于 systemd (215-17+deb8u13) 的触发器 ...</span><br><span class="line">在处理时有错误发生：</span><br><span class="line"> console-setup-linux</span><br><span class="line"> console-setup</span><br><span class="line"> x11-common</span><br><span class="line"> libxss1:armhf</span><br><span class="line"> libtk8.6:armhf</span><br><span class="line"> tk8.6-blt2.5</span><br><span class="line"> blt</span><br><span class="line"> dphys-swapfile</span><br><span class="line"> xfonts-utils</span><br><span class="line"> gsfonts-x11</span><br><span class="line"> python-tk</span><br><span class="line"> idle-python2.7</span><br><span class="line"> libice6:armhf</span><br><span class="line"> libsm6:armhf</span><br><span class="line"> libxt6:armhf</span><br><span class="line"> libaudio2:armhf</span><br><span class="line"> libxmu6:armhf</span><br><span class="line"> libgtkglext1:armhf</span><br><span class="line"> libxaw7:armhf</span><br><span class="line"> x11-xkb-utils</span><br><span class="line"> libxklavier16:armhf</span><br><span class="line"> liblightdm-gobject-1-0:armhf</span><br><span class="line"> libxtst6:armhf</span><br><span class="line"> pi-greeter</span><br><span class="line"> raspi-config</span><br><span class="line"> rc-gui</span><br><span class="line"> x11-utils</span><br><span class="line"> x2x</span><br><span class="line"> xfonts-100dpi</span><br><span class="line"> xfonts-base</span><br><span class="line"> xinit</span><br><span class="line"> xserver-common</span><br><span class="line"> fake-hwclock</span><br><span class="line"> triggerhappy</span><br><span class="line"> motion</span><br><span class="line">E: Sub-process /usr/bin/dpkg returned an error code (1)</span><br><span class="line">pi@raspberrypi:~ $ sudo apt-get install ffmpeg v4l-utils</span><br><span class="line">正在读取软件包列表... 完成</span><br><span class="line">正在分析软件包的依赖关系树</span><br><span class="line">正在读取状态信息... 完成</span><br><span class="line">v4l-utils 已经是最新的版本。</span><br><span class="line">有一些软件包无法被安装。如果您用的是 unstable 发行版，这也许是</span><br><span class="line">因为系统无法达到您要求的状态造成的。该版本中可能会有一些您需要的软件</span><br><span class="line">包尚未被创建或是它们已被从新到(Incoming)目录移出。</span><br><span class="line">下列信息可能会对解决问题有所帮助：</span><br><span class="line"></span><br><span class="line">下列软件包有未满足的依赖关系：</span><br><span class="line"> ffmpeg : 依赖: libavcodec58 (= 7:4.1.6-1~deb10u1+rpt1)</span><br><span class="line">          依赖: libavdevice58 (= 7:4.1.6-1~deb10u1+rpt1) 但是它将不会被安装</span><br><span class="line">          依赖: libavfilter7 (= 7:4.1.6-1~deb10u1+rpt1)</span><br><span class="line">          依赖: libavformat58 (= 7:4.1.6-1~deb10u1+rpt1) 但是它将不会被安装</span><br><span class="line">          依赖: libavresample4 (= 7:4.1.6-1~deb10u1+rpt1) 但是它将不会被安装</span><br><span class="line">          依赖: libavutil56 (= 7:4.1.6-1~deb10u1+rpt1) 但是它将不会被安装</span><br><span class="line">          依赖: libpostproc55 (= 7:4.1.6-1~deb10u1+rpt1) 但是它将不会被安装</span><br><span class="line">          依赖: libsdl2-2.0-0 (&gt;= 2.0.9) 但是它将不会被安装</span><br><span class="line">          依赖: libswresample3 (= 7:4.1.6-1~deb10u1+rpt1) 但是它将不会被安装</span><br><span class="line">          依赖: libswscale5 (= 7:4.1.6-1~deb10u1+rpt1) 但是它将不会被安装</span><br><span class="line">E: 无法修正错误，因为您要求某些软件包保持现状，就是它们破坏了软件包间的依赖关系。</span><br><span class="line">pi@raspberrypi:~ $ sudo apt-get install libmariadbclient18 libpq5</span><br><span class="line">正在读取软件包列表... 完成</span><br><span class="line">正在分析软件包的依赖关系树</span><br><span class="line">正在读取状态信息... 完成</span><br><span class="line">下列软件包是自动安装的并且现在不需要了：</span><br><span class="line">  libasprintf0c2 libboost-filesystem1.55.0 libboost-program-options1.55.0</span><br><span class="line">  libboost-regex1.55.0 libsoxr0 lxkeymap python-gobject python-xklavier tcpd</span><br><span class="line">使用&#x27;apt-get autoremove&#x27;来卸载它(它们)。</span><br><span class="line">将会安装下列额外的软件包：</span><br><span class="line">  mariadb-common</span><br><span class="line">下列【新】软件包将被安装：</span><br><span class="line">  libmariadbclient18 libpq5 mariadb-common</span><br><span class="line">升级了 0 个软件包，新安装了 3 个软件包，要卸载 0 个软件包，有 106 个软件包未被升级。</span><br><span class="line">有 35 个软件包没有被完全安装或卸载。</span><br><span class="line">需要下载 627 kB 的软件包。</span><br><span class="line">解压缩后会消耗掉 3,555 kB 的额外空间。</span><br><span class="line">您希望继续执行吗？ [Y/n] y</span><br><span class="line">获取：1 http://mirrordirector.raspbian.org/raspbian/ jessie/main mariadb-common all 10.0.38-0+deb8u1 [17.8 kB]</span><br><span class="line">获取：2 http://mirrordirector.raspbian.org/raspbian/ jessie/main libmariadbclient18 armhf 5.5.39-2 [495 kB]</span><br><span class="line">获取：3 http://mirrordirector.raspbian.org/raspbian/ jessie/main libpq5 armhf 9.4.26-0+deb8u1 [114 kB]</span><br><span class="line">下载 627 kB，耗时 3秒 (204 kB/s)</span><br><span class="line">正在选中未选择的软件包 mariadb-common。</span><br><span class="line">(正在读取数据库 ... 系统当前共安装有 120715 个文件和目录。)</span><br><span class="line">正准备解包 .../mariadb-common_10.0.38-0+deb8u1_all.deb  ...</span><br><span class="line">正在解包 mariadb-common (10.0.38-0+deb8u1) ...</span><br><span class="line">正在选中未选择的软件包 libmariadbclient18:armhf。</span><br><span class="line">正准备解包 .../libmariadbclient18_5.5.39-2_armhf.deb  ...</span><br><span class="line">正在解包 libmariadbclient18:armhf (5.5.39-2) ...</span><br><span class="line">正在选中未选择的软件包 libpq5:armhf。</span><br><span class="line">正准备解包 .../libpq5_9.4.26-0+deb8u1_armhf.deb  ...</span><br><span class="line">正在解包 libpq5:armhf (9.4.26-0+deb8u1) ...</span><br><span class="line">正在设置 console-setup-linux (1.193~deb10u1) ...</span><br><span class="line">insserv: FATAL: service udev is missed in the runlevels 2 3 4 5 to use service raspi-config</span><br><span class="line">insserv: exiting now!</span><br><span class="line">update-rc.d: error: insserv rejected the script header</span><br><span class="line">dpkg: 处理软件包 console-setup-linux (--configure)时出错：</span><br><span class="line"> 子进程 已安装 post-installation 脚本 返回错误状态 1</span><br><span class="line">dpkg: 依赖关系问题使得 console-setup 的配置工作不能继续：</span><br><span class="line"> console-setup 依赖于 console-setup-linux | console-setup-freebsd | hurd；然而：</span><br><span class="line">  软件包 console-setup-linux 尚未配置。</span><br><span class="line">  未安装软件包 console-setup-freebsd。</span><br><span class="line">  未安装软件包 hurd。</span><br><span class="line"></span><br><span class="line">dpkg: 处理软件包 console-setup (--configure)时出错：</span><br><span class="line"> 依赖关系问题 - 仍未被配置</span><br><span class="line">正在设置 x11-common (1:7.7+19) ...</span><br><span class="line">update-rc.d: warning: start and stop actions are no longer supported; falling back to defaults</span><br><span class="line">insserv: FATAL: service udev is missed in the runlevels 2 3 4 5 to use service raspi-config</span><br><span class="line">insserv: exiting now!</span><br><span class="line">update-rc.d: error: insserv rejected the script header</span><br><span class="line">dpkg: 处理软件包 x11-common (--configure)时出错：</span><br><span class="line"> 子进程 已安装 post-installation 脚本 返回错误状态 1</span><br><span class="line">dpkg: 依赖关系问题使得 libxss1:armhf 的配置工作不能继续：</span><br><span class="line"> libxss1:armhf 依赖于 x11-common；然而：</span><br><span class="line">  软件包 x11-common 尚未配置。</span><br><span class="line"></span><br><span class="line">dpkg: 处理软件包 libxss1:armhf (--configure)时出错：</span><br><span class="line"> 依赖关系问题 - 仍未被配置</span><br><span class="line">dpkg: 依赖关系问题使得 libtk8.6:armhf 的配置工作不能继续：</span><br><span class="line"> libtk8.6:armhf 依赖于 libxss1；然而：</span><br><span class="line">  软件包 libxss1:armhf 尚未配置。</span><br><span class="line"></span><br><span class="line">dpkg: 处理软件包 libtk8.6:armhf (--configure)时出错：</span><br><span class="line"> 依赖关系问题 - 仍未被配置</span><br><span class="line">dpkg: 依赖关系问题使得 tk8.6-blt2.5 的配置工作不能继续：</span><br><span class="line"> tk8.6-blt2.5 依赖于 libtk8.6 (&gt;= 8.6.0)；然而：</span><br><span class="line">  软件包 libtk8.6:armhf 尚未配置。</span><br><span class="line"></span><br><span class="line">dpkg: 处理软件包 tk8.6-blt2.5 (--configure)时出错：</span><br><span class="line"> 依赖关系问题 - 仍未被配置</span><br><span class="line">dpkg: 依赖关系问题使得 blt 的配置工作不能继续：</span><br><span class="line"> blt 依赖于 tk8.6-blt2.5 (= 2.5.3+dfsg-4)；然而：</span><br><span class="line">  软件包 tk8.6-blt2.5 尚未配置。</span><br><span class="line"></span><br><span class="line">dpkg: 处理软件包 blt (--configure)时出错：</span><br><span class="line"> 依赖关系问题 - 仍未被配置</span><br><span class="line">正在设置 dphys-swapfile (20100506-5+rpt2) ...</span><br><span class="line">insserv: FATAL: service udev is missed in the runlevels 2 3 4 5 to use service raspi-config</span><br><span class="line">insserv: exiting now!</span><br><span class="line">update-rc.d: error: insserv rejected the script header</span><br><span class="line">dpkg: 处理软件包 dphys-swapfile (--configure)时出错：</span><br><span class="line"> 子进程 已安装 post-installation 脚本 返回错误状态 1</span><br><span class="line">dpkg: 依赖关系问题使得 xfonts-utils 的配置工作不能继续：</span><br><span class="line"> xfonts-utils 依赖于 x11-common；然而：</span><br><span class="line">  软件包 x11-common 尚未配置。</span><br><span class="line"></span><br><span class="line">dpkg: 处理软件包 xfonts-utils (--configure)时出错：</span><br><span class="line"> 依赖关系问题 - 仍未被配置</span><br><span class="line">dpkg: 依赖关系问题使得 gsfonts-x11 的配置工作不能继续：</span><br><span class="line"> gsfonts-x11 依赖于 xfonts-utils (&gt;= 1:7.5+2)；然而：</span><br><span class="line">  软件包 xfonts-utils 尚未配置。</span><br><span class="line"></span><br><span class="line">dpkg: 处理软件包 gsfonts-x11 (--configure)时出错：</span><br><span class="line"> 依赖关系问题 - 仍未被配置</span><br><span class="line">dpkg: 依赖关系问题使得 python-tk 的配置工作不能继续：</span><br><span class="line"> python-tk 依赖于 blt (&gt;= 2.4z-9)；然而：</span><br><span class="line">  软件包 blt 尚未配置。</span><br><span class="line"> python-tk 依赖于 libtk8.6 (&gt;= 8.6.0)；然而：</span><br><span class="line">  软件包 libtk8.6:armhf 尚未配置。</span><br><span class="line"> python-tk 依赖于 tk8.6-blt2.5 (&gt;= 2.5.3)；然而：</span><br><span class="line">  软件包 tk8.6-blt2.5 尚未配置。</span><br><span class="line"></span><br><span class="line">dpkg: 处理软件包 python-tk (--configure)时出错：</span><br><span class="line"> 依赖关系问题 - 仍未被配置</span><br><span class="line">dpkg: 依赖关系问题使得 idle-python2.7 的配置工作不能继续：</span><br><span class="line"> idle-python2.7 依赖于 python-tk (&gt;= 2.6~a3)；然而：</span><br><span class="line">  软件包 python-tk 尚未配置。</span><br><span class="line"> idle-python2.7 依赖于 python2.7-tk；然而：</span><br><span class="line">  未安装软件包 python2.7-tk。</span><br><span class="line">  软件包 python-tk 提供了 python2.7-tk，但它尚未被配置。</span><br><span class="line"></span><br><span class="line">dpkg: 处理软件包 idle-python2.7 (--configure)时出错：</span><br><span class="line"> 依赖关系问题 - 仍未被配置</span><br><span class="line">dpkg: 依赖关系问题使得 libice6:armhf 的配置工作不能继续：</span><br><span class="line"> libice6:armhf 依赖于 x11-common；然而：</span><br><span class="line">  软件包 x11-common 尚未配置。</span><br><span class="line"></span><br><span class="line">dpkg: 处理软件包 libice6:armhf (--configure)时出错：</span><br><span class="line"> 依赖关系问题 - 仍未被配置</span><br><span class="line">dpkg: 依赖关系问题使得 libsm6:armhf 的配置工作不能继续：</span><br><span class="line"> libsm6:armhf 依赖于 libice6 (&gt;= 1:1.0.0)；然而：</span><br><span class="line">  软件包 libice6:armhf 尚未配置。</span><br><span class="line"></span><br><span class="line">dpkg: 处理软件包 libsm6:armhf (--configure)时出错：</span><br><span class="line"> 依赖关系问题 - 仍未被配置</span><br><span class="line">dpkg: 依赖关系问题使得 libxt6:armhf 的配置工作不能继续：</span><br><span class="line"> libxt6:armhf 依赖于 libice6 (&gt;= 1:1.0.0)；然而：</span><br><span class="line">  软件包 libice6:armhf 尚未配置。</span><br><span class="line"> libxt6:armhf 依赖于 libsm6；然而：</span><br><span class="line">  软件包 libsm6:armhf 尚未配置。</span><br><span class="line"></span><br><span class="line">dpkg: 处理软件包 libxt6:armhf (--configure)时出错：</span><br><span class="line"> 依赖关系问题 - 仍未被配置</span><br><span class="line">dpkg: 依赖关系问题使得 libaudio2:armhf 的配置工作不能继续：</span><br><span class="line"> libaudio2:armhf 依赖于 libxt6；然而：</span><br><span class="line">  软件包 libxt6:armhf 尚未配置。</span><br><span class="line"></span><br><span class="line">dpkg: 处理软件包 libaudio2:armhf (--configure)时出错：</span><br><span class="line"> 依赖关系问题 - 仍未被配置</span><br><span class="line">dpkg: 依赖关系问题使得 libxmu6:armhf 的配置工作不能继续：</span><br><span class="line"> libxmu6:armhf 依赖于 libxt6；然而：</span><br><span class="line">  软件包 libxt6:armhf 尚未配置。</span><br><span class="line"></span><br><span class="line">dpkg: 处理软件包 libxmu6:armhf (--configure)时出错：</span><br><span class="line"> 依赖关系问题 - 仍未被配置</span><br><span class="line">dpkg: 依赖关系问题使得 libgtkglext1:armhf 的配置工作不能继续：</span><br><span class="line"> libgtkglext1:armhf 依赖于 libice6 (&gt;= 1:1.0.0)；然而：</span><br><span class="line">  软件包 libice6:armhf 尚未配置。</span><br><span class="line"> libgtkglext1:armhf 依赖于 libsm6；然而：</span><br><span class="line">  软件包 libsm6:armhf 尚未配置。</span><br><span class="line"> libgtkglext1:armhf 依赖于 libxmu6；然而：</span><br><span class="line">  软件包 libxmu6:armhf 尚未配置。</span><br><span class="line"> libgtkglext1:armhf 依赖于 libxt6；然而：</span><br><span class="line">  软件包 libxt6:armhf 尚未配置。</span><br><span class="line"></span><br><span class="line">dpkg: 处理软件包 libgtkglext1:armhf (--configure)时出错：</span><br><span class="line"> 依赖关系问题 - 仍未被配置</span><br><span class="line">dpkg: 依赖关系问题使得 libxaw7:armhf 的配置工作不能继续：</span><br><span class="line"> libxaw7:armhf 依赖于 libxmu6；然而：</span><br><span class="line">  软件包 libxmu6:armhf 尚未配置。</span><br><span class="line"> libxaw7:armhf 依赖于 libxt6；然而：</span><br><span class="line">  软件包 libxt6:armhf 尚未配置。</span><br><span class="line"></span><br><span class="line">dpkg: 处理软件包 libxaw7:armhf (--configure)时出错：</span><br><span class="line"> 依赖关系问题 - 仍未被配置</span><br><span class="line">dpkg: 依赖关系问题使得 x11-xkb-utils 的配置工作不能继续：</span><br><span class="line"> x11-xkb-utils 依赖于 libxaw7；然而：</span><br><span class="line">  软件包 libxaw7:armhf 尚未配置。</span><br><span class="line"> x11-xkb-utils 依赖于 libxt6；然而：</span><br><span class="line">  软件包 libxt6:armhf 尚未配置。</span><br><span class="line"></span><br><span class="line">dpkg: 处理软件包 x11-xkb-utils (--configure)时出错：</span><br><span class="line"> 依赖关系问题 - 仍未被配置</span><br><span class="line">dpkg: 依赖关系问题使得 libxklavier16:armhf 的配置工作不能继续：</span><br><span class="line"> libxklavier16:armhf 依赖于 x11-xkb-utils；然而：</span><br><span class="line">  软件包 x11-xkb-utils 尚未配置。</span><br><span class="line"></span><br><span class="line">dpkg: 处理软件包 libxklavier16:armhf (--configure)时出错：</span><br><span class="line"> 依赖关系问题 - 仍未被配置</span><br><span class="line">dpkg: 依赖关系问题使得 liblightdm-gobject-1-0:armhf 的配置工作不能继续：</span><br><span class="line"> liblightdm-gobject-1-0:armhf 依赖于 libxklavier16 (&gt;= 5.0)；然而：</span><br><span class="line">  软件包 libxklavier16:armhf 尚未配置。</span><br><span class="line"></span><br><span class="line">dpkg: 处理软件包 liblightdm-gobject-1-0:armhf (--configure)时出错：</span><br><span class="line"> 依赖关系问题 - 仍未被配置</span><br><span class="line">dpkg: 依赖关系问题使得 libxtst6:armhf 的配置工作不能继续：</span><br><span class="line"> libxtst6:armhf 依赖于 x11-common；然而：</span><br><span class="line">  软件包 x11-common 尚未配置。</span><br><span class="line"></span><br><span class="line">dpkg: 处理软件包 libxtst6:armhf (--configure)时出错：</span><br><span class="line"> 依赖关系问题 - 仍未被配置</span><br><span class="line">正在设置 motion (3.2.12+git20140228-4+b2) ...</span><br><span class="line">insserv: FATAL: service udev is missed in the runlevels 2 3 4 5 to use service raspi-config</span><br><span class="line">insserv: exiting now!</span><br><span class="line">update-rc.d: error: insserv rejected the script header</span><br><span class="line">dpkg: 处理软件包 motion (--configure)时出错：</span><br><span class="line"> 子进程 已安装 post-installation 脚本 返回错误状态 1</span><br><span class="line">dpkg: 依赖关系问题使得 pi-greeter 的配置工作不能继续：</span><br><span class="line"> pi-greeter 依赖于 liblightdm-gobject-1-0 (&gt;= 1.8.7)；然而：</span><br><span class="line">  软件包 liblightdm-gobject-1-0:armhf 尚未配置。</span><br><span class="line"></span><br><span class="line">dpkg: 处理软件包 pi-greeter (--configure)时出错：</span><br><span class="line"> 依赖关系问题 - 仍未被配置</span><br><span class="line">正在设置 raspi-config (20210119) ...</span><br><span class="line">insserv: FATAL: service udev is missed in the runlevels 2 3 4 5 to use service raspi-config</span><br><span class="line">insserv: exiting now!</span><br><span class="line">update-rc.d: error: insserv rejected the script header</span><br><span class="line">dpkg: 处理软件包 raspi-config (--configure)时出错：</span><br><span class="line"> 子进程 已安装 post-installation 脚本 返回错误状态 1</span><br><span class="line">dpkg: 依赖关系问题使得 rc-gui 的配置工作不能继续：</span><br><span class="line"> rc-gui 依赖于 raspi-config；然而：</span><br><span class="line">  软件包 raspi-config 尚未配置。</span><br><span class="line"></span><br><span class="line">dpkg: 处理软件包 rc-gui (--configure)时出错：</span><br><span class="line"> 依赖关系问题 - 仍未被配置</span><br><span class="line">dpkg: 依赖关系问题使得 x11-utils 的配置工作不能继续：</span><br><span class="line"> x11-utils 依赖于 libxaw7；然而：</span><br><span class="line">  软件包 libxaw7:armhf 尚未配置。</span><br><span class="line"> x11-utils 依赖于 libxmu6；然而：</span><br><span class="line">  软件包 libxmu6:armhf 尚未配置。</span><br><span class="line"> x11-utils 依赖于 libxt6 (&gt;= 1:1.1.0)；然而：</span><br><span class="line">  软件包 libxt6:armhf 尚未配置。</span><br><span class="line"> x11-utils 依赖于 libxtst6；然而：</span><br><span class="line">  软件包 libxtst6:armhf 尚未配置。</span><br><span class="line"></span><br><span class="line">dpkg: 处理软件包 x11-utils (--configure)时出错：</span><br><span class="line"> 依赖关系问题 - 仍未被配置</span><br><span class="line">dpkg: 依赖关系问题使得 x2x 的配置工作不能继续：</span><br><span class="line"> x2x 依赖于 libxtst6；然而：</span><br><span class="line">  软件包 libxtst6:armhf 尚未配置。</span><br><span class="line"></span><br><span class="line">dpkg: 处理软件包 x2x (--configure)时出错：</span><br><span class="line"> 依赖关系问题 - 仍未被配置</span><br><span class="line">dpkg: 依赖关系问题使得 xfonts-100dpi 的配置工作不能继续：</span><br><span class="line"> xfonts-100dpi 依赖于 xfonts-utils (&gt;= 1:7.5+2)；然而：</span><br><span class="line">  软件包 xfonts-utils 尚未配置。</span><br><span class="line"></span><br><span class="line">dpkg: 处理软件包 xfonts-100dpi (--configure)时出错：</span><br><span class="line"> 依赖关系问题 - 仍未被配置</span><br><span class="line">dpkg: 依赖关系问题使得 xfonts-base 的配置工作不能继续：</span><br><span class="line"> xfonts-base 依赖于 xfonts-utils (&gt;= 1:7.5+2)；然而：</span><br><span class="line">  软件包 xfonts-utils 尚未配置。</span><br><span class="line"></span><br><span class="line">dpkg: 处理软件包 xfonts-base (--configure)时出错：</span><br><span class="line"> 依赖关系问题 - 仍未被配置</span><br><span class="line">dpkg: 依赖关系问题使得 xinit 的配置工作不能继续：</span><br><span class="line"> xinit 依赖于 x11-common；然而：</span><br><span class="line">  软件包 x11-common 尚未配置。</span><br><span class="line"></span><br><span class="line">dpkg: 处理软件包 xinit (--configure)时出错：</span><br><span class="line"> 依赖关系问题 - 仍未被配置</span><br><span class="line">dpkg: 依赖关系问题使得 xserver-common 的配置工作不能继续：</span><br><span class="line"> xserver-common 依赖于 x11-common；然而：</span><br><span class="line">  软件包 x11-common 尚未配置。</span><br><span class="line"> xserver-common 依赖于 x11-xkb-utils；然而：</span><br><span class="line">  软件包 x11-xkb-utils 尚未配置。</span><br><span class="line"></span><br><span class="line">dpkg: 处理软件包 xserver-common (--configure)时出错：</span><br><span class="line"> 依赖关系问题 - 仍未被配置</span><br><span class="line">正在设置 fake-hwclock (0.11+rpt1) ...</span><br><span class="line">update-rc.d: warning: start and stop actions are no longer supported; falling back to defaults</span><br><span class="line">insserv: FATAL: service udev is missed in the runlevels 2 3 4 5 to use service raspi-config</span><br><span class="line">insserv: exiting now!</span><br><span class="line">update-rc.d: error: insserv rejected the script header</span><br><span class="line">dpkg: 处理软件包 fake-hwclock (--configure)时出错：</span><br><span class="line"> 子进程 已安装 post-installation 脚本 返回错误状态 1</span><br><span class="line">正在设置 triggerhappy (0.5.0-1) ...</span><br><span class="line">insserv: FATAL: service udev is missed in the runlevels 2 3 4 5 to use service raspi-config</span><br><span class="line">insserv: exiting now!</span><br><span class="line">update-rc.d: error: insserv rejected the script header</span><br><span class="line">dpkg: 处理软件包 triggerhappy (--configure)时出错：</span><br><span class="line"> 子进程 已安装 post-installation 脚本 返回错误状态 1</span><br><span class="line">正在设置 mariadb-common (10.0.38-0+deb8u1) ...</span><br><span class="line">正在设置 libmariadbclient18:armhf (5.5.39-2) ...</span><br><span class="line">正在设置 libpq5:armhf (9.4.26-0+deb8u1) ...</span><br><span class="line">正在处理用于 libc-bin (2.19-18+deb8u10) 的触发器 ...</span><br><span class="line">在处理时有错误发生：</span><br><span class="line"> console-setup-linux</span><br><span class="line"> console-setup</span><br><span class="line"> x11-common</span><br><span class="line"> libxss1:armhf</span><br><span class="line"> libtk8.6:armhf</span><br><span class="line"> tk8.6-blt2.5</span><br><span class="line"> blt</span><br><span class="line"> dphys-swapfile</span><br><span class="line"> xfonts-utils</span><br><span class="line"> gsfonts-x11</span><br><span class="line"> python-tk</span><br><span class="line"> idle-python2.7</span><br><span class="line"> libice6:armhf</span><br><span class="line"> libsm6:armhf</span><br><span class="line"> libxt6:armhf</span><br><span class="line"> libaudio2:armhf</span><br><span class="line"> libxmu6:armhf</span><br><span class="line"> libgtkglext1:armhf</span><br><span class="line"> libxaw7:armhf</span><br><span class="line"> x11-xkb-utils</span><br><span class="line"> libxklavier16:armhf</span><br><span class="line"> liblightdm-gobject-1-0:armhf</span><br><span class="line"> libxtst6:armhf</span><br><span class="line"> motion</span><br><span class="line"> pi-greeter</span><br><span class="line"> raspi-config</span><br><span class="line"> rc-gui</span><br><span class="line"> x11-utils</span><br><span class="line"> x2x</span><br><span class="line"> xfonts-100dpi</span><br><span class="line"> xfonts-base</span><br><span class="line"> xinit</span><br><span class="line"> xserver-common</span><br><span class="line"> fake-hwclock</span><br><span class="line"> triggerhappy</span><br><span class="line">E: Sub-process /usr/bin/dpkg returned an error code (1)</span><br><span class="line">pi@raspberrypi:~ $ sudo apt-get install python-pip python-dev libssl-dev</span><br><span class="line">正在读取软件包列表... 完成</span><br><span class="line">正在分析软件包的依赖关系树</span><br><span class="line">正在读取状态信息... 完成</span><br><span class="line">有一些软件包无法被安装。如果您用的是 unstable 发行版，这也许是</span><br><span class="line">因为系统无法达到您要求的状态造成的。该版本中可能会有一些您需要的软件</span><br><span class="line">包尚未被创建或是它们已被从新到(Incoming)目录移出。</span><br><span class="line">下列信息可能会对解决问题有所帮助：</span><br><span class="line"></span><br><span class="line">下列软件包有未满足的依赖关系：</span><br><span class="line"> libssl-dev : 依赖: libssl1.1 (= 1.1.1d-0+deb10u4+rpt1) 但是它将不会被安装</span><br><span class="line">E: 无法修正错误，因为您要求某些软件包保持现状，就是它们破坏了软件包间的依赖关系。</span><br><span class="line">pi@raspberrypi:~ $ sudo apt-get install ffmpeg v4l-utils</span><br><span class="line">正在读取软件包列表... 完成</span><br><span class="line">正在分析软件包的依赖关系树</span><br><span class="line">正在读取状态信息... 完成</span><br><span class="line">v4l-utils 已经是最新的版本。</span><br><span class="line">有一些软件包无法被安装。如果您用的是 unstable 发行版，这也许是</span><br><span class="line">因为系统无法达到您要求的状态造成的。该版本中可能会有一些您需要的软件</span><br><span class="line">包尚未被创建或是它们已被从新到(Incoming)目录移出。</span><br><span class="line">下列信息可能会对解决问题有所帮助：</span><br><span class="line"></span><br><span class="line">下列软件包有未满足的依赖关系：</span><br><span class="line"> ffmpeg : 依赖: libavcodec58 (= 7:4.1.6-1~deb10u1+rpt1)</span><br><span class="line">          依赖: libavdevice58 (= 7:4.1.6-1~deb10u1+rpt1) 但是它将不会被安装</span><br><span class="line">          依赖: libavfilter7 (= 7:4.1.6-1~deb10u1+rpt1)</span><br><span class="line">          依赖: libavformat58 (= 7:4.1.6-1~deb10u1+rpt1) 但是它将不会被安装</span><br><span class="line">          依赖: libavresample4 (= 7:4.1.6-1~deb10u1+rpt1) 但是它将不会被安装</span><br><span class="line">          依赖: libavutil56 (= 7:4.1.6-1~deb10u1+rpt1) 但是它将不会被安装</span><br><span class="line">          依赖: libpostproc55 (= 7:4.1.6-1~deb10u1+rpt1) 但是它将不会被安装</span><br><span class="line">          依赖: libsdl2-2.0-0 (&gt;= 2.0.9) 但是它将不会被安装</span><br><span class="line">          依赖: libswresample3 (= 7:4.1.6-1~deb10u1+rpt1) 但是它将不会被安装</span><br><span class="line">          依赖: libswscale5 (= 7:4.1.6-1~deb10u1+rpt1) 但是它将不会被安装</span><br><span class="line">E: 无法修正错误，因为您要求某些软件包保持现状，就是它们破坏了软件包间的依赖关系。</span><br><span class="line">pi@raspberrypi:~ $ sudo apt-get install motion</span><br><span class="line">正在读取软件包列表... 完成</span><br><span class="line">正在分析软件包的依赖关系树</span><br><span class="line">正在读取状态信息... 完成</span><br><span class="line">motion 已经是最新的版本。</span><br><span class="line">下列软件包是自动安装的并且现在不需要了：</span><br><span class="line">  libasprintf0c2 libboost-filesystem1.55.0 libboost-program-options1.55.0</span><br><span class="line">  libboost-regex1.55.0 libsoxr0 lxkeymap python-gobject python-xklavier tcpd</span><br><span class="line">使用&#x27;apt-get autoremove&#x27;来卸载它(它们)。</span><br><span class="line">升级了 0 个软件包，新安装了 0 个软件包，要卸载 0 个软件包，有 106 个软件包未被升级。</span><br><span class="line">有 35 个软件包没有被完全安装或卸载。</span><br><span class="line">解压缩后会消耗掉 0 B 的额外空间。</span><br><span class="line">您希望继续执行吗？ [Y/n] y</span><br><span class="line">正在设置 console-setup-linux (1.193~deb10u1) ...</span><br><span class="line">insserv: FATAL: service udev is missed in the runlevels 2 3 4 5 to use service raspi-config</span><br><span class="line">insserv: exiting now!</span><br><span class="line">update-rc.d: error: insserv rejected the script header</span><br><span class="line">dpkg: 处理软件包 console-setup-linux (--configure)时出错：</span><br><span class="line"> 子进程 已安装 post-installation 脚本 返回错误状态 1</span><br><span class="line">dpkg: 依赖关系问题使得 console-setup 的配置工作不能继续：</span><br><span class="line"> console-setup 依赖于 console-setup-linux | console-setup-freebsd | hurd；然而：</span><br><span class="line">  软件包 console-setup-linux 尚未配置。</span><br><span class="line">  未安装软件包 console-setup-freebsd。</span><br><span class="line">  未安装软件包 hurd。</span><br><span class="line"></span><br><span class="line">dpkg: 处理软件包 console-setup (--configure)时出错：</span><br><span class="line"> 依赖关系问题 - 仍未被配置</span><br><span class="line">正在设置 x11-common (1:7.7+19) ...</span><br><span class="line">update-rc.d: warning: start and stop actions are no longer supported; falling back to defaults</span><br><span class="line">insserv: FATAL: service udev is missed in the runlevels 2 3 4 5 to use service raspi-config</span><br><span class="line">insserv: exiting now!</span><br><span class="line">update-rc.d: error: insserv rejected the script header</span><br><span class="line">dpkg: 处理软件包 x11-common (--configure)时出错：</span><br><span class="line"> 子进程 已安装 post-installation 脚本 返回错误状态 1</span><br><span class="line">dpkg: 依赖关系问题使得 libxss1:armhf 的配置工作不能继续：</span><br><span class="line"> libxss1:armhf 依赖于 x11-common；然而：</span><br><span class="line">  软件包 x11-common 尚未配置。</span><br><span class="line"></span><br><span class="line">dpkg: 处理软件包 libxss1:armhf (--configure)时出错：</span><br><span class="line"> 依赖关系问题 - 仍未被配置</span><br><span class="line">dpkg: 依赖关系问题使得 libtk8.6:armhf 的配置工作不能继续：</span><br><span class="line"> libtk8.6:armhf 依赖于 libxss1；然而：</span><br><span class="line">  软件包 libxss1:armhf 尚未配置。</span><br><span class="line"></span><br><span class="line">dpkg: 处理软件包 libtk8.6:armhf (--configure)时出错：</span><br><span class="line"> 依赖关系问题 - 仍未被配置</span><br><span class="line">dpkg: 依赖关系问题使得 tk8.6-blt2.5 的配置工作不能继续：</span><br><span class="line"> tk8.6-blt2.5 依赖于 libtk8.6 (&gt;= 8.6.0)；然而：</span><br><span class="line">  软件包 libtk8.6:armhf 尚未配置。</span><br><span class="line"></span><br><span class="line">dpkg: 处理软件包 tk8.6-blt2.5 (--configure)时出错：</span><br><span class="line"> 依赖关系问题 - 仍未被配置</span><br><span class="line">dpkg: 依赖关系问题使得 blt 的配置工作不能继续：</span><br><span class="line"> blt 依赖于 tk8.6-blt2.5 (= 2.5.3+dfsg-4)；然而：</span><br><span class="line">  软件包 tk8.6-blt2.5 尚未配置。</span><br><span class="line"></span><br><span class="line">dpkg: 处理软件包 blt (--configure)时出错：</span><br><span class="line"> 依赖关系问题 - 仍未被配置</span><br><span class="line">正在设置 dphys-swapfile (20100506-5+rpt2) ...</span><br><span class="line">insserv: FATAL: service udev is missed in the runlevels 2 3 4 5 to use service raspi-config</span><br><span class="line">insserv: exiting now!</span><br><span class="line">update-rc.d: error: insserv rejected the script header</span><br><span class="line">dpkg: 处理软件包 dphys-swapfile (--configure)时出错：</span><br><span class="line"> 子进程 已安装 post-installation 脚本 返回错误状态 1</span><br><span class="line">dpkg: 依赖关系问题使得 xfonts-utils 的配置工作不能继续：</span><br><span class="line"> xfonts-utils 依赖于 x11-common；然而：</span><br><span class="line">  软件包 x11-common 尚未配置。</span><br><span class="line"></span><br><span class="line">dpkg: 处理软件包 xfonts-utils (--configure)时出错：</span><br><span class="line"> 依赖关系问题 - 仍未被配置</span><br><span class="line">dpkg: 依赖关系问题使得 gsfonts-x11 的配置工作不能继续：</span><br><span class="line"> gsfonts-x11 依赖于 xfonts-utils (&gt;= 1:7.5+2)；然而：</span><br><span class="line">  软件包 xfonts-utils 尚未配置。</span><br><span class="line"></span><br><span class="line">dpkg: 处理软件包 gsfonts-x11 (--configure)时出错：</span><br><span class="line"> 依赖关系问题 - 仍未被配置</span><br><span class="line">dpkg: 依赖关系问题使得 python-tk 的配置工作不能继续：</span><br><span class="line"> python-tk 依赖于 blt (&gt;= 2.4z-9)；然而：</span><br><span class="line">  软件包 blt 尚未配置。</span><br><span class="line"> python-tk 依赖于 libtk8.6 (&gt;= 8.6.0)；然而：</span><br><span class="line">  软件包 libtk8.6:armhf 尚未配置。</span><br><span class="line"> python-tk 依赖于 tk8.6-blt2.5 (&gt;= 2.5.3)；然而：</span><br><span class="line">  软件包 tk8.6-blt2.5 尚未配置。</span><br><span class="line"></span><br><span class="line">dpkg: 处理软件包 python-tk (--configure)时出错：</span><br><span class="line"> 依赖关系问题 - 仍未被配置</span><br><span class="line">dpkg: 依赖关系问题使得 idle-python2.7 的配置工作不能继续：</span><br><span class="line"> idle-python2.7 依赖于 python-tk (&gt;= 2.6~a3)；然而：</span><br><span class="line">  软件包 python-tk 尚未配置。</span><br><span class="line"> idle-python2.7 依赖于 python2.7-tk；然而：</span><br><span class="line">  未安装软件包 python2.7-tk。</span><br><span class="line">  软件包 python-tk 提供了 python2.7-tk，但它尚未被配置。</span><br><span class="line"></span><br><span class="line">dpkg: 处理软件包 idle-python2.7 (--configure)时出错：</span><br><span class="line"> 依赖关系问题 - 仍未被配置</span><br><span class="line">dpkg: 依赖关系问题使得 libice6:armhf 的配置工作不能继续：</span><br><span class="line"> libice6:armhf 依赖于 x11-common；然而：</span><br><span class="line">  软件包 x11-common 尚未配置。</span><br><span class="line"></span><br><span class="line">dpkg: 处理软件包 libice6:armhf (--configure)时出错：</span><br><span class="line"> 依赖关系问题 - 仍未被配置</span><br><span class="line">dpkg: 依赖关系问题使得 libsm6:armhf 的配置工作不能继续：</span><br><span class="line"> libsm6:armhf 依赖于 libice6 (&gt;= 1:1.0.0)；然而：</span><br><span class="line">  软件包 libice6:armhf 尚未配置。</span><br><span class="line"></span><br><span class="line">dpkg: 处理软件包 libsm6:armhf (--configure)时出错：</span><br><span class="line"> 依赖关系问题 - 仍未被配置</span><br><span class="line">dpkg: 依赖关系问题使得 libxt6:armhf 的配置工作不能继续：</span><br><span class="line"> libxt6:armhf 依赖于 libice6 (&gt;= 1:1.0.0)；然而：</span><br><span class="line">  软件包 libice6:armhf 尚未配置。</span><br><span class="line"> libxt6:armhf 依赖于 libsm6；然而：</span><br><span class="line">  软件包 libsm6:armhf 尚未配置。</span><br><span class="line"></span><br><span class="line">dpkg: 处理软件包 libxt6:armhf (--configure)时出错：</span><br><span class="line"> 依赖关系问题 - 仍未被配置</span><br><span class="line">dpkg: 依赖关系问题使得 libaudio2:armhf 的配置工作不能继续：</span><br><span class="line"> libaudio2:armhf 依赖于 libxt6；然而：</span><br><span class="line">  软件包 libxt6:armhf 尚未配置。</span><br><span class="line"></span><br><span class="line">dpkg: 处理软件包 libaudio2:armhf (--configure)时出错：</span><br><span class="line"> 依赖关系问题 - 仍未被配置</span><br><span class="line">dpkg: 依赖关系问题使得 libxmu6:armhf 的配置工作不能继续：</span><br><span class="line"> libxmu6:armhf 依赖于 libxt6；然而：</span><br><span class="line">  软件包 libxt6:armhf 尚未配置。</span><br><span class="line"></span><br><span class="line">dpkg: 处理软件包 libxmu6:armhf (--configure)时出错：</span><br><span class="line"> 依赖关系问题 - 仍未被配置</span><br><span class="line">dpkg: 依赖关系问题使得 libgtkglext1:armhf 的配置工作不能继续：</span><br><span class="line"> libgtkglext1:armhf 依赖于 libice6 (&gt;= 1:1.0.0)；然而：</span><br><span class="line">  软件包 libice6:armhf 尚未配置。</span><br><span class="line"> libgtkglext1:armhf 依赖于 libsm6；然而：</span><br><span class="line">  软件包 libsm6:armhf 尚未配置。</span><br><span class="line"> libgtkglext1:armhf 依赖于 libxmu6；然而：</span><br><span class="line">  软件包 libxmu6:armhf 尚未配置。</span><br><span class="line"> libgtkglext1:armhf 依赖于 libxt6；然而：</span><br><span class="line">  软件包 libxt6:armhf 尚未配置。</span><br><span class="line"></span><br><span class="line">dpkg: 处理软件包 libgtkglext1:armhf (--configure)时出错：</span><br><span class="line"> 依赖关系问题 - 仍未被配置</span><br><span class="line">dpkg: 依赖关系问题使得 libxaw7:armhf 的配置工作不能继续：</span><br><span class="line"> libxaw7:armhf 依赖于 libxmu6；然而：</span><br><span class="line">  软件包 libxmu6:armhf 尚未配置。</span><br><span class="line"> libxaw7:armhf 依赖于 libxt6；然而：</span><br><span class="line">  软件包 libxt6:armhf 尚未配置。</span><br><span class="line"></span><br><span class="line">dpkg: 处理软件包 libxaw7:armhf (--configure)时出错：</span><br><span class="line"> 依赖关系问题 - 仍未被配置</span><br><span class="line">dpkg: 依赖关系问题使得 x11-xkb-utils 的配置工作不能继续：</span><br><span class="line"> x11-xkb-utils 依赖于 libxaw7；然而：</span><br><span class="line">  软件包 libxaw7:armhf 尚未配置。</span><br><span class="line"> x11-xkb-utils 依赖于 libxt6；然而：</span><br><span class="line">  软件包 libxt6:armhf 尚未配置。</span><br><span class="line"></span><br><span class="line">dpkg: 处理软件包 x11-xkb-utils (--configure)时出错：</span><br><span class="line"> 依赖关系问题 - 仍未被配置</span><br><span class="line">dpkg: 依赖关系问题使得 libxklavier16:armhf 的配置工作不能继续：</span><br><span class="line"> libxklavier16:armhf 依赖于 x11-xkb-utils；然而：</span><br><span class="line">  软件包 x11-xkb-utils 尚未配置。</span><br><span class="line"></span><br><span class="line">dpkg: 处理软件包 libxklavier16:armhf (--configure)时出错：</span><br><span class="line"> 依赖关系问题 - 仍未被配置</span><br><span class="line">dpkg: 依赖关系问题使得 liblightdm-gobject-1-0:armhf 的配置工作不能继续：</span><br><span class="line"> liblightdm-gobject-1-0:armhf 依赖于 libxklavier16 (&gt;= 5.0)；然而：</span><br><span class="line">  软件包 libxklavier16:armhf 尚未配置。</span><br><span class="line"></span><br><span class="line">dpkg: 处理软件包 liblightdm-gobject-1-0:armhf (--configure)时出错：</span><br><span class="line"> 依赖关系问题 - 仍未被配置</span><br><span class="line">dpkg: 依赖关系问题使得 libxtst6:armhf 的配置工作不能继续：</span><br><span class="line"> libxtst6:armhf 依赖于 x11-common；然而：</span><br><span class="line">  软件包 x11-common 尚未配置。</span><br><span class="line"></span><br><span class="line">dpkg: 处理软件包 libxtst6:armhf (--configure)时出错：</span><br><span class="line"> 依赖关系问题 - 仍未被配置</span><br><span class="line">正在设置 motion (3.2.12+git20140228-4+b2) ...</span><br><span class="line">insserv: FATAL: service udev is missed in the runlevels 2 3 4 5 to use service raspi-config</span><br><span class="line">insserv: exiting now!</span><br><span class="line">update-rc.d: error: insserv rejected the script header</span><br><span class="line">dpkg: 处理软件包 motion (--configure)时出错：</span><br><span class="line"> 子进程 已安装 post-installation 脚本 返回错误状态 1</span><br><span class="line">dpkg: 依赖关系问题使得 pi-greeter 的配置工作不能继续：</span><br><span class="line"> pi-greeter 依赖于 liblightdm-gobject-1-0 (&gt;= 1.8.7)；然而：</span><br><span class="line">  软件包 liblightdm-gobject-1-0:armhf 尚未配置。</span><br><span class="line"></span><br><span class="line">dpkg: 处理软件包 pi-greeter (--configure)时出错：</span><br><span class="line"> 依赖关系问题 - 仍未被配置</span><br><span class="line">正在设置 raspi-config (20210119) ...</span><br><span class="line">insserv: FATAL: service udev is missed in the runlevels 2 3 4 5 to use service raspi-config</span><br><span class="line">insserv: exiting now!</span><br><span class="line">update-rc.d: error: insserv rejected the script header</span><br><span class="line">dpkg: 处理软件包 raspi-config (--configure)时出错：</span><br><span class="line"> 子进程 已安装 post-installation 脚本 返回错误状态 1</span><br><span class="line">dpkg: 依赖关系问题使得 rc-gui 的配置工作不能继续：</span><br><span class="line"> rc-gui 依赖于 raspi-config；然而：</span><br><span class="line">  软件包 raspi-config 尚未配置。</span><br><span class="line"></span><br><span class="line">dpkg: 处理软件包 rc-gui (--configure)时出错：</span><br><span class="line"> 依赖关系问题 - 仍未被配置</span><br><span class="line">dpkg: 依赖关系问题使得 x11-utils 的配置工作不能继续：</span><br><span class="line"> x11-utils 依赖于 libxaw7；然而：</span><br><span class="line">  软件包 libxaw7:armhf 尚未配置。</span><br><span class="line"> x11-utils 依赖于 libxmu6；然而：</span><br><span class="line">  软件包 libxmu6:armhf 尚未配置。</span><br><span class="line"> x11-utils 依赖于 libxt6 (&gt;= 1:1.1.0)；然而：</span><br><span class="line">  软件包 libxt6:armhf 尚未配置。</span><br><span class="line"> x11-utils 依赖于 libxtst6；然而：</span><br><span class="line">  软件包 libxtst6:armhf 尚未配置。</span><br><span class="line"></span><br><span class="line">dpkg: 处理软件包 x11-utils (--configure)时出错：</span><br><span class="line"> 依赖关系问题 - 仍未被配置</span><br><span class="line">dpkg: 依赖关系问题使得 x2x 的配置工作不能继续：</span><br><span class="line"> x2x 依赖于 libxtst6；然而：</span><br><span class="line">  软件包 libxtst6:armhf 尚未配置。</span><br><span class="line"></span><br><span class="line">dpkg: 处理软件包 x2x (--configure)时出错：</span><br><span class="line"> 依赖关系问题 - 仍未被配置</span><br><span class="line">dpkg: 依赖关系问题使得 xfonts-100dpi 的配置工作不能继续：</span><br><span class="line"> xfonts-100dpi 依赖于 xfonts-utils (&gt;= 1:7.5+2)；然而：</span><br><span class="line">  软件包 xfonts-utils 尚未配置。</span><br><span class="line"></span><br><span class="line">dpkg: 处理软件包 xfonts-100dpi (--configure)时出错：</span><br><span class="line"> 依赖关系问题 - 仍未被配置</span><br><span class="line">dpkg: 依赖关系问题使得 xfonts-base 的配置工作不能继续：</span><br><span class="line"> xfonts-base 依赖于 xfonts-utils (&gt;= 1:7.5+2)；然而：</span><br><span class="line">  软件包 xfonts-utils 尚未配置。</span><br><span class="line"></span><br><span class="line">dpkg: 处理软件包 xfonts-base (--configure)时出错：</span><br><span class="line"> 依赖关系问题 - 仍未被配置</span><br><span class="line">dpkg: 依赖关系问题使得 xinit 的配置工作不能继续：</span><br><span class="line"> xinit 依赖于 x11-common；然而：</span><br><span class="line">  软件包 x11-common 尚未配置。</span><br><span class="line"></span><br><span class="line">dpkg: 处理软件包 xinit (--configure)时出错：</span><br><span class="line"> 依赖关系问题 - 仍未被配置</span><br><span class="line">dpkg: 依赖关系问题使得 xserver-common 的配置工作不能继续：</span><br><span class="line"> xserver-common 依赖于 x11-common；然而：</span><br><span class="line">  软件包 x11-common 尚未配置。</span><br><span class="line"> xserver-common 依赖于 x11-xkb-utils；然而：</span><br><span class="line">  软件包 x11-xkb-utils 尚未配置。</span><br><span class="line"></span><br><span class="line">dpkg: 处理软件包 xserver-common (--configure)时出错：</span><br><span class="line"> 依赖关系问题 - 仍未被配置</span><br><span class="line">正在设置 fake-hwclock (0.11+rpt1) ...</span><br><span class="line">update-rc.d: warning: start and stop actions are no longer supported; falling back to defaults</span><br><span class="line">insserv: FATAL: service udev is missed in the runlevels 2 3 4 5 to use service raspi-config</span><br><span class="line">insserv: exiting now!</span><br><span class="line">update-rc.d: error: insserv rejected the script header</span><br><span class="line">dpkg: 处理软件包 fake-hwclock (--configure)时出错：</span><br><span class="line"> 子进程 已安装 post-installation 脚本 返回错误状态 1</span><br><span class="line">正在设置 triggerhappy (0.5.0-1) ...</span><br><span class="line">insserv: FATAL: service udev is missed in the runlevels 2 3 4 5 to use service raspi-config</span><br><span class="line">insserv: exiting now!</span><br><span class="line">update-rc.d: error: insserv rejected the script header</span><br><span class="line">dpkg: 处理软件包 triggerhappy (--configure)时出错：</span><br><span class="line"> 子进程 已安装 post-installation 脚本 返回错误状态 1</span><br><span class="line">在处理时有错误发生：</span><br><span class="line"> console-setup-linux</span><br><span class="line"> console-setup</span><br><span class="line"> x11-common</span><br><span class="line"> libxss1:armhf</span><br><span class="line"> libtk8.6:armhf</span><br><span class="line"> tk8.6-blt2.5</span><br><span class="line"> blt</span><br><span class="line"> dphys-swapfile</span><br><span class="line"> xfonts-utils</span><br><span class="line"> gsfonts-x11</span><br><span class="line"> python-tk</span><br><span class="line"> idle-python2.7</span><br><span class="line"> libice6:armhf</span><br><span class="line"> libsm6:armhf</span><br><span class="line"> libxt6:armhf</span><br><span class="line"> libaudio2:armhf</span><br><span class="line"> libxmu6:armhf</span><br><span class="line"> libgtkglext1:armhf</span><br><span class="line"> libxaw7:armhf</span><br><span class="line"> x11-xkb-utils</span><br><span class="line"> libxklavier16:armhf</span><br><span class="line"> liblightdm-gobject-1-0:armhf</span><br><span class="line"> libxtst6:armhf</span><br><span class="line"> motion</span><br><span class="line"> pi-greeter</span><br><span class="line"> raspi-config</span><br><span class="line"> rc-gui</span><br><span class="line"> x11-utils</span><br><span class="line"> x2x</span><br><span class="line"> xfonts-100dpi</span><br><span class="line"> xfonts-base</span><br><span class="line"> xinit</span><br><span class="line"> xserver-common</span><br><span class="line"> fake-hwclock</span><br><span class="line"> triggerhappy</span><br><span class="line">E: Sub-process /usr/bin/dpkg returned an error code (1)</span><br><span class="line">pi@raspberrypi:~ $ sudo apt-get upgrade</span><br><span class="line">正在读取软件包列表... 完成</span><br><span class="line">正在分析软件包的依赖关系树</span><br><span class="line">正在读取状态信息... 完成</span><br><span class="line">正在对升级进行计算... 下列软件包是自动安装的并且现在不需要了：</span><br><span class="line">  libasprintf0c2 libboost-filesystem1.55.0 libboost-program-options1.55.0</span><br><span class="line">  libboost-regex1.55.0 libsoxr0 lxkeymap python-gobject python-xklavier tcpd</span><br><span class="line">使用&#x27;apt-get autoremove&#x27;来卸载它(它们)。</span><br><span class="line">完成</span><br><span class="line">下列软件包的版本将保持不变：</span><br><span class="line">  bluej bluez chromium-browser dhcpcd5 firmware-ralink gir1.2-gtk-3.0</span><br><span class="line">  greenfoot gstreamer1.0-omx gstreamer1.0-plugins-good libasound2</span><br><span class="line">  libasound2-data libcairo2 libcupsfilters1 libdrm-amdgpu1 libdrm2</span><br><span class="line">  libegl1-mesa libfm-gtk4 libfm-modules libfm4 libgbm1 libgl1-mesa-dri</span><br><span class="line">  libgl1-mesa-glx libglapi-mesa libgles2-mesa libgtk-3-0 libgtk-3-bin</span><br><span class="line">  libgtk2.0-0 libgtk2.0-bin libpam-modules libpam-modules-bin libplymouth4</span><br><span class="line">  libpolkit-agent-1-0 libpolkit-backend-1-0 libpolkit-gobject-1-0 libpulse0</span><br><span class="line">  libpulsedsp libreoffice libreoffice-avmedia-backend-gstreamer</span><br><span class="line">  libreoffice-base libreoffice-base-core libreoffice-base-drivers</span><br><span class="line">  libreoffice-calc libreoffice-common libreoffice-core libreoffice-draw</span><br><span class="line">  libreoffice-impress libreoffice-java-common libreoffice-math</span><br><span class="line">  libreoffice-report-builder-bin libreoffice-sdbc-hsqldb libreoffice-writer</span><br><span class="line">  librtimulib-dev librtimulib-utils librtimulib7 libsdl1.2debian</span><br><span class="line">  libwayland-egl1-mesa lxappearance-obconf lxinput lxpanel lxpanel-data</span><br><span class="line">  lxsession lxterminal mesa-va-drivers nodered omxplayer openbox openssl</span><br><span class="line">  pcmanfm pi-bluetooth pi-package pi-package-data pi-package-session piclone</span><br><span class="line">  pigpio pimixer pix-icons pix-plym-splash plymouth plymouth-themes</span><br><span class="line">  policykit-1 pulseaudio pulseaudio-module-bluetooth pulseaudio-utils</span><br><span class="line">  python-gpiozero python-openssl python-pip python-rpi.gpio python-rtimulib</span><br><span class="line">  python3-gpiozero python3-openssl python3-pip python3-rpi.gpio</span><br><span class="line">  python3-rtimulib python3-spidev python3-uno raspberrypi-net-mods</span><br><span class="line">  raspberrypi-sys-mods raspberrypi-ui-mods rpi-chromium-mods sense-emu-tools</span><br><span class="line">  uno-libs3 ure wolfram-engine x11-xserver-utils xserver-xorg-core</span><br><span class="line">  xserver-xorg-video-fbturbo</span><br><span class="line">升级了 0 个软件包，新安装了 0 个软件包，要卸载 0 个软件包，有 106 个软件包未被升级。</span><br><span class="line">有 35 个软件包没有被完全安装或卸载。</span><br><span class="line">解压缩后会消耗掉 0 B 的额外空间。</span><br><span class="line">您希望继续执行吗？ [Y/n] y</span><br><span class="line">正在设置 console-setup-linux (1.193~deb10u1) ...</span><br><span class="line">insserv: FATAL: service udev is missed in the runlevels 2 3 4 5 to use service raspi-config</span><br><span class="line">insserv: exiting now!</span><br><span class="line">update-rc.d: error: insserv rejected the script header</span><br><span class="line">dpkg: 处理软件包 console-setup-linux (--configure)时出错：</span><br><span class="line"> 子进程 已安装 post-installation 脚本 返回错误状态 1</span><br><span class="line">dpkg: 依赖关系问题使得 console-setup 的配置工作不能继续：</span><br><span class="line"> console-setup 依赖于 console-setup-linux | console-setup-freebsd | hurd；然而：</span><br><span class="line">  软件包 console-setup-linux 尚未配置。</span><br><span class="line">  未安装软件包 console-setup-freebsd。</span><br><span class="line">  未安装软件包 hurd。</span><br><span class="line"></span><br><span class="line">dpkg: 处理软件包 console-setup (--configure)时出错：</span><br><span class="line"> 依赖关系问题 - 仍未被配置</span><br><span class="line">正在设置 x11-common (1:7.7+19) ...</span><br><span class="line">update-rc.d: warning: start and stop actions are no longer supported; falling back to defaults</span><br><span class="line">insserv: FATAL: service udev is missed in the runlevels 2 3 4 5 to use service raspi-config</span><br><span class="line">insserv: exiting now!</span><br><span class="line">update-rc.d: error: insserv rejected the script header</span><br><span class="line">dpkg: 处理软件包 x11-common (--configure)时出错：</span><br><span class="line"> 子进程 已安装 post-installation 脚本 返回错误状态 1</span><br><span class="line">dpkg: 依赖关系问题使得 libxss1:armhf 的配置工作不能继续：</span><br><span class="line"> libxss1:armhf 依赖于 x11-common；然而：</span><br><span class="line">  软件包 x11-common 尚未配置。</span><br><span class="line"></span><br><span class="line">dpkg: 处理软件包 libxss1:armhf (--configure)时出错：</span><br><span class="line"> 依赖关系问题 - 仍未被配置</span><br><span class="line">dpkg: 依赖关系问题使得 libtk8.6:armhf 的配置工作不能继续：</span><br><span class="line"> libtk8.6:armhf 依赖于 libxss1；然而：</span><br><span class="line">  软件包 libxss1:armhf 尚未配置。</span><br><span class="line"></span><br><span class="line">dpkg: 处理软件包 libtk8.6:armhf (--configure)时出错：</span><br><span class="line"> 依赖关系问题 - 仍未被配置</span><br><span class="line">dpkg: 依赖关系问题使得 tk8.6-blt2.5 的配置工作不能继续：</span><br><span class="line"> tk8.6-blt2.5 依赖于 libtk8.6 (&gt;= 8.6.0)；然而：</span><br><span class="line">  软件包 libtk8.6:armhf 尚未配置。</span><br><span class="line"></span><br><span class="line">dpkg: 处理软件包 tk8.6-blt2.5 (--configure)时出错：</span><br><span class="line"> 依赖关系问题 - 仍未被配置</span><br><span class="line">dpkg: 依赖关系问题使得 blt 的配置工作不能继续：</span><br><span class="line"> blt 依赖于 tk8.6-blt2.5 (= 2.5.3+dfsg-4)；然而：</span><br><span class="line">  软件包 tk8.6-blt2.5 尚未配置。</span><br><span class="line"></span><br><span class="line">dpkg: 处理软件包 blt (--configure)时出错：</span><br><span class="line"> 依赖关系问题 - 仍未被配置</span><br><span class="line">正在设置 dphys-swapfile (20100506-5+rpt2) ...</span><br><span class="line">insserv: FATAL: service udev is missed in the runlevels 2 3 4 5 to use service raspi-config</span><br><span class="line">insserv: exiting now!</span><br><span class="line">update-rc.d: error: insserv rejected the script header</span><br><span class="line">dpkg: 处理软件包 dphys-swapfile (--configure)时出错：</span><br><span class="line"> 子进程 已安装 post-installation 脚本 返回错误状态 1</span><br><span class="line">dpkg: 依赖关系问题使得 xfonts-utils 的配置工作不能继续：</span><br><span class="line"> xfonts-utils 依赖于 x11-common；然而：</span><br><span class="line">  软件包 x11-common 尚未配置。</span><br><span class="line"></span><br><span class="line">dpkg: 处理软件包 xfonts-utils (--configure)时出错：</span><br><span class="line"> 依赖关系问题 - 仍未被配置</span><br><span class="line">dpkg: 依赖关系问题使得 gsfonts-x11 的配置工作不能继续：</span><br><span class="line"> gsfonts-x11 依赖于 xfonts-utils (&gt;= 1:7.5+2)；然而：</span><br><span class="line">  软件包 xfonts-utils 尚未配置。</span><br><span class="line"></span><br><span class="line">dpkg: 处理软件包 gsfonts-x11 (--configure)时出错：</span><br><span class="line"> 依赖关系问题 - 仍未被配置</span><br><span class="line">dpkg: 依赖关系问题使得 python-tk 的配置工作不能继续：</span><br><span class="line"> python-tk 依赖于 blt (&gt;= 2.4z-9)；然而：</span><br><span class="line">  软件包 blt 尚未配置。</span><br><span class="line"> python-tk 依赖于 libtk8.6 (&gt;= 8.6.0)；然而：</span><br><span class="line">  软件包 libtk8.6:armhf 尚未配置。</span><br><span class="line"> python-tk 依赖于 tk8.6-blt2.5 (&gt;= 2.5.3)；然而：</span><br><span class="line">  软件包 tk8.6-blt2.5 尚未配置。</span><br><span class="line"></span><br><span class="line">dpkg: 处理软件包 python-tk (--configure)时出错：</span><br><span class="line"> 依赖关系问题 - 仍未被配置</span><br><span class="line">dpkg: 依赖关系问题使得 idle-python2.7 的配置工作不能继续：</span><br><span class="line"> idle-python2.7 依赖于 python-tk (&gt;= 2.6~a3)；然而：</span><br><span class="line">  软件包 python-tk 尚未配置。</span><br><span class="line"> idle-python2.7 依赖于 python2.7-tk；然而：</span><br><span class="line">  未安装软件包 python2.7-tk。</span><br><span class="line">  软件包 python-tk 提供了 python2.7-tk，但它尚未被配置。</span><br><span class="line"></span><br><span class="line">dpkg: 处理软件包 idle-python2.7 (--configure)时出错：</span><br><span class="line"> 依赖关系问题 - 仍未被配置</span><br><span class="line">dpkg: 依赖关系问题使得 libice6:armhf 的配置工作不能继续：</span><br><span class="line"> libice6:armhf 依赖于 x11-common；然而：</span><br><span class="line">  软件包 x11-common 尚未配置。</span><br><span class="line"></span><br><span class="line">dpkg: 处理软件包 libice6:armhf (--configure)时出错：</span><br><span class="line"> 依赖关系问题 - 仍未被配置</span><br><span class="line">dpkg: 依赖关系问题使得 libsm6:armhf 的配置工作不能继续：</span><br><span class="line"> libsm6:armhf 依赖于 libice6 (&gt;= 1:1.0.0)；然而：</span><br><span class="line">  软件包 libice6:armhf 尚未配置。</span><br><span class="line"></span><br><span class="line">dpkg: 处理软件包 libsm6:armhf (--configure)时出错：</span><br><span class="line"> 依赖关系问题 - 仍未被配置</span><br><span class="line">dpkg: 依赖关系问题使得 libxt6:armhf 的配置工作不能继续：</span><br><span class="line"> libxt6:armhf 依赖于 libice6 (&gt;= 1:1.0.0)；然而：</span><br><span class="line">  软件包 libice6:armhf 尚未配置。</span><br><span class="line"> libxt6:armhf 依赖于 libsm6；然而：</span><br><span class="line">  软件包 libsm6:armhf 尚未配置。</span><br><span class="line"></span><br><span class="line">dpkg: 处理软件包 libxt6:armhf (--configure)时出错：</span><br><span class="line"> 依赖关系问题 - 仍未被配置</span><br><span class="line">dpkg: 依赖关系问题使得 libaudio2:armhf 的配置工作不能继续：</span><br><span class="line"> libaudio2:armhf 依赖于 libxt6；然而：</span><br><span class="line">  软件包 libxt6:armhf 尚未配置。</span><br><span class="line"></span><br><span class="line">dpkg: 处理软件包 libaudio2:armhf (--configure)时出错：</span><br><span class="line"> 依赖关系问题 - 仍未被配置</span><br><span class="line">dpkg: 依赖关系问题使得 libxmu6:armhf 的配置工作不能继续：</span><br><span class="line"> libxmu6:armhf 依赖于 libxt6；然而：</span><br><span class="line">  软件包 libxt6:armhf 尚未配置。</span><br><span class="line"></span><br><span class="line">dpkg: 处理软件包 libxmu6:armhf (--configure)时出错：</span><br><span class="line"> 依赖关系问题 - 仍未被配置</span><br><span class="line">dpkg: 依赖关系问题使得 libgtkglext1:armhf 的配置工作不能继续：</span><br><span class="line"> libgtkglext1:armhf 依赖于 libice6 (&gt;= 1:1.0.0)；然而：</span><br><span class="line">  软件包 libice6:armhf 尚未配置。</span><br><span class="line"> libgtkglext1:armhf 依赖于 libsm6；然而：</span><br><span class="line">  软件包 libsm6:armhf 尚未配置。</span><br><span class="line"> libgtkglext1:armhf 依赖于 libxmu6；然而：</span><br><span class="line">  软件包 libxmu6:armhf 尚未配置。</span><br><span class="line"> libgtkglext1:armhf 依赖于 libxt6；然而：</span><br><span class="line">  软件包 libxt6:armhf 尚未配置。</span><br><span class="line"></span><br><span class="line">dpkg: 处理软件包 libgtkglext1:armhf (--configure)时出错：</span><br><span class="line"> 依赖关系问题 - 仍未被配置</span><br><span class="line">dpkg: 依赖关系问题使得 libxaw7:armhf 的配置工作不能继续：</span><br><span class="line"> libxaw7:armhf 依赖于 libxmu6；然而：</span><br><span class="line">  软件包 libxmu6:armhf 尚未配置。</span><br><span class="line"> libxaw7:armhf 依赖于 libxt6；然而：</span><br><span class="line">  软件包 libxt6:armhf 尚未配置。</span><br><span class="line"></span><br><span class="line">dpkg: 处理软件包 libxaw7:armhf (--configure)时出错：</span><br><span class="line"> 依赖关系问题 - 仍未被配置</span><br><span class="line">dpkg: 依赖关系问题使得 x11-xkb-utils 的配置工作不能继续：</span><br><span class="line"> x11-xkb-utils 依赖于 libxaw7；然而：</span><br><span class="line">  软件包 libxaw7:armhf 尚未配置。</span><br><span class="line"> x11-xkb-utils 依赖于 libxt6；然而：</span><br><span class="line">  软件包 libxt6:armhf 尚未配置。</span><br><span class="line"></span><br><span class="line">dpkg: 处理软件包 x11-xkb-utils (--configure)时出错：</span><br><span class="line"> 依赖关系问题 - 仍未被配置</span><br><span class="line">dpkg: 依赖关系问题使得 libxklavier16:armhf 的配置工作不能继续：</span><br><span class="line"> libxklavier16:armhf 依赖于 x11-xkb-utils；然而：</span><br><span class="line">  软件包 x11-xkb-utils 尚未配置。</span><br><span class="line"></span><br><span class="line">dpkg: 处理软件包 libxklavier16:armhf (--configure)时出错：</span><br><span class="line"> 依赖关系问题 - 仍未被配置</span><br><span class="line">dpkg: 依赖关系问题使得 liblightdm-gobject-1-0:armhf 的配置工作不能继续：</span><br><span class="line"> liblightdm-gobject-1-0:armhf 依赖于 libxklavier16 (&gt;= 5.0)；然而：</span><br><span class="line">  软件包 libxklavier16:armhf 尚未配置。</span><br><span class="line"></span><br><span class="line">dpkg: 处理软件包 liblightdm-gobject-1-0:armhf (--configure)时出错：</span><br><span class="line"> 依赖关系问题 - 仍未被配置</span><br><span class="line">dpkg: 依赖关系问题使得 libxtst6:armhf 的配置工作不能继续：</span><br><span class="line"> libxtst6:armhf 依赖于 x11-common；然而：</span><br><span class="line">  软件包 x11-common 尚未配置。</span><br><span class="line"></span><br><span class="line">dpkg: 处理软件包 libxtst6:armhf (--configure)时出错：</span><br><span class="line"> 依赖关系问题 - 仍未被配置</span><br><span class="line">正在设置 motion (3.2.12+git20140228-4+b2) ...</span><br><span class="line">insserv: FATAL: service udev is missed in the runlevels 2 3 4 5 to use service raspi-config</span><br><span class="line">insserv: exiting now!</span><br><span class="line">update-rc.d: error: insserv rejected the script header</span><br><span class="line">dpkg: 处理软件包 motion (--configure)时出错：</span><br><span class="line"> 子进程 已安装 post-installation 脚本 返回错误状态 1</span><br><span class="line">dpkg: 依赖关系问题使得 pi-greeter 的配置工作不能继续：</span><br><span class="line"> pi-greeter 依赖于 liblightdm-gobject-1-0 (&gt;= 1.8.7)；然而：</span><br><span class="line">  软件包 liblightdm-gobject-1-0:armhf 尚未配置。</span><br><span class="line"></span><br><span class="line">dpkg: 处理软件包 pi-greeter (--configure)时出错：</span><br><span class="line"> 依赖关系问题 - 仍未被配置</span><br><span class="line">正在设置 raspi-config (20210119) ...</span><br><span class="line">insserv: FATAL: service udev is missed in the runlevels 2 3 4 5 to use service raspi-config</span><br><span class="line">insserv: exiting now!</span><br><span class="line">update-rc.d: error: insserv rejected the script header</span><br><span class="line">dpkg: 处理软件包 raspi-config (--configure)时出错：</span><br><span class="line"> 子进程 已安装 post-installation 脚本 返回错误状态 1</span><br><span class="line">dpkg: 依赖关系问题使得 rc-gui 的配置工作不能继续：</span><br><span class="line"> rc-gui 依赖于 raspi-config；然而：</span><br><span class="line">  软件包 raspi-config 尚未配置。</span><br><span class="line"></span><br><span class="line">dpkg: 处理软件包 rc-gui (--configure)时出错：</span><br><span class="line"> 依赖关系问题 - 仍未被配置</span><br><span class="line">dpkg: 依赖关系问题使得 x11-utils 的配置工作不能继续：</span><br><span class="line"> x11-utils 依赖于 libxaw7；然而：</span><br><span class="line">  软件包 libxaw7:armhf 尚未配置。</span><br><span class="line"> x11-utils 依赖于 libxmu6；然而：</span><br><span class="line">  软件包 libxmu6:armhf 尚未配置。</span><br><span class="line"> x11-utils 依赖于 libxt6 (&gt;= 1:1.1.0)；然而：</span><br><span class="line">  软件包 libxt6:armhf 尚未配置。</span><br><span class="line"> x11-utils 依赖于 libxtst6；然而：</span><br><span class="line">  软件包 libxtst6:armhf 尚未配置。</span><br><span class="line"></span><br><span class="line">dpkg: 处理软件包 x11-utils (--configure)时出错：</span><br><span class="line"> 依赖关系问题 - 仍未被配置</span><br><span class="line">dpkg: 依赖关系问题使得 x2x 的配置工作不能继续：</span><br><span class="line"> x2x 依赖于 libxtst6；然而：</span><br><span class="line">  软件包 libxtst6:armhf 尚未配置。</span><br><span class="line"></span><br><span class="line">dpkg: 处理软件包 x2x (--configure)时出错：</span><br><span class="line"> 依赖关系问题 - 仍未被配置</span><br><span class="line">dpkg: 依赖关系问题使得 xfonts-100dpi 的配置工作不能继续：</span><br><span class="line"> xfonts-100dpi 依赖于 xfonts-utils (&gt;= 1:7.5+2)；然而：</span><br><span class="line">  软件包 xfonts-utils 尚未配置。</span><br><span class="line"></span><br><span class="line">dpkg: 处理软件包 xfonts-100dpi (--configure)时出错：</span><br><span class="line"> 依赖关系问题 - 仍未被配置</span><br><span class="line">dpkg: 依赖关系问题使得 xfonts-base 的配置工作不能继续：</span><br><span class="line"> xfonts-base 依赖于 xfonts-utils (&gt;= 1:7.5+2)；然而：</span><br><span class="line">  软件包 xfonts-utils 尚未配置。</span><br><span class="line"></span><br><span class="line">dpkg: 处理软件包 xfonts-base (--configure)时出错：</span><br><span class="line"> 依赖关系问题 - 仍未被配置</span><br><span class="line">dpkg: 依赖关系问题使得 xinit 的配置工作不能继续：</span><br><span class="line"> xinit 依赖于 x11-common；然而：</span><br><span class="line">  软件包 x11-common 尚未配置。</span><br><span class="line"></span><br><span class="line">dpkg: 处理软件包 xinit (--configure)时出错：</span><br><span class="line"> 依赖关系问题 - 仍未被配置</span><br><span class="line">dpkg: 依赖关系问题使得 xserver-common 的配置工作不能继续：</span><br><span class="line"> xserver-common 依赖于 x11-common；然而：</span><br><span class="line">  软件包 x11-common 尚未配置。</span><br><span class="line"> xserver-common 依赖于 x11-xkb-utils；然而：</span><br><span class="line">  软件包 x11-xkb-utils 尚未配置。</span><br><span class="line"></span><br><span class="line">dpkg: 处理软件包 xserver-common (--configure)时出错：</span><br><span class="line"> 依赖关系问题 - 仍未被配置</span><br><span class="line">正在设置 fake-hwclock (0.11+rpt1) ...</span><br><span class="line">update-rc.d: warning: start and stop actions are no longer supported; falling back to defaults</span><br><span class="line">insserv: FATAL: service udev is missed in the runlevels 2 3 4 5 to use service raspi-config</span><br><span class="line">insserv: exiting now!</span><br><span class="line">update-rc.d: error: insserv rejected the script header</span><br><span class="line">dpkg: 处理软件包 fake-hwclock (--configure)时出错：</span><br><span class="line"> 子进程 已安装 post-installation 脚本 返回错误状态 1</span><br><span class="line">正在设置 triggerhappy (0.5.0-1) ...</span><br><span class="line">insserv: FATAL: service udev is missed in the runlevels 2 3 4 5 to use service raspi-config</span><br><span class="line">insserv: exiting now!</span><br><span class="line">update-rc.d: error: insserv rejected the script header</span><br><span class="line">dpkg: 处理软件包 triggerhappy (--configure)时出错：</span><br><span class="line"> 子进程 已安装 post-installation 脚本 返回错误状态 1</span><br><span class="line">在处理时有错误发生：</span><br><span class="line"> console-setup-linux</span><br><span class="line"> console-setup</span><br><span class="line"> x11-common</span><br><span class="line"> libxss1:armhf</span><br><span class="line"> libtk8.6:armhf</span><br><span class="line"> tk8.6-blt2.5</span><br><span class="line"> blt</span><br><span class="line"> dphys-swapfile</span><br><span class="line"> xfonts-utils</span><br><span class="line"> gsfonts-x11</span><br><span class="line"> python-tk</span><br><span class="line"> idle-python2.7</span><br><span class="line"> libice6:armhf</span><br><span class="line"> libsm6:armhf</span><br><span class="line"> libxt6:armhf</span><br><span class="line"> libaudio2:armhf</span><br><span class="line"> libxmu6:armhf</span><br><span class="line"> libgtkglext1:armhf</span><br><span class="line"> libxaw7:armhf</span><br><span class="line"> x11-xkb-utils</span><br><span class="line"> libxklavier16:armhf</span><br><span class="line"> liblightdm-gobject-1-0:armhf</span><br><span class="line"> libxtst6:armhf</span><br><span class="line"> motion</span><br><span class="line"> pi-greeter</span><br><span class="line"> raspi-config</span><br><span class="line"> rc-gui</span><br><span class="line"> x11-utils</span><br><span class="line"> x2x</span><br><span class="line"> xfonts-100dpi</span><br><span class="line"> xfonts-base</span><br><span class="line"> xinit</span><br><span class="line"> xserver-common</span><br><span class="line"> fake-hwclock</span><br><span class="line"> triggerhappy</span><br><span class="line">E: Sub-process /usr/bin/dpkg returned an error code (1)</span><br><span class="line">pi@raspberrypi:~ $ sudo service motion start</span><br><span class="line">pi@raspberrypi:~ $ sudo motion</span><br><span class="line">[0] [NTC] [ALL] conf_load: Processing thread 0 - config file /etc/motion/motion.conf</span><br><span class="line">[0] [ALR] [ALL] conf_cmdparse: Unknown config option &quot;sdl_threadnr&quot;</span><br><span class="line">[0] [NTC] [ALL] motion_startup: Motion 3.2.12+git20140228 Started</span><br><span class="line">[0] [NTC] [ALL] motion_startup: Logging to syslog</span><br><span class="line">[0] [NTC] [ALL] motion_startup: Using log type (ALL) log level (NTC)</span><br><span class="line">[0] [NTC] [ALL] become_daemon: Motion going to daemon mode</span><br><span class="line">[0] [NTC] [ALL] create_path: creating directory /var/run/motion</span><br><span class="line">pi@raspberrypi:~ $ sudo nano /etc/default/motion</span><br><span class="line">pi@raspberrypi:~ $ sudo nano /etc/motion/motion.conf</span><br><span class="line">pi@raspberrypi:~ $ sudo nano /etc/motion/motion.conf</span><br><span class="line">pi@raspberrypi:~ $ motion</span><br><span class="line">[0] [ALR] [ALL] conf_load: could not open configfile /etc/motion/motion.conf:</span><br><span class="line">[0] [CRT] [ALL] conf_load: Not config file to process using default values</span><br><span class="line">[0] [NTC] [ALL] motion_startup: Using default log level (NTC) (6)</span><br><span class="line">[0] [NTC] [ALL] motion_startup: Motion 3.2.12+git20140228 Started</span><br><span class="line">[0] [NTC] [ALL] motion_startup: Logging to syslog</span><br><span class="line">[0] [NTC] [ALL] motion_startup: Using default log type (ALL)</span><br><span class="line">[0] [NTC] [ALL] motion_startup: Using log type (ALL) log level (NTC)</span><br><span class="line">[0] [NTC] [ENC] ffmpeg_init: ffmpeg LIBAVCODEC_BUILD 3670016 LIBAVFORMAT_BUILD 3670272</span><br><span class="line">[0] [NTC] [ALL] main: Thread 1 is device: /dev/video0 input -1</span><br><span class="line">[0] [NTC] [ALL] main: Stream port 0</span><br><span class="line">[0] [NTC] [ALL] main: Waiting for threads to finish, pid: 3045</span><br><span class="line">[1] [NTC] [ALL] motion_init: Thread 1 started , motion detection Enabled</span><br><span class="line">[1] [NTC] [VID] vid_v4lx_start: Using videodevice /dev/video0 and input -1</span><br><span class="line">[1] [NTC] [VID] v4l2_get_capability:</span><br><span class="line">------------------------</span><br><span class="line">cap.driver: &quot;bm2835 mmal&quot;</span><br><span class="line">cap.card: &quot;mmal service 16.1&quot;</span><br><span class="line">cap.bus_info: &quot;platform:bcm2835-v4l2&quot;</span><br><span class="line">cap.capabilities=0x85200005</span><br><span class="line">------------------------</span><br><span class="line">[1] [NTC] [VID] v4l2_get_capability: - VIDEO_CAPTURE</span><br><span class="line">[1] [NTC] [VID] v4l2_get_capability: - VIDEO_OVERLAY</span><br><span class="line">[1] [NTC] [VID] v4l2_get_capability: - READWRITE</span><br><span class="line">[1] [NTC] [VID] v4l2_get_capability: - STREAMING</span><br><span class="line">[1] [NTC] [VID] v4l2_select_input: name = &quot;Camera 0&quot;, type 0x00000002, status 00000000</span><br><span class="line">[1] [NTC] [VID] v4l2_select_input: - CAMERA</span><br><span class="line">[1] [WRN] [VID] v4l2_select_input: Device doesn&#x27;t support VIDIOC_G_STD</span><br><span class="line">[1] [NTC] [VID] v4l2_do_set_pix_format: Testing palette YU12 (352x288)</span><br><span class="line">[1] [ERR] [VID] v4l2_do_set_pix_format: Error setting pixel format.</span><br><span class="line">VIDIOC_S_FMT: :</span><br><span class="line">[1] [NTC] [VID] v4l2_set_pix_format: Config palette index 17 (YU12) doesn&#x27;t work.</span><br><span class="line">[1] [NTC] [VID] v4l2_set_pix_format: Supported palettes:</span><br><span class="line">[1] [NTC] [VID] v4l2_set_pix_format: (0) YU12 (Planar YUV 4:2:0)</span><br><span class="line">[1] [NTC] [VID] v4l2_set_pix_format: 0 - Planar YUV 4:2:0 (compressed : 0) (0x32315559)</span><br><span class="line">[1] [NTC] [VID] v4l2_set_pix_format: (1) YUYV (YUYV 4:2:2)</span><br><span class="line">[1] [NTC] [VID] v4l2_set_pix_format: 1 - YUYV 4:2:2 (compressed : 0) (0x56595559)</span><br><span class="line">[1] [NTC] [VID] v4l2_set_pix_format: (2) RGB3 (24-bit RGB 8-8-8)</span><br><span class="line">[1] [NTC] [VID] v4l2_set_pix_format: 2 - 24-bit RGB 8-8-8 (compressed : 0) (0x33424752)</span><br><span class="line">[1] [NTC] [VID] v4l2_set_pix_format: (3) JPEG (JFIF JPEG)</span><br><span class="line">[1] [NTC] [VID] v4l2_set_pix_format: 3 - JFIF JPEG (compressed : 1) (0x4745504a)</span><br><span class="line">[1] [NTC] [VID] v4l2_set_pix_format: (4) H264 (H.264)</span><br><span class="line">[1] [NTC] [VID] v4l2_set_pix_format: 4 - H.264 (compressed : 1) (0x34363248)</span><br><span class="line">[1] [NTC] [VID] v4l2_set_pix_format: (5) MJPG (Motion-JPEG)</span><br><span class="line">[1] [NTC] [VID] v4l2_set_pix_format: 5 - Motion-JPEG (compressed : 1) (0x47504a4d)</span><br><span class="line">[1] [NTC] [VID] v4l2_set_pix_format: (6) YVYU (YVYU 4:2:2)</span><br><span class="line">[1] [NTC] [VID] v4l2_set_pix_format: 6 - YVYU 4:2:2 (compressed : 0) (0x55595659)</span><br><span class="line">[1] [NTC] [VID] v4l2_set_pix_format: (7) VYUY (VYUY 4:2:2)</span><br><span class="line">[1] [NTC] [VID] v4l2_set_pix_format: 7 - VYUY 4:2:2 (compressed : 0) (0x59555956)</span><br><span class="line">[1] [NTC] [VID] v4l2_set_pix_format: (8) UYVY (UYVY 4:2:2)</span><br><span class="line">[1] [NTC] [VID] v4l2_set_pix_format: 8 - UYVY 4:2:2 (compressed : 0) (0x59565955)</span><br><span class="line">[1] [NTC] [VID] v4l2_set_pix_format: (9) NV12 (Y/CbCr 4:2:0)</span><br><span class="line">[1] [NTC] [VID] v4l2_set_pix_format: 9 - Y/CbCr 4:2:0 (compressed : 0) (0x3231564e)</span><br><span class="line">[1] [NTC] [VID] v4l2_set_pix_format: (10) BGR3 (24-bit BGR 8-8-8)</span><br><span class="line">[1] [NTC] [VID] v4l2_set_pix_format: 10 - 24-bit BGR 8-8-8 (compressed : 0) (0x33524742)</span><br><span class="line">[1] [NTC] [VID] v4l2_set_pix_format: (11) YV12 (Planar YVU 4:2:0)</span><br><span class="line">[1] [NTC] [VID] v4l2_set_pix_format: 11 - Planar YVU 4:2:0 (compressed : 0) (0x32315659)</span><br><span class="line">[1] [NTC] [VID] v4l2_set_pix_format: (12) NV21 (Y/CrCb 4:2:0)</span><br><span class="line">[1] [NTC] [VID] v4l2_set_pix_format: 12 - Y/CrCb 4:2:0 (compressed : 0) (0x3132564e)</span><br><span class="line">[1] [NTC] [VID] v4l2_set_pix_format: (13) RX24 (32-bit XBGR 8-8-8-8)</span><br><span class="line">[1] [NTC] [VID] v4l2_set_pix_format: 13 - 32-bit XBGR 8-8-8-8 (compressed : 0) (0x34325852)</span><br><span class="line">[1] [NTC] [VID] v4l2_set_pix_format Selected palette YU12</span><br><span class="line">[1] [NTC] [VID] v4l2_do_set_pix_format: Testing palette YU12 (352x288)</span><br><span class="line">[1] [ERR] [VID] v4l2_do_set_pix_format: Error setting pixel format.</span><br><span class="line">VIDIOC_S_FMT: :</span><br><span class="line">[1] [ERR] [VID] VIDIOC_TRY_FMT failed for format v4l2_set_pix_format:</span><br><span class="line">[1] [ERR] [VID] v4l2_set_pix_format: Unable to find a compatible palette format.</span><br><span class="line">[1] [NTC] [VID] vid_v4lx_start: Using V4L1</span><br><span class="line">[1] [NTC] [ALL] image_ring_resize: Resizing pre_capture buffer to 1 items</span><br><span class="line">[1] [ERR] [ALL] motion_init: Error capturing first image</span><br><span class="line">[1] [ERR] [ALL] motion_loop: Video device fatal error - Closing video device</span><br><span class="line">[1] [NTC] [VID] vid_close: Closing video device /dev/video0</span><br><span class="line">^C[1] [NTC] [ALL] motion_loop: End of event 1</span><br><span class="line">[1] [NTC] [ALL] motion_loop: Thread exiting</span><br><span class="line">[0] [NTC] [ALL] main: Threads finished</span><br><span class="line">[0] [NTC] [ALL] main: Motion terminating</span><br><span class="line">pi@raspberrypi:~ $ sudo nano /etc/motion/motion.conf</span><br><span class="line">pi@raspberrypi:~ $ sudo killall -TERM motion</span><br><span class="line">pi@raspberrypi:~ $ sudo motion</span><br><span class="line">[0] [NTC] [ALL] conf_load: Processing thread 0 - config file /etc/motion/motion.conf</span><br><span class="line">[0] [ALR] [ALL] conf_cmdparse: Unknown config option &quot;sdl_threadnr&quot;</span><br><span class="line">[0] [NTC] [ALL] motion_startup: Motion 3.2.12+git20140228 Started</span><br><span class="line">[0] [NTC] [ALL] motion_startup: Logging to syslog</span><br><span class="line">[0] [NTC] [ALL] motion_startup: Using log type (ALL) log level (NTC)</span><br><span class="line">[0] [NTC] [ALL] become_daemon: Motion going to daemon mode</span><br><span class="line">pi@raspberrypi:~ $ sudo killall -TERM motion</span><br></pre></td></tr></table></figure>
<p>都说了没后文了…依赖还是有问题但不影响使用就暂且装死..</p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>树莓派</tag>
        <tag>ARM</tag>
        <tag>shell</tag>
      </tags>
  </entry>
  <entry>
    <title>MSP430单片机(三)——I/O口操作</title>
    <url>/2020/11/18/MSP430%E5%8D%95%E7%89%87%E6%9C%BA%E5%85%A5%E9%97%A8(3)%E2%80%94%E2%80%94IO%E6%93%8D%E4%BD%9C/</url>
    <content><![CDATA[<blockquote>
<p>学习了MSP430单片机的一些基础操作，如I/O口和看门狗的使用，以及低功耗模式。</p>
</blockquote>
<a id="more"></a>

<h3 id="1-逻辑操作"><a href="#1-逻辑操作" class="headerlink" title="1. 逻辑操作"></a>1. 逻辑操作</h3><p>I/O和寄存器需要涉及到很多运算符的操作，先简要复习一下C语言中运算符的使用方法做个备忘。</p>
<p><strong>与、&amp; 、AND</strong>：<code>1 &amp; 1 = 1，1 &amp; 0 = 0</code>，<strong>有0为0</strong></p>
<p><strong>或、| 、OR</strong>：<code>1 | 1 = 1</code>，<code>1 | 0 = 1</code> ，<strong>有1为1</strong></p>
<p><strong>异或、^ 、XOR</strong>：<code>1 ^ 0 = 1,0 ^ 1 = 1, 1 ^ 1 = 0, 0 ^ 0 = 0</code> ，<strong>不同为1</strong></p>
<p><strong>取反、~ **：<code> ~ 1 = 0,  ~ 0 = 1</code> ，</strong>01互换**</p>
<h3 id="2-GPIO口概述"><a href="#2-GPIO口概述" class="headerlink" title="2. GPIO口概述"></a>2. GPIO口概述</h3><blockquote>
<p>在前面的示例程序中我们发现对单片机进行编程实际上就是改写寄存器的值。单片机各个外设的功能其实是预先固定的，而寄存器就像是这些功能的控制接口，通过改变寄存器的值就可以在这些功能中进行选择。还有一些寄存器直接对应引脚的状态，例如GPIO的输入/输出寄存器。像以下语句： <code>P1OUT = 0x01</code> ;</p>
<p>这句话其实就是赋值给P1OUT这个寄存器，这个寄存器是GPIO的输出寄存器，赋值之后对应引脚的输出状态就会发生改变。</p>
<p>P1OUT寄存器共有8位，分别是从P1.0-P1.7。要给这个寄存器赋值，其实就是写入一个8位的二进制数值，例如00000001。在C语言中，为了尽量精简代码，一般把这个8位二进制数换算成2位16进制数，前面加上“0x”表示这是一个16进制的值。这样二进制的00000001也可以表示为0x01，那么上面一句P1OUT =0x01实际上是把P1.0赋值为1，P1.1-P1.7赋值为0。</p>
<p>——<a href="https://bbs.nuedc-training.com.cn/thread-292-1-1.html">MSP430G2 LaunchPad入门系列第1篇 - MSP430简介及CCS开发环境</a></p>
</blockquote>
<p>单片机最基础的功能是通过引脚来控制或者采集外部电路的接口，这是我们知道的单片机最基础的功能。</p>
<p>不同的单片机可以提供一个或多个8位I/O口，引脚的数量越多，芯片提供的I/O口就越多，相应的功能也更丰富一点；</p>
<p>例如 8051 提供了 P0、P1、P2、P3这四组IO：</p>
<table>
<thead>
<tr>
<th align="center">I/O口</th>
<th align="center">引脚</th>
<th align="center">第一功能</th>
<th align="center">第二功能</th>
</tr>
</thead>
<tbody><tr>
<td align="center">P0口</td>
<td align="center">P0.0~P0.7</td>
<td align="center">输入与输出</td>
<td align="center">分时的传送地址低8位与数据线</td>
</tr>
<tr>
<td align="center">P1口</td>
<td align="center">P1.0~P1.7</td>
<td align="center">输入与输出</td>
<td align="center">无第二功能</td>
</tr>
<tr>
<td align="center">P2口</td>
<td align="center">P2.0~P2.7</td>
<td align="center">输入与输出</td>
<td align="center">传送地址的高八位</td>
</tr>
<tr>
<td align="center">P3口</td>
<td align="center">P3.0~P3.7</td>
<td align="center">输入与输出</td>
<td align="center">P3.0——RXD：串行口输入端</td>
</tr>
<tr>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center">P3.1——TXD：串行口输出端</td>
</tr>
<tr>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center">P3.2——INT0 ：外部中断0中断请求输入端</td>
</tr>
<tr>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center">P3.3——INT1 ：外部中断1中断请求输入端</td>
</tr>
<tr>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center">P3.4——T0：定时器/计数器0外部输入端</td>
</tr>
<tr>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center">P3.5——T1：定时器/计数器1外部输入端</td>
</tr>
<tr>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center">P3.6——WR：外部数据存储器写选通信号</td>
</tr>
<tr>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
<td align="center">P3.7——RD：外部数据存储器读选通信号</td>
</tr>
</tbody></table>
<p><strong>MSP430特点：</strong></p>
<ul>
<li><p>类型丰富：MSP430提供了12组IO口，分别是 P1-P11，PJ.，以及S、COM端口。其中除了第十一P11的宽度是3位，其他的端口全是8为宽度;</p>
<p>  相邻的端口可以组合成端口对，分别命名为 PA、PB、PC、PD等，通过字节(byte)形式访问 <code>单独端口</code>，通过字(word)的形式访问 <code>端口对</code>;</p>
</li>
<li><p>功能丰富：P1和P2具有9个（或7个）寄存器，其他有6个（或4个）寄存器</p>
<ul>
<li>每个I/O口可单独编程</li>
<li>输入和输出可任意组合</li>
<li>P1、P2所有I/O口都具有边沿可选的输入中断功能</li>
<li>能使用指令对寄存器操作</li>
<li>可设置I/O口上拉或者下拉</li>
<li>配置I/O驱动能力</li>
</ul>
</li>
<li><p>输出特性：MSP430只有数据端口，可用端口的某一位或几位来传送状态信息来确定外设状态；</p>
<p>  MSP430输入端口的最大漏电流为50na，输入端口的漏电流对系统的耗电影响很大；</p>
<p>  每个端口的输出晶体管都能够限制输出电流（最大约为25mA）</p>
</li>
</ul>
<p><strong>MSP430的I/O口功能：</strong></p>
<ul>
<li>PxDIR输入/输出方向寄存器：<strong>作为输入时，只能读，作为输出时，可读可写</strong></li>
<li>PxIN输入寄存器：是<strong>只读</strong>寄存器，用户不能对其写入</li>
<li>PxOUT输出寄存器：可读可写</li>
<li>PxREN上拉或下拉电阻使能寄存器（提高信号的驱动能力）：该寄存器的每一位可以使能或禁用I/O引脚的上拉/下拉电阻——0为禁止，1为使能</li>
<li>PxSEL功能选择寄存器：P1和P2端口还具有其他片内外设功能，0-选择引脚为I/O端口，1-选择引脚为外围模块功能</li>
<li>PxDS输出驱动强度寄存器：每位设置引脚的输出强度为高驱动强度（“1”）或低驱动强度（“0”），默认值为低驱动强度</li>
<li>PxIE中断使能寄存器：该寄存器的8位与该端口的8个引脚一一对应，某一位置位表示允许对应的引脚在电平变化（上升沿或下降沿）时产生中断</li>
<li>PxIES中断触发沿选择寄存器：如果允许Px口某个引脚中断，还需定义该引脚的中断触发方式，该寄存器8位对应Px口的8个引脚（”0：上升沿使相应标志置位，1：下降沿使相应标志置位“）</li>
<li>PxIFG中断标志寄存器：用来表示对应引脚是否产生了有PxIES设定的电平跳变，如果GIE置位，引脚对应的中断使能寄存器PxIE位置位，则会向CPU请求中断处理</li>
</ul>
<h3 id="3-I-O寄存器"><a href="#3-I-O寄存器" class="headerlink" title="3. I/O寄存器"></a>3. I/O寄存器</h3><p>​    (1)<strong>PxDIR</strong>：输入/输出方向寄存器</p>
<p>​        相互独立的8位分别定义了8个引脚的输入/输出方向。8位在PUC后都被复位。使用输入和输出功能时，应该先定义端口的方向，输入/输出才能满足设计者的要求。</p>
<p>​            0：输入模式；</p>
<p>​            1：输出模式。</p>
<p>​    (2)<strong>PxIN</strong>：输入寄存器</p>
<p>​        输入寄存器是 <strong>只读</strong>寄存器。用户不能对它进行写入，只能通过该寄存器内容知道I/O端口的输入信号。此时引脚方向必须选定为输入。</p>
<p>​     (3) <strong>PxOUT</strong>：输出寄存器</p>
<p>​        该寄存器为I/O端口的输出缓冲寄存器，在读取时输出缓存内容与引脚方向定义无关。</p>
<p>​     (4) <strong>PxIFG</strong>：中断标志寄存器</p>
<p>​        该寄存器有8个标志位，标志相应引脚是否有待处理中断的信息，即相应引脚是否有中断请求。寄存器定义如下：</p>
<table>
<thead>
<tr>
<th align="center">7</th>
<th align="center">6</th>
<th align="center">5</th>
<th align="center">4</th>
<th align="center">3</th>
<th align="center">2</th>
<th align="center">1</th>
<th align="center">0</th>
</tr>
</thead>
<tbody><tr>
<td align="center">PxIFG</td>
<td align="center">PxIFG.6</td>
<td align="center">PxIFG.5</td>
<td align="center">PxIFG.4</td>
<td align="center">PxIFG.3</td>
<td align="center">PxIFG.2</td>
<td align="center">PxIFG.1</td>
<td align="center">PxIFG.0</td>
</tr>
</tbody></table>
<p>​            0：没有中断请求；</p>
<p>​            1：有中断请求。</p>
<p>​     (5) <strong>PxIES</strong>：中断触发沿选择寄存器</p>
<p>​        如果允许Px口的某个引脚中断，还需定义该引脚的中断触发方式。该寄存器的8位分别对应Px口的8个引脚。</p>
<p>​            0：上升沿使相应标志置位</p>
<p>​            1：下降沿使相应标志置位</p>
<p>​      (6) <strong>PxIE</strong>：中断使能寄存器</p>
<p>​         Px口的每一个引脚都有一位用以控制该引脚是否允许中断。该寄存器定义如下：</p>
<table>
<thead>
<tr>
<th align="center">7</th>
<th align="center">6</th>
<th align="center">5</th>
<th align="center">4</th>
<th align="center">3</th>
<th align="center">2</th>
<th align="center">1</th>
<th align="center">0</th>
</tr>
</thead>
<tbody><tr>
<td align="center">PxIE.7</td>
<td align="center">PxIE.6</td>
<td align="center">PxIE.5</td>
<td align="center">PxIE.4</td>
<td align="center">PxIE.3</td>
<td align="center">PxIE.2</td>
<td align="center">PxIE.1</td>
<td align="center">PxIE.0</td>
</tr>
</tbody></table>
<p>​            0：禁止中断；</p>
<p>​            1：允许中断。</p>
<p>​     (7) <strong>PxSEL</strong>：功能选择寄存器</p>
<p>​        P1和P2俩端口还具有其他片内外设功能，这些功能与芯片外的联系通过复用P1和P2引脚的方式来实现。P1SEL和P2SEL用来选择引脚的I/O端口功能与外围模块功能。</p>
<p>​            0：选择引脚位I/O模式；</p>
<p>​            1：选择引脚为外围模块功能。</p>
<p>端口P3、P4、P5和P6没有中断能力，其余功能同P1和P2，可以实现输入/输出功能和外围模块功能。四个寄存器可以对它们进行访问和控制，这四个寄存器分别是<strong>PxDIR</strong>，PxIN，<strong>PxOUT</strong>，<strong>PxSEL</strong>，定义和用法同P1、P2端口。</p>
<h3 id="4-I-O口操作"><a href="#4-I-O口操作" class="headerlink" title="4.  I/O口操作"></a>4.  I/O口操作</h3><p>430不支持直接对位操作，需要使用屏蔽符和掩码来实现修改寄存器的某一位而不影响其他位的目的。BIT0~F分别对16位寄存器操作。</p>
<p>配置MSP430的寄存器可以用两种方法来实现：</p>
<ol>
<li><p>最直接的方式，直接给寄存器赋值，如 <code>P1DIR = 0x81</code>；</p>
</li>
<li><p>利用msp430官方库文件中宏定义，更直观地表示要操作地寄存器：</p>
</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BIT0                (0x0001u)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BIT1                (0x0002u)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BIT2                (0x0004u)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BIT3                (0x0008u)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BIT4                (0x0010u)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BIT5                (0x0020u)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BIT6                (0x0040u)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BIT7                (0x0080u)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BIT8                (0x0100u)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BIT9                (0x0200u)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BITA                (0x0400u)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BITB                (0x0800u)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BITC                (0x1000u)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BITD                (0x2000u)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BITE                (0x4000u)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BITF                (0x8000u)</span></span><br></pre></td></tr></table></figure>
<p><code>PxDIR = 0x81</code> 就可以改写成 <code>PxDIR = BIT0 + BIT7</code> ，可以省去计算寄存器换算16进制的值；</p>
<ol start="3">
<li>驱动库中提供了一个函数GPIO_setAsInputPin()来将I/O口配置为输出。</li>
</ol>
<h4 id="4-1-PxDIR"><a href="#4-1-PxDIR" class="headerlink" title="4.1 PxDIR"></a>4.1 PxDIR</h4><p>设置IO口方向，0-输入，1-输出。如P1.5、P1.6、P1.7 接有按键，P1.1、P1.3、P1.4接有LED，那么P1.5、P1.6、P1.7 要设为输入，P1.1、P1.3、P1.4 要设为输出：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">P1DIR|=BIT1+BIT3+BIT4; <span class="comment">// P1.1、P1.3、P1.4设为输出</span></span><br><span class="line"></span><br><span class="line">P1DIR &amp;=~ (BIT5+BIT6+BIT7); <span class="comment">// P1.5、P1.6、P1.7设为输入</span></span><br></pre></td></tr></table></figure>
<p>PxDIR 寄存器在复位过程中会被清0，没有被设置的IO口方向均为输入状态，因此<strong>第二句可以被省略</strong>。</p>
<h4 id="4-2-PxOUT和PxIN"><a href="#4-2-PxOUT和PxIN" class="headerlink" title="4.2 PxOUT和PxIN"></a>4.2 PxOUT和PxIN</h4><p>对于所有已经设成输出状态的IO口，可以通过 <code>PxOUT</code> 寄存器设置其输出电平（当IO口配置为输入模式并且置高/置低使能时， <code>PxOUT</code> 寄存器：0置低1置高）；</p>
<p>对于所有已经被设成输入状态的IO口，可以通过 <code>PxIN</code> 寄存器读回其输入电平。</p>
<p>如判断P1.5口上的开关状态，若低电平则从P1.1口输出高电平点亮LED：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(( P1IN &amp; BIT5) ==<span class="number">0</span> )  P1OUT|=BIT1;  <span class="comment">//若P1.5为低电平则P1.1输出高电平</span></span><br></pre></td></tr></table></figure>
<h4 id="4-3-PxSEL"><a href="#4-3-PxSEL" class="headerlink" title="4.3 PxSEL"></a>4.3 PxSEL</h4><p>用于设置每一位IO的功能： 0=普通IO口 1=第二功能。</p>
<p>例如MSP4305418A中P5.6和P5.7和串口的TXD、RXD公用引脚，如果需要将两个引脚配置成串口收发脚，需将P5SEL的6，7位置高：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">P5SEL |= BIT6 + BIT7; 	<span class="comment">// P2.4,5 设为串口收发引脚</span></span><br></pre></td></tr></table></figure>
<h4 id="4-4-PxIE和PxIES"><a href="#4-4-PxIE和PxIES" class="headerlink" title="4.4 PxIE和PxIES"></a>4.4 PxIE和PxIES</h4><p>PxIE寄存器用于设置每一位IO的中断允许： 0=不允许 1=允许</p>
<p>PxIES寄存器用于选择每一位IO的中断触发沿： 0=上升沿 1=下降沿</p>
<p><strong>使用方法：</strong> 使用IO口中断之前，需要先将IO 口<strong>设为输入状态</strong>，并<strong>允许该位IO的中断</strong>，再通过PxIES寄存器选择触发方式为上升沿触发或者下降沿触发。</p>
<p>例如将P1.5、P1.6、P1.7 口设为中断源，下降沿触发：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">P1DIR &amp;=~(BIT5 + BIT6 + BIT7); <span class="comment">// P1.5、P1.6、P1.7设为输入(可省略)</span></span><br><span class="line"></span><br><span class="line">P1IES |= BIT5 + BIT6 + BIT7; <span class="comment">// P1.5、P1.6、P1.7设为下降沿中断</span></span><br><span class="line"></span><br><span class="line">P1IE |= BIT5 + BIT6 + BIT7; <span class="comment">// 允许P1.5、P1.6、P1.7中断</span></span><br><span class="line"></span><br><span class="line">EINT(); <span class="comment">// 总中断允许</span></span><br></pre></td></tr></table></figure>
<h4 id="4-5-PxIFG"><a href="#4-5-PxIFG" class="headerlink" title="4.5 PxIFG"></a>4.5 PxIFG</h4><p>PxIFG寄存器是IO中断标志寄存器：0=中断条件不成立1=中断条件曾经成立过.</p>
<p>这个寄存器存在的目的是为了尽可能地不漏掉每一次中断。</p>
<p>例如P1.5、P1.6、P1.7 发生中断后执行不同的代码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> vector = PORT1_VECTOR <span class="comment">//P1口中断源</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">__interrupt <span class="keyword">void</span> <span class="title">P1_ISR</span><span class="params">(<span class="keyword">void</span>)</span> <span class="comment">//声明一个中断服务程序，名为P1_ISR()</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(P1IFG &amp; BIT5) <span class="comment">//判断P1中断标志第5位(P1.5)</span></span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">	... ... <span class="comment">//在这里写P1.5中断处理程序</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(P1IFG &amp; BIT6) <span class="comment">//判断P1中断标志第6位(P1.6)</span></span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">	... ... <span class="comment">//在这里写P1.6中断处理程序</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(P1IFG &amp; BIT7) <span class="comment">//判断P1中断标志第7位(P1.7)</span></span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">	... ... <span class="comment">//在这里写P1.7中断处理程序</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">P1IFG=<span class="number">0</span>； <span class="comment">//清除P1所有中断标志位</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>PxIFG</code> 的中断操作比较灵活，既可以被动执行中断判断，也可以通过主动向写 <code>PxIFG</code> 寄存器相应位写“1”。</p>
<p>因此，更改 <code>PxIES</code> 应该在<strong>关闭中断后进行</strong>，并在打开中断之前<strong>及时清除中断标志</strong>。</p>
<h3 id="5-例程"><a href="#5-例程" class="headerlink" title="5. 例程"></a>5. 例程</h3><p>使用TI官方提供的点亮LED的程序来进行430的入门操作——操作I/O口。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//*******************************************************************************</span></span><br><span class="line"><span class="comment">//  MSP-FET430P140 Demo - Software Toggle P1.0</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  Description: Toggle P1.0 by xor&#x27;ing P1.0 inside of a software loop.</span></span><br><span class="line"><span class="comment">//  ACLK= n/a, MCLK= SMCLK= default DCO ~800k</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//                MSP430F149</span></span><br><span class="line"><span class="comment">//             -----------------</span></span><br><span class="line"><span class="comment">//         /|\|              XIN|-</span></span><br><span class="line"><span class="comment">//          | |                 |</span></span><br><span class="line"><span class="comment">//          --|RST          XOUT|-</span></span><br><span class="line"><span class="comment">//            |                 |</span></span><br><span class="line"><span class="comment">//            |             P1.0|--&gt;LED</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//  M. Buccini</span></span><br><span class="line"><span class="comment">//  Texas Instruments Inc.</span></span><br><span class="line"><span class="comment">//  Feb 2005</span></span><br><span class="line"><span class="comment">//  Built with IAR Embedded Workbench Version: 3.21A</span></span><br><span class="line"><span class="comment">//******************************************************************************</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span>  <span class="meta-string">&lt;msp430x14x.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  WDTCTL = WDTPW + WDTHOLD;                 <span class="comment">// 停止看门狗</span></span><br><span class="line">  P1DIR |= <span class="number">0x01</span>;                            <span class="comment">// Set P1.0 to output direction</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (;;)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">     P1OUT ^= <span class="number">0x01</span>;                          <span class="comment">// Toggle P1.0 using exclusive-OR</span></span><br><span class="line"></span><br><span class="line">     i = <span class="number">50000</span>;                              <span class="comment">// Delay</span></span><br><span class="line">     <span class="keyword">do</span> (i--);</span><br><span class="line">     <span class="keyword">while</span> (i != <span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="程序流程"><a href="#程序流程" class="headerlink" title="程序流程"></a>程序流程</h4><p>​    1.关看门狗；2.设置I/O口；3.延时、循环输出    </p>
<h4 id="源码解释"><a href="#源码解释" class="headerlink" title="源码解释"></a>源码解释</h4><ol>
<li> 关看门狗</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">WDTCTL = WDTPW + WDTHOLD;                 <span class="comment">// 停止看门狗</span></span><br></pre></td></tr></table></figure>
<p>这句话实现了关开门狗的功能，要想理解这句话需要先查看官方的芯片手册：</p>
<img src="/upload_image/image-20201107163354835.png" alt="image-20201107163354835" style="zoom:50%;" />

<p><code>WDTPW</code>：读取时必须是<code>069h</code>，写的时候必须是<code>05Ah</code>，否则就会出现一个PUC信号导致单片机复位</p>
<p><code>WDTHOLD</code>：置为<code>1</code>时看门狗被停止</p>
<p>在头文件<code>msp430x14x.h</code>中查看<code>WDTPW</code>、<code>WDTHOLD</code>的宏定义</p>
<p>430的库文件对这两个“变量”的宏定义如下:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> WDTHOLD             (0x0080u)  	<span class="comment">/* WDT - Timer hold */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> WDTPW               (0x5A00u)	</span></span><br></pre></td></tr></table></figure>
<p><code>WDTPW</code>为5A表示写入，<code>WDTHOLD</code>为80，高位为1，地位为0，表示关闭看门狗。</p>
<p>将两个数相加，送入<code>WDTCTL</code>实现关门狗；如果缺失其中一个会导致产生一个PUC信号使单片机复位。</p>
<p>​    2. 设置I/O口</p>
<p>​          <code>P1DIR |= 0x01;                            // 提取01口，设置P1.1为输出</code></p>
<img src="/upload_image/image-20201119165324316.png" alt="image-20201119165324316" style="zoom:67%;" />

<p>​    如上图，端口（Port）P1和P2具有输入/输出、中断和外部模块功能，这些功能可以通过它们各自的7个控制寄存器的设置来实现。</p>
<p>​    这里P1.1端口默认无输出，而P1.3-1.6，P1.7-1.8都是默认输入(00h)</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">P1OUT ^= <span class="number">0x01</span>;                          <span class="comment">// Toggle P1.0 using exclusive-OR</span></span><br></pre></td></tr></table></figure>
<ol start="3">
<li>延时、循环输出</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">P1OUT ^= <span class="number">0x01</span>;                          <span class="comment">// Toggle P1.0 using exclusive-OR</span></span><br></pre></td></tr></table></figure>
<p>这句指令又可写成     <code>P1OUT = P1OUT ^ 0x01;</code> 每次对第四位进行异或，改为输出。0 ^ 1，循环之后又变成1 ^ 1，实现闪烁。 </p>
]]></content>
      <categories>
        <category>嵌入式开发</category>
      </categories>
      <tags>
        <tag>嵌入式</tag>
        <tag>驱动开发</tag>
        <tag>MSP430</tag>
        <tag>C/C++</tag>
        <tag>编程语法</tag>
      </tags>
  </entry>
</search>
